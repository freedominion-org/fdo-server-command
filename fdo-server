#!/bin/sh

# Copyright (c) 2016 Euan Thoms <euan@potensol.com>.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

##### GLOBAL STATIC VARIABLE DECLARATIONS ##########

TERM="xterm"
LRED="\033[1;31m"
LGRN="\033[1;32m"
LBLU="\033[1;34m"
LCYN="\033[1;36m"
CYAN="\033[0;36m"
YELL="\033[1;33m"
ORNG="\033[0;33m"
GREY="\033[0;37m"
DGRY="\033[1;30m"
NRML="\033[0;00m"
CARRIAGE_RETURN="
"


SCRIPT_NAME=`basename $0`
DEBUG=${DEBUG:-false}
DIALOG_OUT_FILE="/tmp/${SCRIPT_NAME}.dialog.answer"
REPO_NAME=${REPO_NAME:-"fdo-server"}
UCL_CMD="/usr/local/bin/uclcmd"
FDO_CONFIG_ROOT=${FDO_CONFIG_ROOT:-"/usr/local/etc/fdo"}
HOST_CONF_PATH=${HOST_CONF_PATH:-"${FDO_CONFIG_ROOT}/host.conf"}
RECIPE_CONF_PATH=${RECIPE_CONF_PATH:-"${FDO_CONFIG_ROOT}/recipe.conf"}
LOGIN_SHELL=${LOGIN_SHELL:-"/usr/local/bin/bash"}
FDO_SERVER_SKELETON_REPO=${FDO_SERVER_SKELETON_REPO:-"https://github.com/freedominion-org/fdo-server.git"}
REPO_URI=`cat "${FDO_CONFIG_ROOT}/fdo-server-repo.conf" 2> /dev/null`
FETCH_LATEST_SELF_URL=${FETCH_LATEST_SELF_URL:-"http://freedominion.org/"}
ESSENTIAL_PACKAGES="apcupsd axel bash bash-completion bsdadminscripts2 cpdup curl dmidecode git p7zip"
ESSENTIAL_PACKAGES="${ESSENTIAL_PACKAGES} py27-speedtest-cli rsync stress tmux tree uclcmd unrar unzip zfs-stats-lite zip nmap vim-console"
PKG_REPO_CONF_FILE="FDo-pkg.conf"
PKG_REPO_CERT_FILE="FDo-pkg.cert"

LATEST_HOST_SYS_COMPAT=1
LATEST_HOTDESK_SUBSYS_COMPAT=1
LATEST_SSHFSD_SUBSYS_COMPAT=1
LATEST_JAILS_SUBSYS_COMPAT=1
LATEST_VMS_SUBSYS_COMPAT=1
LATEST_PARTIMAG_SUBSYS_COMPAT=1


ESSENTIAL_JAIL_PACKAGES="axel bash bash-completion bsdadminscripts2 cpdup curl portmaster rsync tree unrar unzip zip vim-console"


HOTDESK_ROOT_FS=${HOTDESK_ROOT_FS:-"fdo-hotdesk-home"}
HOTDESK_ROOT_MP=${HOTDESK_ROOT_MP:-"/fdo-hotdesk-home"}
HOTDESK_CONF_PATH=${HOTDESK_CONF_PATH:-"${FDO_CONFIG_ROOT}/hotdesk.conf"}


PARTIMAG_ROOT_FS=${PARTIMAG_ROOT_FS:-"partimag"}
PARTIMAG_ROOT_MP=${PARTIMAG_ROOT_MP:-"/usr/home/partimag"}
PARTIMAG_CONF_PATH=${PARTIMAG_CONF_PATH:-"${FDO_CONFIG_ROOT}/partimag.conf"}


SSHFS_DAEMON_PACKAGES="fusefs-sshfs"


VM_SUBSYSTEM_PACKAGES="bhyve-firmware"
VMS_CONF_PATH=${VMS_CONF_PATH:-"${FDO_CONFIG_ROOT}/vms.conf"}
VMS_ROOT_FS="fdo-vms"
VMS_ROOT_PATH="/${VMS_ROOT_FS}"
VM_RESOURCES_DIRNAME="resources"
VM_TEMPLATES_DIRNAME="templates"
VM_INSTANCES_DIRNAME="instances"
VM_RESOURCES_PATH="${VMS_ROOT_PATH}/${VM_RESOURCES_DIRNAME}"
VM_NAME_MIN=3
VM_NAME_MAX=30
VM_MIN_CORES=1
VM_MAX_CORES=16
VM_MIN_MEM_SIZE_MB=128
VM_MAX_MEM_SIZE_MB=65536
VM_MIN_IMAGE_SIZE_GB=1
VM_MAX_IMAGE_SIZE_GB=16384
VM_DEFAULT_SECTOR_SIZE=4096
DEFAULT_VM_VNC_PORT_NUM_START=6000
VM_DEFAULT_NIC_DRIVER="e1000"
VM_DEFAULT_BOOT_LOADER="UEFI"
FDO_VMS_LIST_PATH="/usr/local/sbin/fdo-vms-list"
FDO_VMS_START_PATH="/usr/local/sbin/fdo-vms-start"
FDO_VMS_STOP_PATH="/usr/local/sbin/fdo-vms-stop"


VNC_DESKTOP_PACKAGES="xorg icewm clearlooks-themes roxterm xfe tightvnc firefox"
VNC_SCREEN_SIZES="800x600 1024x768 1280x768 1280x800 1280x1024 1366x768 1440x900 1600x900 1600x1200 1680x1050 1920x1080 1920x1200"


NET_IFACES_IGNORED="^tun[0-9]|^vboxnet[0-9]|^lo[0-9]|^vlan[0-9]|^pflog[0-9]"
AUX_LOCAL_SERVER_IP_MIN=2
AUX_LOCAL_SERVER_IP_MAX=9
WAN_PPP_TUN_ID=0
NET_CONNECT_TIMEOUT_SECS=${NET_CONNECT_TIMEOUT_SECS:-16}
INET_TEST_IPV4="8.8.8.8"
INET_TEST_HOSTNAME="freedominion.org"
DEFAULT_LAN_SUBNET_B="10.0"
if [ -e "${UCL_CMD}" ] && [ -e "${HOST_CONF_PATH}" ]
then
	CONFIG_LAN_NET_IFACE=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .network.interface.lan.id`
	if [ ${?} -ne 0 ] || [ "${CONFIG_LAN_NET_IFACE}" = "null" ] || [ "${CONFIG_LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} It appears that there is a problem accessing the host config file!\n"
		CONFIG_LAN_NET_IFACE="null"
	fi
else
	CONFIG_LAN_NET_IFACE="null"
fi
if [ "${CONFIG_LAN_NET_IFACE}" = "null" ]
then
	SET_LAN_SUBNET_B="${DEFAULT_LAN_SUBNET_B}"
else
	DETECTED_LAN_SUBNET_B=`ifconfig ${CONFIG_LAN_NET_IFACE} | grep "inet.*netmask 0xffff0000" | awk '{print $2}' | sort | head -1 | cut -d. -f1,2`
	if [ "${DETECTED_LAN_SUBNET_B}" = "" ]
	then
		SET_LAN_SUBNET_B="${DEFAULT_LAN_SUBNET_B}"
	else
		SET_LAN_SUBNET_B="${DETECTED_LAN_SUBNET_B}"
	fi
fi
FDO_LAN_SUBNET_B=${FDO_LAN_SUBNET_B:-"${SET_LAN_SUBNET_B}"}
FDO_LAN_SUBNET_MASK="255.255.0.0"
SERVERS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.10"
JAILS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.11"
WORKSTATIONS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.20"
HOTDESKS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.40"
MOBILES_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.50"
GUESTS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.60"
FDO_LAN_GATEWAY_IP="${SERVERS_LAN_SUBNET_C}.1"



usage ()
{
	if [ "${NO_DISPLAY_USAGE}" = "yes" ]
	then
		return 1
	fi

	echo -e ""
	echo -e "${LCYN}    ---- HOST MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} connect-internet${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-host host_name domain_name${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} init-host beastie1 example.net${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} patch-host${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} setup-vnc-desktop${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-hotdesk${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-partimag${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-sshfs-daemon${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} upgrade-repo-from-upstream${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} merge-local-repo-to-remote${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- SCRIPT MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} install-scripts${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} add-script script_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} add-script /usr/local/bin/findinfiles${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} update-script script_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} update-script /usr/local/bin/replaceinfiles${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- CONFIG FILE MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} add-config config_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} add-config /etc/ntp.conf${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} add-config /jls/dhcp/usr/local/etc/dhcpd.conf${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} update-config config_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} update-config /etc/ntp.conf${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} update-config /jls/dhcp/usr/local/etc/dhcpd.conf${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} remove-config config_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} remove-config /etc/ntp.conf${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} remove-config /jls/dhcp/usr/local/etc/dhcpd.conf${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} install-configs${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} check-configs [--silent]${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- JAIL MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-jails${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-jail jail_name jail_hostname${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-jail foo foobar.example.net${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-jail-from-recipe jail_name jail_hostname recipe_name${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-jail-from-recipe dns_cache dns-cache dns_cache${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- VM MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-vms${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-vm-template template_name${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-vm-template Win7${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-vm-instance template_name vm_name${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-vm-instance Win7 Legacy_Software${NRML}"
	echo -e ""
}

pause_prompt ()
{
	# $[1} is the pause duration in seconds (maximum is 25).
	PAUSE_DURATION=$(( ${1} * 10 ))
	if [ ${PAUSE_DURATION} -gt 250 ]
	then
		PAUSE_DURATION=250
	fi
	echo -e "\n${GREY}Press any key to continue...${NRML}\c"
	CURRENT_TTY_SETTINGS=$(stty -g)
	stty raw -echo min 0 time ${PAUSE_DURATION}
	printf '%s' $(dd bs=1 count=1 2>/dev/null) > /dev/null
	stty ${CURRENT_TTY_SETTINGS}
	echo -e "\n"
}

# Modern replacement for the 'read' shell inbuilt command.
# Similar to the bash inbuilt 'read -e'.
readee ()
{

	# Test for no arguments.
	if [ ${#} -eq 0 ]
	then
		echo -e "readee: arg count"
		return 2
	fi

	# Parse arguments.
	READEE_SILENT_MODE="false"
	READEE_PROMPT_MODE="false"
	READEE_PROMPT_TEXT=""
	READEE_VARIABLE=""
	for ARG in "${@}"
	do
		case "${ARG}" in
			"-e")
				# For backwards compatibility only.
				continue
				;;
			"-s")
				READEE_SILENT_MODE="true"
				;;
			"-p")
				READEE_PROMPT_MODE="next_arg"
				;;
			*)
				# If in prompt mode 'next_arg', capture the prompt.
				if [ "${READEE_PROMPT_MODE}" = "next_arg" ]
				then
					READEE_PROMPT_TEXT="${ARG}"
					READEE_PROMPT_MODE="true"
					continue
				fi

				# Test for illegal option flags.
				if [ "`echo ${ARG} | cut -c1`" = "-" ]
				then
					echo -e "readee: Illegal option "`echo "${ARG}" | cut -c1-2`
					return 2
				fi

				# Test for variable name validity (try best to copy sh inbuilt: read).
				IS_SYNTAX_OK=`echo "${ARG}" | sed -r "s/^[a-zA-Z\_]+[a-zA-Z0-9\_]*//" | wc -L`
				if [ ${IS_SYNTAX_OK}  -ne 0 ]
				then
					echo -e "readee: ${ARG}: bad variable name"
					return 2
				fi
				READEE_VARIABLE="${ARG}"
				break
				;;
		esac
	done

	# Test for missing prompt argument.
	if [ "${READEE_PROMPT_MODE}" = "next_arg" ]
	then
		echo -e "readee: No arg for -p option"
		return 2
	fi

	# Test for missing variable argument.
	if [ "${READEE_VARIABLE}" = "" ]
	then
		echo -e "readee: arg count"
		return 2
	fi

	# Variables (re)initialisation.
	CURS="\033[30;47m"
	NRML="\033[0;00m"
	HEX_CARRIAGE_RETURN="%0d"
	HEX_ESCAPE="%1b"
	HEX_CTRL_C="%03"
	HEX_CTRL_D="%04"
	HEX_ASCII_DEL="%7f"         # ASCII DEL, but actually comes from Backspace Key in some terminals.
	HEX_BACKSPACE="%08"
	HEX_DELETE="%33"            # Comes after escape character.
	HEX_HOME="%48"              # Comes after escape character.
	HEX_END="%46"               # Comes after escape character.
	HEX_D="%44"                 # LEFT ARROW, comes after escape character.
	HEX_C="%43"                 # RIGHT ARROW, comes after escape character.
	TYPED_CHAR=""
	TYPED_CHAR_HEX=""
	PRE_CURS_TEXT=""
	CURS_TEXT=" "
	POST_CURS_TEXT=""
	CURSOR_AT_START="true"
	CURSOR_AT_END="true"
	READEE_ABORTED="false"
	CURRENT_TTY_SETTINGS=`stty -g`

	# Prepare the TTY for line editing (no echo, raw input, make cursor invisible).
	stty -echo raw
	tput vi

	# Display initial prompt and edit line.
	echo -e "\r${NRML}${READEE_PROMPT_TEXT}${CURS}${CURS_TEXT}${NRML}\c"

	# Loop taking keystrokes until carriage return key is pressed.
	while [ "${TYPED_CHAR_HEX}" != "${HEX_CARRIAGE_RETURN}" ]
	do

		# Get a 2-byte character from stdin on key press and convert to Hexidecimal value.
		TYPED_CHAR=$(dd bs=2 count=1 2> /dev/null)
		TYPED_CHAR_HEX=`printf "%%%02x\n" "'${TYPED_CHAR}"`

		if [ "${TYPED_CHAR_HEX}" = "${HEX_ASCII_DEL}" ]
		then
			TYPED_CHAR_HEX=${HEX_BACKSPACE}
		fi

		# Compare the hexidecimal value of the first character with known ASCII values.
		case "${TYPED_CHAR_HEX}" in
			"${HEX_CTRL_C}")
				READEE_ABORTED="true"
				READEE_ABORT_TYPE="C"
				break
				;;
			"${HEX_CTRL_D}")
				READEE_ABORTED="true"
				READEE_ABORT_TYPE="D"
				break
				;;
			"${HEX_CARRIAGE_RETURN}")
				continue
				;;
			"${HEX_BACKSPACE}")
				# Get the length of the text left of cursor.
				PRE_CURS_TEXT_LENGTH=`echo ${#PRE_CURS_TEXT}`

				if [ "${CURSOR_AT_START}" = "true" ]
				then
					# If cursor is already at the beginning, do nothing and continue.
					continue
				fi

				if [ ${PRE_CURS_TEXT_LENGTH} -lt 2 ]
				then
					# Cursor reached the first character.
					# Set new pre-cursor text to empty, since cursor is now at the beginning.
					NEW_PRE_CURS_TEXT=""
					NEW_CURSOR_AT_START="true"
				else
					# Cursor moves left erasing the right-most character left of cursor.
					# Truncate the pre-cursor text by one character from the right.
					NEW_PRE_CURS_TEXT=`echo "${PRE_CURS_TEXT}" | cut -c1-$(( ${PRE_CURS_TEXT_LENGTH} - 1 ))`
					NEW_CURSOR_AT_START="false"
				fi

				# Set new values.
				PRE_CURS_TEXT="${NEW_PRE_CURS_TEXT}"
				CURSOR_AT_START="${NEW_CURSOR_AT_START}"
				;;
			"${HEX_ESCAPE}")

				# The first character was the escape character, so let's get a second character and hex value.
				ESCAPED_CHAR=$(dd bs=2 count=1 2> /dev/null)
				ESCAPED_CHAR_HEX=`printf "%%%02x\n" "'${ESCAPED_CHAR}"`

				# Compare the hex value of second character with known ASCII values
				# In order to get the extended meaning of the key stroke.
				case "${ESCAPED_CHAR_HEX}" in
					"${HEX_HOME}")
						if [ "${CURSOR_AT_START}" = "true" ]
						then
							# If the cursor is already at the start, do nothing and continue.
							continue
						fi

						if [ "${CURSOR_AT_END}" = "true" ]
						then
							NEW_TEXT="${PRE_CURS_TEXT}"
						else
							NEW_TEXT="${PRE_CURS_TEXT}${CURS_TEXT}${POST_CURS_TEXT}"
						fi
						NEW_TEXT_LENGTH=${#NEW_TEXT}
						NEW_CURS_TEXT=`echo "${NEW_TEXT}" | cut -c1`
						NEW_POST_CURS_TEXT=`echo "${NEW_TEXT}" | cut -c2-${NEW_TEXT_LENGTH}`

						# Set new values.
						PRE_CURS_TEXT=""
						CURS_TEXT="${NEW_CURS_TEXT}"
						POST_CURS_TEXT="${NEW_POST_CURS_TEXT}"
						CURSOR_AT_START="true"
						CURSOR_AT_END="false"
						;;
					"${HEX_END}")
						if [ "${CURSOR_AT_END}" = "true" ]
						then
							# If the cursor is already at he end, do nothing and continue.
							continue
						fi

						NEW_TEXT="${PRE_CURS_TEXT}${CURS_TEXT}${POST_CURS_TEXT}"

						# Set new values.
						PRE_CURS_TEXT="${NEW_TEXT}"
						CURS_TEXT=" "
						POST_CURS_TEXT=""
						CURSOR_AT_START="false"
						CURSOR_AT_END="true"
						;;
					"${HEX_DELETE}")
						# Get the length of the text right of cursor.
						POST_CURS_TEXT_LENGTH=${#POST_CURS_TEXT}

						if [ "${CURSOR_AT_END}" = "true" ]
						then
							# If cursor is already at the end, do nothing and continue.
							continue
						fi

						if [ ${POST_CURS_TEXT_LENGTH} -lt 1 ]
						then
							# Cursor reached the last character.
							# Set new cursor character to whitespace so we can still see it.
							NEW_CURS_TEXT=" "
							# Set new post-cursor text to empty, since we are at the end.
							NEW_POST_CURS_TEXT=""
							NEW_CURSOR_AT_END="true"
						else
							# Cursor erases it's character and becomes the left-most character right of cursor.
							# Set cursor text to the left-most character of post-cursor text.
							NEW_CURS_TEXT=`echo "${POST_CURS_TEXT}" | cut -c1`
							# Truncate the post-cursor text by one character from the left.
							NEW_POST_CURS_TEXT=`echo "${POST_CURS_TEXT}" | cut -c2-${POST_CURS_TEXT_LENGTH}`
							NEW_CURSOR_AT_END="false"
						fi

						# Set new values.
						CURS_TEXT="${NEW_CURS_TEXT}"
						POST_CURS_TEXT="${NEW_POST_CURS_TEXT}"
						CURSOR_AT_END="${NEW_CURSOR_AT_END}"
						;;
					"${HEX_D}")    # LEFT ARROW.
						# Get the length of the text left of cursor.
						PRE_CURS_TEXT_LENGTH=`echo ${#PRE_CURS_TEXT}`

						if [ "${CURSOR_AT_START}" = "true" ]
						then
							# If cursor is already at the beginning, do nothing and continue.
							continue
						fi

						if [ ${PRE_CURS_TEXT_LENGTH} -lt 2 ]
						then
							# Cursor reached the first character.
							# Set new pre-cursor text to empty, since cursor is now at the beginning.
							NEW_PRE_CURS_TEXT=""
							NEW_CURSOR_AT_START="true"
							NEW_CURSOR_AT_END="false"
						else
							# Cursor is moving left.
							# Set new pre-cursor text to current pre-cursor text truncated by one character from the right.
							NEW_PRE_CURS_TEXT=`echo "${PRE_CURS_TEXT}" | cut -c1-$(( ${PRE_CURS_TEXT_LENGTH} - 1 ))`
							NEW_CURSOR_AT_START="false"
							NEW_CURSOR_AT_END="false"
						fi

						# Set new cursor character to character left of current cursor.
						NEW_CURS_TEXT=`echo "${PRE_CURS_TEXT}" | cut -c${#PRE_CURS_TEXT}`
						if [ "${CURSOR_AT_END}" = "true" ]
						then
							# Cursor was at end, so new post-cursor text is same as before.
							NEW_POST_CURS_TEXT="${POST_CURS_TEXT}"
						else
							# Set new post-cursor text to current cursor character concatenated with current post-cursor text.
							NEW_POST_CURS_TEXT="${CURS_TEXT}${POST_CURS_TEXT}"
						fi

						# Set new values.
						PRE_CURS_TEXT="${NEW_PRE_CURS_TEXT}"
						CURS_TEXT="${NEW_CURS_TEXT}"
						POST_CURS_TEXT="${NEW_POST_CURS_TEXT}"
						CURSOR_AT_START="${NEW_CURSOR_AT_START}"
						CURSOR_AT_END="${NEW_CURSOR_AT_END}"
						;;
					"${HEX_C}")    # RIGHT ARROW.
						# Get the length of the text right of cursor.
						POST_CURS_TEXT_LENGTH=${#POST_CURS_TEXT}

						if [ "${CURSOR_AT_END}" = "true" ]
						then
							# If cursor is already at the end, do nothing and continue.
							continue
						fi

						if [ ${POST_CURS_TEXT_LENGTH} -lt 1 ]
						then
							# Cursor reached past last character.
							# Set new cursor character to whitespace so we can still see it.
							NEW_CURS_TEXT=" "
							# Set new post-cursor text to empty, since we are at the end.
							NEW_POST_CURS_TEXT=""
							NEW_CURSOR_AT_START="false"
							NEW_CURSOR_AT_END="true"
						else
							# Cursor is moving right.
							# Set new cursor character to first character of current post-cursor text.
							NEW_CURS_TEXT=`echo "${POST_CURS_TEXT}" | cut -c1`
							# Set new post-cursor text to current post-cursor text truncated by one character from the left.
							NEW_POST_CURS_TEXT=`echo "${POST_CURS_TEXT}" | cut -c2-${POST_CURS_TEXT_LENGTH}`
							NEW_CURSOR_AT_START="false"
							NEW_CURSOR_AT_END="false"
						fi

						# Set new pre-cursor text to current pre-cursor text concatenated with current cursor character.
						NEW_PRE_CURS_TEXT="${PRE_CURS_TEXT}${CURS_TEXT}"

						# Set new values.
						PRE_CURS_TEXT="${NEW_PRE_CURS_TEXT}"
						CURS_TEXT="${NEW_CURS_TEXT}"
						POST_CURS_TEXT="${NEW_POST_CURS_TEXT}"
						CURSOR_AT_START="${NEW_CURSOR_AT_START}"
						CURSOR_AT_END="${NEW_CURSOR_AT_END}"
						;;
					*)
						# For any other character, do nothing.
						continue
						;;

				esac
				;;

			*)
				# Character is actual input.
				PRE_CURS_TEXT="${PRE_CURS_TEXT}${TYPED_CHAR}"
				CURSOR_AT_START="false"
				;;
		esac

		# If in silent mode, hide displayed text.
		if [ "${READEE_SILENT_MODE}" = "true" ]
		then
			DISPLAY_LINE="${NRML}${READEE_PROMPT_TEXT}"`echo "${PRE_CURS_TEXT}" | sed "s/./\*/g"`
			DISPLAY_LINE="${DISPLAY_LINE}${CURS}"`echo "${CURS_TEXT}" | sed "s/[^ ]/\*/g"`
			DISPLAY_LINE="${DISPLAY_LINE}${NRML}"`echo "${POST_CURS_TEXT}" | sed "s/./\*/g"`
		else
			DISPLAY_LINE="${NRML}${READEE_PROMPT_TEXT}${PRE_CURS_TEXT}${CURS}${CURS_TEXT}${NRML}${POST_CURS_TEXT}"
		fi

		# Echo display text to screen.
		echo -e "\r${DISPLAY_LINE} \c"

	done

	# Put tty text and cursor back to how they were before.
	stty ${CURRENT_TTY_SETTINGS}
	tput ve

	# Compile the whole entered text line from component parts.
	if [ "${CURSOR_AT_END}" = "true" ]
	then
		READEE_ENTERED_TEXT="${PRE_CURS_TEXT}${POST_CURS_TEXT}"
	else
		READEE_ENTERED_TEXT="${PRE_CURS_TEXT}${CURS_TEXT}${POST_CURS_TEXT}"
	fi

	# If in silent mode, hide final entered text once more.
	if [ "${READEE_SILENT_MODE}" = "true" ]
	then
		DISPLAY_LINE="${READEE_PROMPT_TEXT}"`echo "${READEE_ENTERED_TEXT}" | sed "s/./\*/g"`
	else
		DISPLAY_LINE="${READEE_PROMPT_TEXT}${READEE_ENTERED_TEXT}"
	fi

	# Now output final text.
	if [ "${READEE_ABORTED}" = "true" ]
	then
		if [ "${READEE_ABORT_TYPE}" = "C" ]
		then
			echo -e "\r${DISPLAY_LINE}^C"
			kill -INT $$
		elif [ "${READEE_ABORT_TYPE}" = "D" ]
		then
			echo -e "\r${DISPLAY_LINE}\c"
			return 1
		fi
	else
		echo -e "\r${DISPLAY_LINE} "
	fi

	# Lastly, set the input variable that was passed as an argument.
	eval "${READEE_VARIABLE}=\"${READEE_ENTERED_TEXT}\""

}

question_yes_no ()
{
	while true
	do
		echo -e "${LCYN}${1}${NRML}"
		readee -p "${LCYN}(yes|no): ${NRML}" ANSWER
		if [ "${ANSWER}" = "yes" ] || [ "${ANSWER}" = "no" ]
		then
			break
		fi
		echo ""
	done
}

question_yes ()
{
	while true
	do
		echo -e "${LCYN}${1}${NRML}"
		readee -p "${LCYN}(yes): ${NRML}" ANSWER
		if [ "${ANSWER}" = "yes" ]
		then
			break
		fi
		echo ""
	done
}

question_purge_archive_reuse ()
{
	while true
	do
		echo -e "${LCYN}${1}${NRML}"
		readee -p "${LCYN}(purge|archive|reuse): ${NRML}" ANSWER
		if [ "${ANSWER}" = "purge" ] || [ "${ANSWER}" = "archive" ] || [ "${ANSWER}" = "reuse" ]
		then
			break
		fi
		echo ""
	done
}

get_class_b_subnet ()
{
	CLASS_B_SUBNET_IP="${1}"
	CLASS_B_SUBNET_FIRST=`echo "${CLASS_B_SUBNET_IP}" | cut -d. -f1`
	CLASS_B_SUBNET_SECOND=`echo "${CLASS_B_SUBNET_IP}" | cut -d. -f2`
	CLASS_B_SUBNET="${CLASS_B_SUBNET_FIRST}.${CLASS_B_SUBNET_SECOND}"
}

get_class_c_subnet ()
{
	CLASS_C_SUBNET_IP="${1}"
	CLASS_C_SUBNET_FIRST=`echo "${CLASS_C_SUBNET_IP}" | cut -d. -f1`
	CLASS_C_SUBNET_SECOND=`echo "${CLASS_C_SUBNET_IP}" | cut -d. -f2`
	CLASS_C_SUBNET_THIRD=`echo "${CLASS_C_SUBNET_IP}" | cut -d. -f3`
	CLASS_C_SUBNET="${CLASS_C_SUBNET_FIRST}.${CLASS_C_SUBNET_SECOND}.${CLASS_C_SUBNET_THIRD}"
}

get_enabled_nat_services ()
{

	IS_PF_NAT_ENABLED=`sysrc pf_enable | awk '{print $2}'`
	IS_PPP_NAT_ENABLED=`sysrc ppp_nat | awk '{print $2}'`

}

get_file_size_in_gigabytes ()
{
	FILE_SIZE_IN_BYTES=`ls -l ${1} | awk '{print $5}'`
	FILE_SIZE_IN_GB=`echo "${FILE_SIZE_IN_BYTES} / 1024 / 1024 / 1024" | bc`
}

get_jail_id_from_name ()
{
	# NOTE: ${1} is jail name.

	JAIL_ID_FILE=`ls -1 /var/run/jail_${1}.id 2> /dev/null | head -1`
	if [ "${JAIL_ID_FILE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Could not identify jail id from jail name.\n"
		JAIL_ID=-1
		return 1
	fi
	JAIL_ID=`cat ${JAIL_ID_FILE}`

}

get_next_vnc_port_num ()
{

	# ASSUME: that before calling this function, we have tested that the vms.conf file is accessible.

	VM_VNC_PORT_NUM_START=`${UCL_CMD} get -f ${VMS_CONF_PATH} -q .network.vnc_port_offset`
	if [ ${?} -ne 0 ] || [ "${VM_VNC_PORT_NUM_START}" = "null" ] || [ "${VM_VNC_PORT_NUM_START}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that there is a problem accessing the VMs config file!\n"
		return 2
	fi

	VNC_PORT_NUM=-1
	VNC_PORT_NUM_TEMP=${VM_VNC_PORT_NUM_START}
	while [ ${VNC_PORT_NUM} -lt 0 ]
	do
		RESULT1=`sockstat -Llq -P tcp -p ${VNC_PORT_NUM_TEMP}`
		RESULT2=0

		INDEX_TEST=0
		while [ `${UCL_CMD} get -f ${VMS_CONF_PATH} -q .templates.${INDEX_TEST}` != "null" ]
		do
			PORT_NUM_TEST=`${UCL_CMD} get -f ${VMS_CONF_PATH} -q .templates.${INDEX_TEST}.vnc_port`
			if [ "${PORT_NUM_TEST}" = "${VNC_PORT_NUM_TEMP}" ]
			then
				RESULT2=$(( ${RESULT2} + 1 ))
			fi
			INDEX_TEST=$(( ${INDEX_TEST} + 1 ))
		done

		INDEX_TEST=0
		while [ `${UCL_CMD} get -f ${VMS_CONF_PATH} -q .instances.${INDEX_TEST}` != "null" ]
		do
			PORT_NUM_TEST=`${UCL_CMD} get -f ${VMS_CONF_PATH} -q .instances.${INDEX_TEST}.vnc_port`
			if [ "${PORT_NUM_TEST}" = "${VNC_PORT_NUM_TEMP}" ]
			then
				RESULT2=$(( ${RESULT2} + 1 ))
			fi
			INDEX_TEST=$(( ${INDEX_TEST} + 1 ))
		done

		if [ "${RESULT1}" != "" ] || [ ${RESULT2} -gt 0 ]
		then
			VNC_PORT_NUM_TEMP=$(( ${VNC_PORT_NUM_TEMP} + 1 ))
		else
			VNC_PORT_NUM=${VNC_PORT_NUM_TEMP}
		fi
	done

	return 0
}

test_num_mandatory_sub_args ()
{
	NUM_MANDATORY_SUB_ARGS=${1}
	if [ ${NUM_SUB_ARGS} -lt ${NUM_MANDATORY_SUB_ARGS} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Invalid number of arguments for this sub-command!\n       Aborting.\n"
		usage
		exit 1
	fi
}

test_valid_person_name ()
{

	TEST_CASE="${1}"

	VALID_PERSON_NAME="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_PERSON_NAME="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^[a-zA-Z0-9]*[a-zA-Z0-9\ ]*[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_PERSON_NAME="no"
		return 2
	fi

	return 0
}

test_valid_integer ()
{

	TEST_CASE="${1}"
	TEST_MIN_VALUE=${2}
	TEST_MAX_VALUE=${3}

	VALID_INTEGER="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_INTEGER="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^[0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_INTEGER="no"
		return 2
	fi

	if [ ${TEST_CASE} -lt ${TEST_MIN_VALUE} ]
	then
		VALID_INTEGER="no"
		return 3
	fi

	if [ ${TEST_CASE} -gt ${TEST_MAX_VALUE} ]
	then
		VALID_INTEGER="no"
		return 4
	fi

	return 0
}

test_valid_email_address ()
{

	TEST_CASE="${1}"

	VALID_EMAIL_ADDRESS="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_EMAIL_ADDRESS="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^([a-zA-Z0-9]+([\.\_\-]?[a-zA-Z0-9]+)*)+([\+]([a-zA-Z0-9]+([\.\_\/\-]?[a-zA-Z0-9]+)*)+)?\@((([a-zA-Z0-9]+[\-])*[a-zA-Z0-9]+)+\.)+[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_EMAIL_ADDRESS="no"
		return 2
	fi

	return 0
}

test_valid_inet_address ()
{

	TEST_CASE="${1}"

	VALID_INET_ADDRESS="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_INET_ADDRESS="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed "s/^[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}$//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_INET_ADDRESS="no"
		return 2
	fi

	NO_ZEROS_IN_FRONT=`echo "${TEST_CASE}" | sed "s/\.0[0-9]//" | sed "s/^0//"`
	if [ "${NO_ZEROS_IN_FRONT}" != "${TEST_CASE}" ]
	then
		VALID_INET_ADDRESS="no"
		return 3
	fi

	ONE=`echo "${TEST_CASE}" | cut -d. -f1`
	TWO=`echo "${TEST_CASE}" | cut -d. -f2`
	THREE=`echo "${TEST_CASE}" | cut -d. -f3`
	FOUR=`echo "${TEST_CASE}" | cut -d. -f4`

	if [ ${ONE} -gt 255 ] || [ ${TWO} -gt 255 ] || [ ${THREE} -gt 255 ] || [ ${FOUR} -gt 255 ]
	then
		VALID_INET_ADDRESS="no"
		return 4
	fi

	return 0
}

test_valid_host_name ()
{

	TEST_CASE="${1}"

	VALID_HOST_NAME="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_HOST_NAME="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^([a-zA-Z0-9]+[\-])*[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_HOST_NAME="no"
		return 2
	fi

	return 0
}

test_valid_fqhn ()
{

	TEST_CASE="${1}"

	VALID_FQHN="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_FQHN="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^((([a-zA-Z0-9]+[\-])*[a-zA-Z0-9]+)+\.)+[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_FQHN="no"
		return 2
	fi

	return 0
}

test_ping_host ()
{

	TEST_CASE="${1}"

	VALID_HOST_PING="yes"

	ping -c 3 ${TEST_CASE} > /dev/null 2>&1

	if [ ${?} -ne 0 ]
	then
		VALID_HOST_PING="no"
		return 1
	fi

	return 0
}

test_valid_simple_url ()
{

	TEST_CASE="${1}"

	VALID_URL="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_URL="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^http[s]?\:\/\/[a-zA-Z0-9]+([\-]*[a-zA-Z0-9]+)*(\.[a-zA-Z0-9]+([\_\-]*[a-zA-Z0-9]+)*)*(:[0-9]+)?(\/[a-zA-Z0-9]+([\_\-]*[a-zA-Z0-9]+)*(\.[a-zA-Z0-9]+([\_\-]*[a-zA-Z0-9]+)*)*)*[\/]*//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_URL="no"
		return 2
	fi

	return 0
}

test_valid_alpha_numeric_string ()
{

	TEST_CASE="${1}"
	MIN_VALID_CHARS=${2}
	MAX_VALID_CHARS=${3}

	VALID_ALPHA_NUMERIC_STRING="yes"

	if [ ${MIN_VALID_CHARS} -eq 0 ] && [ "${TEST_CASE}" = "" ]
	then
		return 0
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed "s/^[a-zA-Z0-9 ]\{${MIN_VALID_CHARS},${MAX_VALID_CHARS}\}//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_ALPHA_NUMERIC_STRING="no"
		return 2
	fi

	return 0
}

test_valid_ldap_dn ()
{

	TEST_CASE="${1}"

	VALID_LDAP_DN="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_LDAP_DN="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/([a-zA-Z0-9]+\=[a-zA-Z0-9_.+-]+)+(,[a-zA-Z0-9]+\=[a-zA-Z0-9_.+-]+)*//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_LDAP_DN="no"
		return 2
	fi

	return 0
}

test_valid_vm_name ()
{
	TEST_CASE="${1}"

	VALID_VM_NAME="yes"

	if [ "${TEST_CASE}" = "null" ] || [ "${TEST_CASE}" = "all" ] || [ "${TEST_CASE}" = "_ALL" ] || [ "${TEST_CASE}" = "" ]
	then
		VALID_VM_NAME="no"
		return 1
	fi

	if [ ${#TEST_CASE} -gt ${VM_NAME_MAX} ] || [ ${#TEST_CASE} -lt ${VM_NAME_MIN} ]
	then
		VALID_VM_NAME="no"
		return 2
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^[a-zA-Z0-9]+(_[a-zA-Z0-9]+[a-zA-Z0-9]*)*//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_VM_NAME="no"
		return 3
	fi

	return 0
}

fetch_latest_self ()
{
	echo -e "\n${YELL}Fetching the latest version of this utility...${NRML}\n"
	cd /root
	fetch -d ${FETCH_LATEST_SELF_URL}${SCRIPT_NAME}
	if [ ${?} -ne 0 ]
	then
		question_yes_no "\nUnable to fetch the latest version of this utility.\nWould you like to continue anyway?"
		if [ "${ANSWER}" = "no" ]
		then
			echo -e "\nAborting.\n"
			exit 1
		fi
	else
		EXISTING_SHA256=`sha256 -q /usr/local/sbin/${SCRIPT_NAME}`
		FETCHED_SHA256=`sha256 -q ${SCRIPT_NAME}`
		if [ "${EXISTING_SHA256}" != "${FETCHED_SHA256}" ]
		then
			if [ ! -d /usr/local/sbin/ ]
			then
				mkdir -p /usr/local/sbin
			fi
			mv /root/${SCRIPT_NAME} /usr/local/sbin/
			chmod +x /usr/local/sbin/${SCRIPT_NAME}
			echo -e "\n${YELL}A newer version has now been installed.\nPlease rerun this utility.${NRML}\n"
			exit 1
		else
			echo -e "\n${YELL}The current version of this utility appears to be up to date.${NRML}\n"
			rm /root/${SCRIPT_NAME}
		fi
	fi

	return 0
}

git_pull ()
{
	REPOSITORY="${1}"
	BRANCH="${2}"
	while true
	do
		git pull ${REPOSITORY} ${BRANCH}
		if [ ${?} -ne 0 ]
		then
			question_yes_no "\nThe git pull operation failed! Would you like to try again?"
			if [ "${ANSWER}" = "yes" ]
			then
				echo -e ""
			else
				return 1
			fi
		else
			return 0
		fi
	done
}

git_push ()
{
	REPOSITORY="${1}"
	BRANCH="${2}"
	while true
	do
		git push ${REPOSITORY} ${BRANCH}
		if [ ${?} -ne 0 ]
		then
			question_yes_no "\nThe git push operation failed! Would you like to try again?"
			if [ "${ANSWER}" = "yes" ]
			then
				echo -e ""
			else
				return 1
			fi
		else
			return 0
		fi
	done
}

ucl_array_length ()
{
	UCL_ARRAY_LENGTH_FILE_PATH="${1}"
	UCL_ARRAY_LENGTH_VARIABLE="${2}"
	UCL_ARRAY_LENGTH=0

	UCL_ARRAY_LENGTH_OBJECT=`${UCL_CMD} get -f "${UCL_ARRAY_LENGTH_FILE_PATH}" "${UCL_ARRAY_LENGTH_VARIABLE}" 2> /dev/null`
	if [ ${?} -ne 0 ]
	then
		# Unexpected error accessing the UCL file. 
		return 2
	fi

	if [ "${UCL_ARRAY_LENGTH_OBJECT}" != "[array]" ]
	then
		# The variable was not a valid array, return expected error.
		return 1
	fi

	while [ "${UCL_ARRAY_LENGTH_OBJECT}" != "null" ]
	do
		UCL_ARRAY_LENGTH_OBJECT=`${UCL_CMD} get -f "${UCL_ARRAY_LENGTH_FILE_PATH}" "${UCL_ARRAY_LENGTH_VARIABLE}.${UCL_ARRAY_LENGTH}"`
		if [ "${UCL_ARRAY_LENGTH_OBJECT}" != "null" ]
		then
			UCL_ARRAY_LENGTH=$(( ${UCL_ARRAY_LENGTH} + 1 ))
		fi
	done

	return 0
}

check_repo_config ()
{

	# If REPO_URI is already set, then no need to proceed.
	if [ "${REPO_URI}" != "" ]
	then
		return 0
	fi

	# Get the type of repo and, if applicable, the remote repo URI.
	while [ "${REPO_URI}" = "" ]
	do
		echo -e "\n\n${LGRN}It appears that this is the first time you have used '${NRML}${SCRIPT_NAME}${LGRN}${NRML}'"
		echo -e "${LGRN}on this host.${NRML}\n"
		echo -e "${YELL}If this is your first host and you don't have a private remote git repo running${NRML}"
		echo -e "${YELL}yet. Then enter '${NRML}local${YELL}' at the next prompt.${NRML}\n"

		pause_prompt 24

		# Prompt for the type of repo to use, remote or local.
		REPO_TYPE=""
		while [ "${REPO_TYPE}" = "" ]
		do
			echo -e "\n${LCYN}Would you like to use an existing remote git repo (recommended, if available),${NRML}"
			echo -e "${LCYN}or start with a local repo (not backed up remotely, no central management)?${NRML}"
			readee -p "${LCYN}(remote|local): ${NRML}" REPO_TYPE_TEMP
			# Check input validation.
			if [ "${REPO_TYPE_TEMP}" = "remote" ] || [ "${REPO_TYPE_TEMP}" = "local" ]
			then
				REPO_TYPE="${REPO_TYPE_TEMP}"
			fi
		done

		# If it does not exist, create the root path for FDo config files.
		if [ ! -f ${FDO_CONFIG_ROOT} ]
		then
			mkdir -p ${FDO_CONFIG_ROOT}
		fi

		if [ "${REPO_TYPE}" = "local" ]
		then
			REPO_URI="local"
		else
			# Get the URI of the remote git repo.
			REMOTE_REPO_URI=""
			while [ "${REMOTE_REPO_URI}" = "" ]
			do
				echo -e "\n${LCYN}Enter the remote git repo URI:${NRML}"
				readee REMOTE_REPO_URI_TEMP
				# Allow user to change their mind about type of repo.
				if [ "${REMOTE_REPO_URI_TEMP}" = "" ]
				then
					break
				fi
				# Test the input to see if it is a valid URI (URL).
				test_valid_simple_url "${REMOTE_REPO_URI_TEMP}"
				if [ "${VALID_URL}" = "yes" ]
				then
					question_yes_no "\nYou have entered '${NRML}${REMOTE_REPO_URI_TEMP}${LCYN}'\nas the remote git repo URI.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						REMOTE_REPO_URI=${REMOTE_REPO_URI_TEMP}
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} remote git repo URI is invalid!\n"
				fi
			done
			REPO_URI="${REMOTE_REPO_URI}"
		fi

	done

	# Store the repo URI in it's FDo config file.
	echo "${REPO_URI}" > ${FDO_CONFIG_ROOT}/fdo-server-repo.conf

	echo -e "\n${YELL}The local repo will be stored in the path '${NRML}/${REPO_NAME}${YELL}'.${NRML}\n"
	NO_DISPLAY_USAGE="yes"

	return 0
}

backup_file ()
{
	FILE_PATH="${1}"
	CHANGE_AGENT="${2}"
	NOW=`date "+%Y-%m-%d_%H-%M-%S"`
	if [ -f "${FILE_PATH}" ]
	then
		BACKUP_FILE_PATH="${FILE_PATH}.${CHANGE_AGENT}_backup_${NOW}"
		cp "${FILE_PATH}" "${BACKUP_FILE_PATH}" > /dev/null 2>&1
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to backup file '${ORNG}${FILE_PATH}${NRML}'!\n"
			BACKUP_FILE_PATH=""
			return 2
		fi
	else
		echo -e "\n${LRED}ERROR:${NRML} File '${ORNG}${FILE_PATH}${NRML}' does not exist!\n       Unable to backup.\n"
		BACKUP_FILE_PATH=""
		return 1
	fi

	return 0
}

install_file_tree ()
{

	SOURCE_FILES_ROOT="${1}"
	DEST_FILES_ROOT="${2}"
	CHOWN_USER="${3}"
	CHOWN_GROUP="${4}"
	ERROR_COUNT=0

	for SOURCE_FILE_PATH in `find "${SOURCE_FILES_ROOT}" -print | tail -n +2 | sort`
	do

		RELATIVE_DEST_FILE_PATH=`echo ${SOURCE_FILE_PATH} | sed "s|${SOURCE_FILES_ROOT}/||"`
		DEST_FILE_PATH="${DEST_FILES_ROOT}${RELATIVE_DEST_FILE_PATH}"
		FILE_UID=`ls -ldn "${SOURCE_FILE_PATH}" | awk '{print $3}'`
		FILE_GID=`ls -ldn "${SOURCE_FILE_PATH}" | awk '{print $4}'`

		if [ -d "${SOURCE_FILE_PATH}" ]
		then
			if [ ! -d "${DEST_FILE_PATH}" ]
			then
				mkdir "${DEST_FILE_PATH}"
				if [ ${?} -ne 0 ]
				then
					ERROR_COUNT=$(( ${ERROR_COUNT} + 1 ))
				fi
				chown ${FILE_UID}:${FILE_GID} "${DEST_FILE_PATH}"
				if [ ${?} -ne 0 ]
				then
					ERROR_COUNT=$(( ${ERROR_COUNT} + 1 ))
				fi
			fi
		else
			diff -q "${SOURCE_FILE_PATH}" "${DEST_FILE_PATH}" > /dev/null 2>&1
			if [ ${?} -ne 0 ]
			then
				cp "${SOURCE_FILE_PATH}" "${DEST_FILE_PATH}"
				if [ ${?} -ne 0 ]
				then
					ERROR_COUNT=$(( ${ERROR_COUNT} + 1 ))
				fi
				chown ${FILE_UID}:${FILE_GID} "${DEST_FILE_PATH}"
				if [ ${?} -ne 0 ]
				then
					ERROR_COUNT=$(( ${ERROR_COUNT} + 1 ))
				fi
			fi
		fi

		if [ "${CHOWN_USER}" != "" ]
		then
			chown ${CHOWN_USER} "${DEST_FILE_PATH}"
			if [ ${?} -ne 0 ]
			then
				ERROR_COUNT=$(( ${ERROR_COUNT} + 1 ))
			fi
		fi

		if [ "${CHOWN_GROUP}" != "" ]
		then
			chown :${CHOWN_GROUP} "${DEST_FILE_PATH}"
			if [ ${?} -ne 0 ]
			then
				ERROR_COUNT=$(( ${ERROR_COUNT} + 1 ))
			fi
		fi
	done

	return ${ERROR_COUNT}
}

compare_file_tree ()
{

	# NOTE: return code is 2 if any file/dir is missing, 1 if any file is OUT OF CHECK, 0 if everything is IN CHECK.
	SOURCE_FILES_ROOT=${1}
	DEST_FILES_ROOT=${2}
	SILENT_MODE="no"
	COMPARE_FILE_ERROR_COUNT=0
	COMPARE_FILE_OUT_OF_CHECK=false
	COMPARE_FILE_MISSING=false

	if [ "${3}" = "--silent" ]
	then
		SILENT_MODE="yes"
	fi

	for SOURCE_FILE_PATH in `find ${SOURCE_FILES_ROOT} -print | tail -n +2 | sort`
	do

		RELATIVE_DEST_FILE_PATH=`echo ${SOURCE_FILE_PATH} | sed "s|${SOURCE_FILES_ROOT}/||"`
		DEST_FILE_PATH=${DEST_FILES_ROOT}${RELATIVE_DEST_FILE_PATH}

		if [ -d "${SOURCE_FILE_PATH}" ]
		then
			if [ ! -d ${DEST_FILE_PATH} ]
			then
				echo -e "The following dir  is      ${LRED}MISSING${NRML}: ${DEST_FILE_PATH}"
				COMPARE_FILE_ERROR_COUNT=$(( ${COMPARE_FILE_ERROR_COUNT} + 1 ))
				COMPARE_FILE_MISSING=true
			fi
		else
			if [ ! -f ${DEST_FILE_PATH} ]
			then
				echo -e "The following file is      ${LRED}MISSING${NRML}: ${DEST_FILE_PATH}"
				COMPARE_FILE_ERROR_COUNT=$(( ${COMPARE_FILE_ERROR_COUNT} + 1 ))
				COMPARE_FILE_MISSING=true
			else
				diff ${SOURCE_FILE_PATH} ${DEST_FILE_PATH} > /dev/null 2>&1
				if [ ${?} -eq 0 ]
				then
					echo -e "The following file is     ${LGRN}IN CHECK${NRML}: ${DEST_FILE_PATH}"
				else
					echo -e "The following file is ${ORNG}OUT OF CHECK${NRML}: ${DEST_FILE_PATH}"
					COMPARE_FILE_ERROR_COUNT=$(( ${COMPARE_FILE_ERROR_COUNT} + 1 ))
					COMPARE_FILE_OUT_OF_CHECK=true
					if [ "${SILENT_MODE}" = "no" ]
					then
						echo -e ""
						question_yes_no "Would you like to see the diff for '${NRML}${DEST_FILE_PATH}${LCYN}'?"
						echo -e ""
						if [ "${ANSWER}" = "yes" ]
						then
							diff -u ${SOURCE_FILE_PATH} ${DEST_FILE_PATH}
							echo -e ""
							question_yes "Continue?"
							echo -e ""
						fi
					fi
				fi
			fi
		fi
	done

	if [ ${COMPARE_FILE_MISSING} = true ]
	then
		return 2
	elif [ ${COMPARE_FILE_OUT_OF_CHECK} = true ]
	then
		return 1
	else
		return 0
	fi
}

init_git_config ()
{

	echo -e "\n\n${YELL}Initialising git config...${NRML}\n"

	# Move into local repo directory.
	cd "/${REPO_NAME}"
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to enter the repo directory; '${ORNG}/${REPO_NAME}${NRML}'!"
		return 2
	fi

	git config user.name > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		while [ "${GIT_USER_NAME}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter the git user name (e.g. John Doe): ${NRML}" GIT_USER_NAME_TEMP
			# Check that the git user name only contains letters numbers and spaces.
			test_valid_person_name "${GIT_USER_NAME_TEMP}"
			if [ "${VALID_PERSON_NAME}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${GIT_USER_NAME_TEMP}${LCYN}' as the git user name.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					GIT_USER_NAME=${GIT_USER_NAME_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The name can not be '${ORNG}${GIT_USER_NAME}${NRML}'."
				echo -e "       It must contain only letters, numbers and spaces.\n"
			fi
		done
		git config user.name "${GIT_USER_NAME}"
	fi

	git config user.email > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		while [ "${GIT_USER_EMAIL}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter the git user email address: ${NRML}" GIT_USER_EMAIL_TEMP
			# Check that the git user email only contains letters, numbers, periods, pluses, hyphens, underscores and one @.
			test_valid_email_address "${GIT_USER_EMAIL_TEMP}"
			if [ "${VALID_EMAIL_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${GIT_USER_EMAIL_TEMP}${LCYN}' as the git user email.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					GIT_USER_EMAIL=${GIT_USER_EMAIL_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The email address can not be '${ORNG}${GIT_USER_EMAIL_TEMP}${NRML}'."
				echo -e "       It must be a valid email address.\n"
			fi
		done
		git config user.email "${GIT_USER_EMAIL}"
	fi

	git config push.default > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		git config push.default "simple"
	fi

	return 0
}

upgrade_repo_from_upstream ()
{

	if [ "${1}" = "--push" ] || [ "${2}" = "--push" ]
	then
		DO_GIT_PUSH="yes"
	else
		DO_GIT_PUSH="no"
	fi

	if [ "${1}" = "--no-install-scripts" ] || [ "${2}" = "--no-install-scripts" ]
	then
		ASK_INSTALL_SCRIPTS="no"
	else
		ASK_INSTALL_SCRIPTS="yes"
	fi

	# Move into local repo directory.
	cd "/${REPO_NAME}"
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to enter the repo directory; '${ORNG}/${REPO_NAME}${NRML}'!"
		return 2
	fi

	# ASSUME: the local repo exists and is initialised properly.

	# Get the pre-upgrade git commit reference.
	PRE_UPGRADE_COMMIT_REF=`git log --format=format:%H -1`

	# Add the public upstream skeleton repo as a remote called 'upstream'.
	git remote add upstream "${FDO_SERVER_SKELETON_REPO}"
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to add upstream remote git repo to local git repo!\n"
		return 2
	fi

	# Fetch the upstream changes.
	git fetch upstream
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to fetch upstream remote git repo!\n"
		return 2
	fi

	# Merge the upstream changes to the local repo.
	git merge upstream/master --allow-unrelated-histories -m "Upgrading private repo from upstream skeleton repo on host '${HOST_NAME}'."
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to merge upstream remote git repo with local git repo!\n"
		return 2
	fi

	# Detach the upstream remote from the local repo.
	git remote remove upstream
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to remove upstream remote git repo from local git repo!\n"
		return 2
	fi

	if [ "${REPO_URI}" != "local" ] && [ "${DO_GIT_PUSH}" = "yes" ]
	then
		echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
		git_push origin master
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
			echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
			UPGRADE_REMOTE_REPO_SUCCESS="no"
		else
			UPGRADE_REMOTE_REPO_SUCCESS="yes"
		fi
	fi

	if [ "${DO_GIT_PUSH}" = "yes" ]
	then
		echo -e "\n${LGRN}OK, it seems we've successfully upgraded the local repo!${NRML}\n"
		if [ "${REPO_URI}" != "local" ] && [ "${UPGRADE_REMOTE_REPO_SUCCESS}" = "no" ]
		then
			echo -e "${ORNG}But we were unable to push changes to the private remote repo.${NRML}\n"
		fi
	fi

	# Get the post-upgrade git commit reference.
	POST_UPGRADE_COMMIT_REF=`git log --format=format:%H -1`

	# Check if any scripts have been updated in this upgrade cycle.
	echo -e "\n${YELL}Checking if any scripts have been updated in this upgrade...${NRML}\n"
	git diff-tree --no-commit-id --name-only -r ${PRE_UPGRADE_COMMIT_REF} ${POST_UPGRADE_COMMIT_REF} | grep "^scripts/"

	if [ ${?} -eq 0 ] && [ "${ASK_INSTALL_SCRIPTS}" = "yes" ]
	then
		# Ask whether to perform an 'install-scripts'.
		question_yes_no "\nIt seems that one or more scripts have been updated in this upgrade.\nWould you like to perform an '${NRML}install-scripts${LCYN}' now?"
		if [ "${ANSWER}" = "yes" ]
		then
			install_scripts_everywhere
		else
			echo -e "${YELL}You may perform an '${NRML}install-scripts${YELL}' later by running the command:\n${LBLU}${SCRIPT_NAME} install-scripts${NRML}"
		fi
		echo -e ""
	fi

	return 0
}

init_local_repo ()
{

	echo -e "\n\n${YELL}Initialising the local repo...${NRML}\n"

	# Clone or update the git repository.
	if [ -d "/${REPO_NAME}/.git" ]
	then

		# ASSUME: The local repo already exists.

		# Move into local repo directory.
		cd "/${REPO_NAME}"
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Unable to enter the repo directory; '${ORNG}/${REPO_NAME}${NRML}'!"
			return 2
		fi

		if [ "${REPO_URI}" = "local" ]
		then
			# Re-initialise a local only repo.
			echo -e "${YELL}The local git repo already exists.${NRML}"
			echo -e "${YELL}Updating from the upstream skeleton repo...${NRML}\n"
			# Temporarily reattach to public upstream skeleton repo, to pull latest changes.
			git remote add origin "${FDO_SERVER_SKELETON_REPO}"
			git fetch
			git branch --set-upstream-to=origin/master master
			git_pull
			# Detach from the remote repo.
			git remote remove origin
		else
			# Re-initialise a local repo and attach it to its remote repo.
			echo -e "${YELL}The local git repo already exists.${NRML}"
			echo -e "${YELL}Updating from the private remote repo...${NRML}\n"
			# Attach the local repo to the private remote repo.
			git remote remove origin
			git remote add origin "${REPO_URI}"
			git fetch
			git branch --set-upstream-to=origin/master master
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} The remote repo is not valid!"
				echo -e "       Check that the remote repo URI is correct."
				echo -e "       Consider using the '${LBLU}merge-local-repo-to-remote${NRML}' subcommand."
				echo -e "       Aborting.\n"
				return 2
			fi
			# Update (pull) the latest changes from the private remote repo.
			git_pull
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to update git repo.\n       Aborting.\n"
				return 2
			fi
		fi

	else

		# ASSUME: The local repo does not exist yet.

		# Move to '/' because this is where we keep the local repo.
		cd /

		if [ "${REPO_URI}" = "local" ]
		then
			# Initialise a new local only repo.
			# Clone the upstream skeleton repo from github.
			echo -e "${YELL}Cloning the upstream skeleton git repo...${NRML}\n"
			git clone "${FDO_SERVER_SKELETON_REPO}" ${REPO_NAME}
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to clone upstream skeleton git repo.\n       Aborting.\n"
				return 2
			fi
			# Move into local repo directory.
			cd "/${REPO_NAME}"
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Unable to enter the repo directory; '${ORNG}/${REPO_NAME}${NRML}'!"
				# TODO: run undo function
				return 2
			fi
			# After we get the skeleton, detach from the upstream skeleton repo.
			git remote remove origin
		else
			# Initialise a new local repo and attach to its remote repo.
			# Clone our private remote git repo.
			echo -e "${YELL}Cloning our private remote git repo...${NRML}\n"
			git clone ${REPO_URI} ${REPO_NAME}
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to clone private remote git repo.\n       Aborting.\n"
				return 2
			fi
		fi
	fi

	echo -e "\n${LGRN}Finished initialising the local repo.${NRML}\n\n"

	return 0
}

install_scripts ()
{

	INSTALL_PATH=${1}

	install_file_tree scripts ${INSTALL_PATH}

	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to copy one or more scripts to target location:"
		echo -e "       ${ORNG}(${INSTALL_PATH})${NRML}\n"
		return 2
	else
		echo -e "\n${LGRN}SUCCESS:${NRML} Installed all scripts successfully!"
		echo -e "         ${LGRN}(${INSTALL_PATH})${NRML}\n"
		return 0
	fi
}

install_scripts_everywhere ()
{
	EXIT_CODE=0

	# Install scripts to the host.
	install_scripts /
	RETURN_CODE=${?}
	if [ ${RETURN_CODE} -gt ${EXIT_CODE} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong installing scripts to the this host!\n"
		EXIT_CODE=${RETURN_CODE}
	fi

	# Install scripts to the jails.
	for JAIL_DIR in `ls -1 /jls 2> /dev/null`
	do
		install_scripts /jls/${JAIL_DIR}/
		RETURN_CODE=${?}
		if [ ${RETURN_CODE} -gt ${EXIT_CODE} ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Something went wrong installing scripts to the '${ORNG}${JAIL_NAME}${NRML}' jail!\n"
			EXIT_CODE=${RETURN_CODE}
		fi
	done

	return ${EXIT_CODE}
}

add_script ()
{

	SCRIPT_PATH="${1}"

	if [ "${SCRIPT_PATH}" = "" ] || [ ! -f ${SCRIPT_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The referenced file '${ORNG}${SCRIPT_PATH}${NRML}' does not exist.\n       Aborting.\n"
		return 1
	elif [ -f "scripts${SCRIPT_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file '${ORNG}scripts${SCRIPT_PATH}${NRML}' already exists."
		echo -e "       Please consider using '${LBLU}${SCRIPT_NAME} update-script${NRML}' instead.\n       Aborting.\n"
		return 1
	else
		cp ${SCRIPT_PATH} scripts${SCRIPT_PATH} > /dev/null 2>&1
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${ORNG}${SCRIPT_PATH}${NRML}'\n       to the local git repo.\n       Aborting.\n"
			return 2
		fi
		git add scripts${SCRIPT_PATH}
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to add '${ORNG}${SCRIPT_PATH}${NRML}'\n       to the local git repo.\n       Aborting.\n"
			rm scripts${SCRIPT_PATH} > /dev/null 2>&1
			return 2
		fi
		git commit -m "Added new script; '${SCRIPT_PATH}'."
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${ORNG}${SCRIPT_PATH}${NRML}'\n       to the local git repo."
			echo -e "       Please consider manually running '${LBLU}git reset --hard${NRML}'"
			echo -e "       to revert to the previous commit.\n       Aborting.\n"
			return 2
		fi
		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
			git_push origin master
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
				echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
				return 2
			fi
		fi
		echo -e "\n${LGRN}OK, it seems we've successfully added the new script!${NRML}\n"
	fi

	return 0
}

update_script ()
{

	SCRIPT_PATH="${1}"

	if [ "${SCRIPT_PATH}" = "" ] || [ ! -f "${SCRIPT_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The referenced file '${ORNG}${SCRIPT_PATH}${NRML}' does not exist.\n       Aborting.\n"
		return 1
	elif [ ! -f "scripts${SCRIPT_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file '${ORNG}scripts${SCRIPT_PATH}${NRML}' does not exist.\n       Aborting.\n"
		return 1
	else
		echo -e ""
		readee -p "${LCYN}Enter a short explanation of the changes made: ${NRML}" CHANGE_MESSAGE
		cp scripts${SCRIPT_PATH} /tmp/${SCRIPT_NAME}_update-script.tmp > /dev/null 2>&1
		cp ${SCRIPT_PATH} scripts${SCRIPT_PATH} > /dev/null 2>&1
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${ORNG}${SCRIPT_PATH}${NRML}'\n       to the local git repo.\n       Aborting.\n"
			return 2
		fi
		git add scripts${SCRIPT_PATH}
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to update '${ORNG}${SCRIPT_PATH}${NRML}'\n       to the local git repo.\n       Aborting.\n"
			mv /tmp/${SCRIPT_NAME}_update-script.tmp scripts${SCRIPT_PATH} > /dev/null 2>&1
			return 2
		else
			rm /tmp/${SCRIPT_NAME}_update-script.tmp > /dev/null 2>&1
		fi
		git commit -m "Updated script; '${SCRIPT_PATH}': ${CHANGE_MESSAGE}."
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${ORNG}${SCRIPT_PATH}${NRML}'\n       to the local git repo."
			echo -e "       Please consider manually running '${LBLU}git reset --hard${NRML}'"
			echo -e "       to revert to the previous commit.\n       Aborting.\n"
			return 2
		fi
		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\n${YELL}Pushing changes to '${NRML}${REPO_NAME}${YELL}' remote repo...\n"
			git_push origin master
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
				echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'."
				echo -e "       Aborting.\n"
				return 2
			fi
		fi
		echo -e "\n${LGRN}OK, it seems we've successfully updated the script!${NRML}\n"
	fi

	return 0
}

install_configs ()
{

	CONFIG_REPO_ROOT=${1}
	INSTALL_PATH=${2}

	if [ ! -d ${CONFIG_REPO_ROOT} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the repo config directory '${ORNG}${CONFIG_REPO_ROOT}${NRML}' does not exist!\n       Aborting.\n"
		return 1
	fi

	if [ ! -d ${INSTALL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the installation directory '${ORNG}${INSTALL_PATH}${NRML}' does not exist!\n       Aborting.\n"
		return 1
	fi

	install_file_tree ${CONFIG_REPO_ROOT} ${INSTALL_PATH}
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to copy one or more config files to the target location:\n       ${ORNG}${CONFIG_REPO_ROOT}${NRML}\n"
		return 2
	else
		echo -e "\n${LGRN}SUCCESS:${NRML} Installed all config files successfully! (${ORNG}${CONFIG_REPO_ROOT}${NRML})\n"
		return 0
	fi
}

install_configs_everywhere ()
{

	EXIT_CODE=0

	# Install configs to the host.
	question_yes_no "Are you sure you want to install all host configs from the repo to this host?"
	if [ "${ANSWER}" = "yes" ]
	then
		install_configs configs/${HOST_NAME} /
		RETURN_CODE=${?}
		if [ ${RETURN_CODE} -gt ${EXIT_CODE} ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Something went wrong installing repo configs to the this host!\n"
			EXIT_CODE=${RETURN_CODE}
		fi
	fi

	# Install configs to the jails.
	for JAIL_NAME in `ls -1 configs | grep -e "@${HOST_NAME}" | cut -d@ -f1`
	do
		question_yes_no "Are you sure you want to install all jail configs from the repo to the\n'${NRML}${JAIL_NAME}${LCYN}' jail?"
		if [ "${ANSWER}" = "yes" ]
		then
			install_configs configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/
			RETURN_CODE=${?}
			if [ ${RETURN_CODE} -gt ${EXIT_CODE} ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Something went wrong installing repo configs to the '${ORNG}${JAIL_NAME}${NRML}' jail!\n"
				EXIT_CODE=${RETURN_CODE}
			fi
		fi
	done
	return ${EXIT_CODE}
}

check_configs ()
{

	CONFIG_REPO_ROOT=${1}
	INSTALL_PATH=${2}

	if [ ! -d ${CONFIG_REPO_ROOT} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the repo config directory '${ORNG}${CONFIG_REPO_ROOT}${NRML}' does not exist!\n"
		return 1
	fi

	if [ ! -d ${INSTALL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the installation directory '${ORNG}${INSTALL_PATH}${NRML}' does not exist!\n"
		return 1
	fi

	compare_file_tree ${CONFIG_REPO_ROOT} ${INSTALL_PATH} ${3}
	return ${?}

}

check_all_configs ()
{

	EXIT_CODE=0
	CHECK_ALL_CONFIGS_ERROR_COUNT=0

	# Check configs for the host.
	echo -e "\n${YELL}Checking configs for the host...${NRML}\n"
	check_configs configs/${HOST_NAME} / "${SUB_ARG1}"
	RETURN_CODE=${?}
	if [ ${RETURN_CODE} -gt ${EXIT_CODE} ]
	then
		EXIT_CODE=${RETURN_CODE}
	fi
	CHECK_ALL_CONFIGS_ERROR_COUNT=$(( ${CHECK_ALL_CONFIGS_ERROR_COUNT} + ${COMPARE_FILE_ERROR_COUNT} ))

	# Check configs for the jails.
	for JAIL_NAME in `ls -1 configs | grep -e "@${HOST_NAME}" | cut -d@ -f1`
	do
		echo -e "\n${YELL}Checking configs for the '${NRML}${JAIL_NAME}${YELL}' jail...${NRML}\n"
		check_configs configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/ "${SUB_ARG1}"
		RETURN_CODE=${?}
		if [ ${RETURN_CODE} -gt ${EXIT_CODE} ]
		then
			EXIT_CODE=${RETURN_CODE}
		fi
		CHECK_ALL_CONFIGS_ERROR_COUNT=$(( ${CHECK_ALL_CONFIGS_ERROR_COUNT} + ${COMPARE_FILE_ERROR_COUNT} ))
	done

	# Display meaningful aggregated results.
	if [ ${CHECK_ALL_CONFIGS_ERROR_COUNT} -lt 1 ]
	then
		echo -e "\n${LGRN}It seems the configs tracked by the repo are all IN CHECK!${NRML}\n"
	elif [ ${CHECK_ALL_CONFIGS_ERROR_COUNT} -eq 1 ]
	then
		echo -e "\n${ORNG}It seems that '${NRML}1${ORNG}' file tracked by the repo is MISSING or OUT OF CHECK!${NRML}\n"
	elif [ ${CHECK_ALL_CONFIGS_ERROR_COUNT} -gt 1 ]
	then
		echo -e "\n${ORNG}It seems that '${NRML}${CHECK_ALL_CONFIGS_ERROR_COUNT}${ORNG}' files tracked by the repo are MISSING or OUT OF CHECK!${NRML}\n"
	fi

	return ${EXIT_CODE}
}

add_config ()
{

	CONFIG_FULL_PATH="${1}"

	echo "${CONFIG_FULL_PATH}" | grep -e "/jls/" > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		# config file belongs to a jail.
		JAIL_NAME=`echo ${CONFIG_FULL_PATH}  | cut -d/ -f3`
		CONFIG_REPO_ROOT=configs/${JAIL_NAME}@${HOST_NAME}
		CONFIG_RELATIVE_PATH=`echo ${CONFIG_FULL_PATH} | sed "s|/jls/${JAIL_NAME}||"`
	else
		# config file belongs to the host.
		CONFIG_REPO_ROOT=configs/${HOST_NAME}
		CONFIG_RELATIVE_PATH=${CONFIG_FULL_PATH}
	fi

	CONFIG_REPO_DIR=`dirname "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}"`
	if [ ! -d ${CONFIG_REPO_DIR} ]
	then
		mkdir -p ${CONFIG_REPO_DIR}
	fi

	if [ "${CONFIG_FULL_PATH}" = "" ] || [ ! -f ${CONFIG_FULL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The file '${ORNG}${CONFIG_FULL_PATH}${NRML}' does not exist.\n       Aborting.\n"
		return 1
	elif [ -f "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file '${ORNG}${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}${NRML}' already exists."
		echo -e "       Please consider using '${LBLU}${SCRIPT_NAME} update-config${NRML}' instead.\n       Aborting.\n"
		return 1
	else
		cp ${CONFIG_FULL_PATH} ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH} > /dev/null 2>&1
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${ORNG}${CONFIG_FULL_PATH}${NRML}'\n       to the local git repo.\n       Aborting.\n"
			return 2
		fi
		git add ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to add '${ORNG}${CONFIG_FULL_PATH}${NRML}'\n       to the local git repo.\n       Aborting.\n"
			rm ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH} > /dev/null 2>&1
			return 2
		fi
		git commit -m "Added new config; '${CONFIG_FULL_PATH}' for ${HOST_NAME}."
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${ORNG}${CONFIG_FULL_PATH}${NRML}'\n       to the local git repo."
			echo -e "       Please consider manually running '${LBLU}git reset --hard${NRML}'"
			echo -e "       to revert to the previous commit.\n       Aborting.\n"
			return 2
		fi
		if [ "${REPO_URI}" != "local" ] && [ "${GIT_NO_PUSH}" != "yes" ]
		then
			echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
			git_push origin master
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
				echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
			fi
		fi
		echo -e "\n${LGRN}OK, it seems we've successfully added the new config file!${NRML}\n"
	fi

	return 0
}

remove_config ()
{

	CONFIG_FULL_PATH="${1}"

	echo "${CONFIG_FULL_PATH}" | grep -e "/jls/" > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		# config file belongs to a jail.
		JAIL_NAME=`echo ${CONFIG_FULL_PATH}  | cut -d/ -f3`
		CONFIG_REPO_ROOT=configs/${JAIL_NAME}@${HOST_NAME}
		CONFIG_RELATIVE_PATH=`echo ${CONFIG_FULL_PATH} | sed "s|/jls/${JAIL_NAME}||"`
	else
		# config file belongs to the host.
		CONFIG_REPO_ROOT=configs/${HOST_NAME}
		CONFIG_RELATIVE_PATH=${CONFIG_FULL_PATH}
	fi

	if [ ! -f "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file '${ORNG}${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}${NRML}' does not exist.\n       Aborting.\n"
		return 1
	else
		git rm "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}"
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to remove '${ORNG}${CONFIG_FULL_PATH}${NRML}' from local git repo.\n       Aborting.\n"
			return 2
		fi
		git commit -m "Remove config; '${CONFIG_FULL_PATH}' for ${HOST_NAME}."
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit removal of '${ORNG}${CONFIG_FULL_PATH}${NRML}'\n       to the local git repo."
			echo -e "       Please consider manually running '${LBLU}git reset --hard${NRML}'"
			echo -e "       to revert to the previous commit.\n       Aborting.\n"
			return 2
		fi
		if [ "${REPO_URI}" != "local" ] && [ "${GIT_NO_PUSH}" != "yes" ]
		then
			echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
			git_push origin master
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
				echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
				return 2
			fi
		fi
		echo -e "\n${LGRN}OK, it seems we've successfully removed the config file!${NRML}\n"
	fi

	CONFIG_REPO_DIR=`dirname "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}"`
	TEST=`ls -A1 "${CONFIG_REPO_DIR}" | wc -l`
	if [ ${TEST} -eq 0 ]
	then
		rmdir ${CONFIG_REPO_DIR}
	fi

	return 0
}

update_config ()
{

	CONFIG_FULL_PATH="${1}"

	echo "${CONFIG_FULL_PATH}" | grep -e "/jls/" > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		# config file belongs to a jail.
		JAIL_NAME=`echo ${CONFIG_FULL_PATH} | cut -d/ -f3`
		CONFIG_REPO_ROOT=configs/${JAIL_NAME}@${HOST_NAME}
		CONFIG_RELATIVE_PATH=`echo ${CONFIG_FULL_PATH} | sed "s|/jls/${JAIL_NAME}||"`
	else
		# config file belongs to the host.
		CONFIG_REPO_ROOT=configs/${HOST_NAME}
		CONFIG_RELATIVE_PATH=${CONFIG_FULL_PATH}
	fi

	CONFIG_REPO_DIR=`dirname "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}"`
	if [ ! -d ${CONFIG_REPO_DIR} ]
	then
		mkdir -p ${CONFIG_REPO_DIR}
	fi

	if [ "${CONFIG_FULL_PATH}" = "" ] || [ ! -f ${CONFIG_FULL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The file '${ORNG}${CONFIG_FULL_PATH}${NRML}' does not exist.\n       Aborting.\n"
		return 1
	elif [ ! -f "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file:\n       ${ORNG}${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}${NRML}\n       does not exist.\n       Aborting.\n"
		return 1
	else
		if [ ! -n "${CHANGE_MESSAGE}" ]
		then
			echo -e ""
			readee -p "${LCYN}Enter a short explanation of the changes made: ${NRML}" CHANGE_MESSAGE
		fi
		cp ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH} /tmp/${SCRIPT_NAME}_update-config.tmp > /dev/null 2>&1
		cp ${CONFIG_FULL_PATH} ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH} > /dev/null 2>&1
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${ORNG}${CONFIG_FULL_PATH}${NRML}'\n       to the local git repo.\n       Aborting.\n"
			return 2
		fi
		git add ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to update '${ORNG}${CONFIG_FULL_PATH}${NRML}'\n       to the local git repo.\n       Aborting.\n"
			mv /tmp/${SCRIPT_NAME}_update-config.tmp ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH} > /dev/null 2>&1
			return 2
		else
			rm /tmp/${SCRIPT_NAME}_update-config.tmp > /dev/null 2>&1
		fi
		git commit -m "Updated config; '${CONFIG_FULL_PATH}' for ${HOST_NAME}: ${CHANGE_MESSAGE}."
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${ORNG}${CONFIG_FULL_PATH}${NRML}'\n       to the local git repo."
			echo -e "       Please consider manually running '${LBLU}git reset --hard${NRML}' "
			echo -e "       to revert to the previous commit.\n       Aborting.\n"
			return 2
		fi
		if [ "${REPO_URI}" != "local" ] && [ "${GIT_NO_PUSH}" != "yes" ]
		then
			echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
			git_push origin master
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
				echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
				return 2
			fi
		fi
		echo -e "\n${LGRN}OK, it seems we've successfully updated the config file!${NRML}\n"
	fi

	return 0
}

update_local_repo ()
{

	if [ "${1}" = "--no-check-scripts" ]
	then
		CHECK_SCRIPTS="no"
	else
		CHECK_SCRIPTS="yes"
	fi

	if [ ! -d "/${REPO_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the local git repo '${ORNG}/${REPO_NAME}${NRML}' does not exist!\n       Aborting.\n"
		exit 1
	fi

	cd "/${REPO_NAME}"
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to enter the repo directory; '${ORNG}/${REPO_NAME}${NRML}'!\n       Aborting.\n"
		exit 1
	fi

	if [ "${REPO_URI}" = "local" ]
	then
		echo -e "\n${YELL}No need to update the local repo, there is no remote repo.${NRML}\n"
	else

		# Get the pre-update git commit reference.
		PRE_UPDATE_COMMIT_REF=`git log --format=format:%H -1`

		echo -e "\n${YELL}First, let's update the local git repo...${NRML}\n"
		git_pull
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to update the local git repo."
			echo -e "       Please use '${LBLU}git status${NRML}' to find the cause.\n       Aborting.\n"
			exit 2
		fi
		# Get the post-update git commit reference.
		POST_UPDATE_COMMIT_REF=`git log --format=format:%H -1`

		if [ "${CHECK_SCRIPTS}" = "yes" ]
		then
			# Check if any scripts have been updated in this update cycle.
			echo -e "\n${YELL}Checking if any scripts have been updated in this update...${NRML}\n"
			git diff-tree --no-commit-id --name-only -r ${PRE_UPDATE_COMMIT_REF} ${POST_UPDATE_COMMIT_REF} | grep "^scripts/"

			if [ ${?} -eq 0 ]
			then
				# Ask whether to perform an 'install-scripts'.
				question_yes_no "\nIt seems that one or more scripts have been updated.\nWould you like to perform an '${NRML}install-scripts${LCYN}' now?"
				if [ "${ANSWER}" = "yes" ]
				then
					install_scripts_everywhere
				else
					echo -e "${YELL}You may perform an '${NRML}install-scripts${YELL}' later by running the command:\n${LBLU}${SCRIPT_NAME} install-scripts${NRML}"
				fi
				echo -e ""
			fi
		fi
	fi

	return 0
}

merge_local_repo_to_remote ()
{
	# Test that we are actually using a local repo.
	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears you are already using a remote repo!\n"
		question_yes_no "Would you like to proceed regardless?"
		if [ "${ANSWER}" = "no" ]
		then
			echo "\nAborting.\n"
			return 1
		fi
	fi

	# Ask for the URI of the remote repo.
	REMOTE_REPO_URI=""
	while [ "${REMOTE_REPO_URI}" = "" ]
	do
		echo -e "\n${LCYN}Enter the remote git repo URI:${NRML}"
		readee REMOTE_REPO_URI_TEMP
		# Allow use to change their mind about type of repo.
		if [ "${REMOTE_REPO_URI_TEMP}" = "" ]
		then
			break
		fi
		# Test the input to see if it is a valid URI (URL).
		test_valid_simple_url "${REMOTE_REPO_URI_TEMP}"
		if [ "${VALID_URL}" = "yes" ]
		then
			question_yes_no "\nYou have entered '${NRML}${REMOTE_REPO_URI_TEMP}${LCYN}'\nas the remote git repo URI.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				REMOTE_REPO_URI=${REMOTE_REPO_URI_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} remote git repo URI is invalid!\n"
		fi
	done

	# Check that the remote repo is valid and that this hostname does not already exist.
	cd /tmp
	rm -rf "${REPO_NAME}"
	echo -e "\n${YELL}We need to check that this host does not already exist in the remote repo.${NRML}"
	echo -e "${YELL}Please enter the remote repo credentials when prompted...${NRML}\n"
	pause_prompt 8
	git clone "${REMOTE_REPO_URI}" "${REPO_NAME}"
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to clone the remote repo!\n       Aborting.\n"
		return 2
	fi
	if [ ! -d "${REPO_NAME}/configs/" ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The remote repo does not contain a config directory."
		echo -e "         This usually means that it is a newly created, empty repo.\n"
	elif [ -d  "${REPO_NAME}/configs/${HOST_NAME}" ]
	then
		rm -rf "${REPO_NAME}"
		echo -e "\n${LRED}ERROR:${NRML} This host already exists in the remote repo!"
		echo -e "       Consider removing or renaming the stale host config directory in the"
		echo -e "       remote repo.\n       Aborting.\n"
		return 1
	else
		echo -e "\n${LGRN}The remote repo seems to be ok!${NRML}\n"
	fi
	rm -rf "${REPO_NAME}"

	# Move into the local repo.
	cd "/${REPO_NAME}"

	# Record last local commit, so that we can rewind if needed.
	LAST_LOCAL_COMMIT=`git log -1 | head -1 | awk '{print $2}'`

	# Check for an existing (stale) remote repo, and if user agrees, proceed and delete it.
	EXISTING_REMOTE=`git remote -v | egrep "^origin" | grep '(push)$' | awk '{print $2}'`
	if [ "${EXISTING_REMOTE}" != "" ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} There appears to be an existing remote origin in the local repo!"
		echo -e "         Git URI of origin:\n         '${ORNG}${EXISTING_REMOTE}${NRML}'\n"
		question_yes_no "Would you like to proceed?"
		if [ "${ANSWER}" = "yes" ]
		then
			git remote remove origin
		else
			return 1
		fi
	fi

	# Add the remote repo URI as this local repos' remote.
	git remote add origin "${REMOTE_REPO_URI}" > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to add the remote repo as the origin!\n       Aborting.\n"
		return 2
	fi

	# Fetch the remote repo.
	echo -e "\n${YELL}Next we need to fetch the remote repo into our local repo.${NRML}"
	echo -e "${YELL}Please enter the remote repo credentials when prompted...${NRML}\n"
	pause_prompt 8
	git fetch
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to fetch the remote repo (origin/master)!\n       Aborting.\n"
		git remote remove origin
		return 1
	fi

	# Align the master branch on both local and remote repo.
	git branch --set-upstream-to=origin/master master > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		# Remote is non-empty. Perform a merge of the local and remote master branch.
		echo -e "\n${YELL}Next we need to merge the remote repo and our local repo...${NRML}\n"
		pause_prompt 8
		git merge origin/master --allow-unrelated-histories -m "Merging local repo from host '${HOST_NAME}'."
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The merge operation seems to have failed!\n       Aborting.\n"
			git remote remove origin
			return 2
		fi
	else
		NEEDS_UPSTREAM_BRANCH_SET="yes"
	fi

	# Lastly, push the local repo deltas to the remote repo.
	echo -e "\n${YELL}Now we need to push the local repo changes to the remote repo.${NRML}"
	echo -e "${YELL}Please enter the remote repo credentials when prompted...${NRML}\n"
	pause_prompt 8
	git_push origin master
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The push operation seems to have failed!\n       Aborting.\n"
		git remote remove origin
		git reset --soft "${LAST_LOCAL_COMMIT}"
		return 1
	fi

	if [ "${NEEDS_UPSTREAM_BRANCH_SET}" = "yes" ]
	then
		# Align the master branch on both local and remote repo.
		git branch --set-upstream-to=origin/master master > /dev/null 2>&1
	fi

	REPO_URI="${REMOTE_REPO_URI}"
	echo "${REPO_URI}" >  "${FDO_CONFIG_ROOT}/fdo-server-repo.conf"
	
	echo -e "\n\n${LGRN}Congratulations! Successfully merged this hosts local repo to the remote repo.${NRML}\n"

	return 0
}

connect_internet ()
{

	# Get available interfaces and the quantity thereof.
	NET_IFACES=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "${NET_IFACES_IGNORED}" | cut -d: -f1`
	NUM_NET_IFACES=`echo ${NET_IFACES} | wc -w`
	if [ ${NUM_NET_IFACES} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No usable network interfaces found.       Aborting.\n"
		return 1
	fi

	WAN_NET_IFACE=""
	USES_PPP=""
	USES_VLAN=""
	VLAN_ID=""
	PPP_AUTHNAME=""
	PPP_AUTHKEY=""
	IS_WAN_IFACE_DHCP=""
	WAN_IFACE_IP=""
	WAN_IFACE_NETMASK=""
	WAN_GATEWAY_IP=""

	# Configure WAN interface.
	if [ ${NUM_NET_IFACES} -lt 2 ]
	then
		WAN_NET_IFACE=${NET_IFACES}
		echo -e "\n${YELL}Using '${NRML}${WAN_NET_IFACE}${YELL}' as the WAN (internet facing) network interface,${NRML}"
		echo -e "${YELL}since it's all that's available.${NRML}\n"
	else
		SELECT_IFACE_PROMPT="Select the WAN network interface (internet facing):"
		while [ "${WAN_NET_IFACE}" = "" ]
		do
			dialog --no-items --no-cancel --menu "${SELECT_IFACE_PROMPT}" 12 40 10 ${NET_IFACES} 2> ${DIALOG_OUT_FILE}
			WAN_NET_IFACE_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${WAN_NET_IFACE_TEMP}${LCYN}' as the WAN interface for this host.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				WAN_NET_IFACE="${WAN_NET_IFACE_TEMP}"
				break
			fi
			sleep 4
		done
	fi

	# Optionally configure PPP.
	question_yes_no "\nDo you want to use PPPoE for the WAN interface (internet facing)?"
	USES_PPP=${ANSWER}
	if [ "${USES_PPP}" = "yes" ]
	then
		question_yes_no "\nDoes your PPPoE connection require a VLAN tag?"
		USES_VLAN=${ANSWER}
		if [ "${USES_VLAN}" = "yes" ]
		then
			while [ "${VLAN_ID}" = "" ]
			do
				echo -e ""
				readee -p "${LCYN}Enter VLAN ID (tag): ${NRML}" VLAN_ID_TEMP
				# Check that the VLAN ID only contains numbers being a minimum of 1 and maximum of 4096.
				test_valid_integer "${VLAN_ID_TEMP}" 1 4096
				if [ "${VALID_INTEGER}" = "no" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} The VLAN ID can not be '${ORNG}${VLAN_ID}${NRML}'."
					echo -e "       It must be a number between 1 and 4096.\n"
				else
					question_yes_no "\nYou have entered '${NRML}${VLAN_ID_TEMP}${LCYN}' as the VLAN ID.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						VLAN_ID=${VLAN_ID_TEMP}
					fi
				fi
			done
		fi

		# Get PPP authname.
		while [ "${PPP_AUTHNAME}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter PPP authname (dialing username): ${NRML}" PPP_AUTHNAME_TEMP
			if [ "${PPP_AUTHNAME_TEMP}" = "" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Authname empty, try again!\n"
			else
				question_yes_no "\nYou have entered '${NRML}${PPP_AUTHNAME_TEMP}${LCYN}' as the PPP authname.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					PPP_AUTHNAME=${PPP_AUTHNAME_TEMP}
				fi
			fi
		done

		# Get PPP authkey.
		while [ "${PPP_AUTHKEY}" = "" ]
		do
			echo -e ""
			readee -s -p "${LCYN}Enter PPP authkey (dialing password): ${NRML}" PPP_AUTHKEY_TEMP1
			readee -s -p "${LCYN}Re-enter PPP authkey                : ${NRML}" PPP_AUTHKEY_TEMP2
			
			if [ "${PPP_AUTHKEY_TEMP1}" != "${PPP_AUTHKEY_TEMP2}" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Authkey mismatch, try again!\n"
			elif [ "${PPP_AUTHKEY_TEMP1}" = "" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Authkey not entered, try again!\n"
			else
				PPP_AUTHKEY=${PPP_AUTHKEY_TEMP1}
			fi
		done

		echo -e ""
	fi
	# END: configure PPP.


	# Configure WAN interface IP address and subnet mask.
	question_yes_no "\nDo you want to use DHCP for the WAN interface?"
	IS_WAN_IFACE_DHCP=${ANSWER}
	if [ "${IS_WAN_IFACE_DHCP}" = "no" ]
	then
		# Set up static IP and netmask for WAN interface.
		while [ "${WAN_IFACE_IP}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter static IP for WAN interface: ${NRML}" WAN_IFACE_IP_TEMP
			test_valid_inet_address "${WAN_IFACE_IP_TEMP}"
			if [ "${VALID_INET_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${WAN_IFACE_IP_TEMP}${LCYN}' as the WAN interface IP address.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_IFACE_IP=${WAN_IFACE_IP_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} IP address is invalid!\n"
			fi
		done

		while [ "${WAN_IFACE_NETMASK}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter netmask for WAN interface: ${NRML}" WAN_IFACE_NETMASK_TEMP
			test_valid_inet_address "${WAN_IFACE_NETMASK_TEMP}"
			if [ "${VALID_INET_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${WAN_IFACE_NETMASK_TEMP}${LCYN}' as the WAN interface netmask.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_IFACE_NETMASK=${WAN_IFACE_NETMASK_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} Subnet mask is invalid!\n"
			fi
		done

		# Set default router.
		while [ "${WAN_GATEWAY_IP}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter the gateway (default router) IP address for this host: ${NRML}" WAN_GATEWAY_IP_TEMP
			test_valid_inet_address "${WAN_GATEWAY_IP_TEMP}"
			if [ "${VALID_INET_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${WAN_GATEWAY_IP_TEMP}${LCYN}' as the gateway (default router).\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_GATEWAY_IP=${WAN_GATEWAY_IP_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} Gateway (default router) IP address is invalid!\n"
			fi
		done
	fi
	# END: if IS_WAN_IFACE_DHCP = no.


	# Stop services that may interfere with a simple internet connection.
	echo -e "\n${YELL}Stopping unwanted network services...${NRML}\n"
	service natd onestop > /dev/null 2>&1
	service pflog onestop > /dev/null 2>&1
	service pf onestop > /dev/null 2>&1
	service ipfw onestop > /dev/null 2>&1
	service ipfilter onestop > /dev/null 2>&1
	service ppp onestop > /dev/null 2>&1
	pkill ppp

	sleep ${NET_CONNECT_TIMEOUT_SECS}

	# Destroy all existing interfaces.
	echo -e "\n${YELL}Destroying existing interfaces...${NRML}\n"
	NET_IFACES_TO_DESTROY=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "^lo0" | cut -d: -f1`
	for IFACE_TO_DESTROY in ${NET_IFACES_TO_DESTROY}
	do
		ifconfig ${IFACE_TO_DESTROY} down delete > /dev/null 2>&1
		ifconfig ${IFACE_TO_DESTROY} destroy > /dev/null 2>&1
	done

	# Flush routing table.
	echo -e "\n${YELL}Flushing routing table...${NRML}\n"
	route flush > /dev/null 2>&1

	# Backup and replace resolv.conf with a generic working copy.
	backup_file /etc/resolv.conf connect-internet
	echo "nameserver 1.1.1.1" > /etc/resolv.conf
	echo "nameserver 8.8.8.8" >> /etc/resolv.conf

	# Setup interface and routing.
	echo -e "\n${YELL}Setup WAN interface and routing...${NRML}\n"
	ifconfig ${WAN_NET_IFACE} up

	if [ "${USES_PPP}" = "yes" ]
	then
		backup_file /etc/ppp/ppp.conf connect-internet
		echo "default:" > /etc/ppp/ppp.conf
		echo " set log Phase Chat LCP IPCP CCP tun command" >> /etc/ppp/ppp.conf
		echo " ident user-ppp VERSION" >> /etc/ppp/ppp.conf
		echo " disable iface-alias" >> /etc/ppp/ppp.conf
		echo " iface clear" >> /etc/ppp/ppp.conf
		if [ "${USES_VLAN}" = "yes" ]
		then
			ifconfig ${WAN_NET_IFACE}.${VLAN_ID} create vlan ${VLAN_ID} vlandev ${WAN_NET_IFACE} up
			echo " set device PPPoE:${WAN_NET_IFACE}_${VLAN_ID}" >> /etc/ppp/ppp.conf
		else
			echo " set device PPPoE:${WAN_NET_IFACE}" >> /etc/ppp/ppp.conf
		fi
		echo " set authname ${PPP_AUTHNAME}" >> /etc/ppp/ppp.conf
		echo " set authkey ${PPP_AUTHKEY}" >> /etc/ppp/ppp.conf
		echo " set dial" >> /etc/ppp/ppp.conf
		echo " set login" >> /etc/ppp/ppp.conf
		echo " set redial 30 0" >> /etc/ppp/ppp.conf
		echo " set reconnect 5 0" >> /etc/ppp/ppp.conf
		echo " set timeout 0" >> /etc/ppp/ppp.conf
		echo " enable lqr echo" >> /etc/ppp/ppp.conf
		echo " set lqrperiod 45" >> /etc/ppp/ppp.conf
		if [ "${IS_WAN_IFACE_DHCP}" = "yes"  ]
		then
			echo " set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255 0.0.0.0" >> /etc/ppp/ppp.conf
		else
			echo " set ifaddr ${WAN_IFACE_IP} ${WAN_GATEWAY_IP} ${WAN_IFACE_NETMASK} 0.0.0.0" >> /etc/ppp/ppp.conf
		fi
		echo " add default HISADDR" >> /etc/ppp/ppp.conf
		ppp -ddial
	else
		if [ "${IS_WAN_IFACE_DHCP}" = "yes" ]
		then
			pkill dhclient > /dev/null 2>&1
			backup_file /etc/resolv.conf connect-internet
			dhclient ${WAN_NET_IFACE}
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} DHCP failed on '${ORNG}${WAN_NET_IFACE}${NRML}'!\n       Aborting.\n"
				return 1
			fi
		else
			ifconfig ${WAN_NET_IFACE} inet ${WAN_IFACE_IP} netmask ${WAN_IFACE_NETMASK} up
			route add default ${WAN_GATEWAY_IP} > /dev/null 2>&1
		fi
	fi

	IS_IP_WORKING="no"
	WAIT_CYCLES=0

	while [ "${IS_IP_WORKING}" = "no" ] && [ ${WAIT_CYCLES} -lt 10 ]
	do
		# Sleep for 16 seconds for connection to establish.
		echo -e "\n${YELL}Waiting for ${NET_CONNECT_TIMEOUT_SECS} seconds for connection to establish...${NRML}\n"
		sleep ${NET_CONNECT_TIMEOUT_SECS}

		# Test internet connection.
		test_ping_host "${INET_TEST_IPV4}"
		if [ "${VALID_HOST_PING}" = "yes" ]
		then
			IS_IP_WORKING="yes"
		fi

		WAIT_CYCLES=$(( ${WAIT_CYCLES} + 1 ))
	done

	if [ "${IS_IP_WORKING}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} IP connection failed! Unable to ping ${INET_TEST_IPV4}.\n       Aborting.\n"
		return 1
	fi

	IS_DNS_WORKING="no"
	WAIT_CYCLES=0

	while [ "${IS_DNS_WORKING}" = "no" ] && [ ${WAIT_CYCLES} -lt 3 ]
	do

		if [ ${WAIT_CYCLES} -ne 0 ]
		then
			# Sleep for 16 seconds for DNS to establish.
			echo -e "\n${YELL}Waiting for ${NET_CONNECT_TIMEOUT_SECS} seconds for DNS to establish...${NRML}\n"
			sleep ${NET_CONNECT_TIMEOUT_SECS}
		fi

		# Test DNS.
		host "${INET_TEST_HOSTNAME}" > /dev/null 2>&1
		if [ ${?} -eq 0 ]
		then
			IS_DNS_WORKING="yes"
		fi
		
		WAIT_CYCLES=$(( ${WAIT_CYCLES} + 1 ))
	done
			
	if [ "${IS_DNS_WORKING}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} internet DNS failed! Unable to lookup google.com.\n       Aborting.\n"
		return 1
	fi

	echo -e "\n${LGRN}Successfully connected to the internet!${NRML}\n"

	return 0
}

undo_init_host ()
{

	ERROR_COUNT=0

	if [ ${INIT_HOST_TZSETUP_DONE} = true ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The timezone has been changed via 'tzsetup'"
		echo -e "		and won't be reverted automatically.\n"
	fi

	if [ ${INIT_HOST_ARBITRARY_USER_ADDED} = true ]
	then
		rmuser -y "${ARBITRARY_USERNAME}" > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${INIT_HOST_TOOR_SHELL_CHANGED} = true ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The shell has been changed for the 'toor' user"
		echo -e "		and won't be reverted automatically.\n"
	fi

	if [ ${INIT_HOST_TOOR_PASSWORD_CHANGED} = true ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The password has been changed for the 'toor' user"
		echo -e "		and can't be reverted automatically.\n"
	fi

	if [ ${INIT_HOST_SYSTEM_MODIFIED} = true ]
	then
		# Restore pre-existing core system config files.
		for CONFIG_FILE in `find config-templates/init-host/ -type f -print | sed "s|^config-templates/init-host||"`
		do
			# Try to find the most  up-to--date backup file for current CONFIG_FILE.
			BACKUP_CONFIG_FILE=`ls -1 ${CONFIG_FILE}.init-host_backup_* 2> /dev/null | sort | tail -1`
			if [ -e "${BACKUP_CONFIG_FILE}" ]
			then
				cp ${BACKUP_CONFIG_FILE} ${CONFIG_FILE}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			fi
		done
	fi

	if [ ${INIT_HOST_REPO_MODIFIED} = true ]
	then
		# TODO: consider replacing with 'git reset --hard'; see create_vm_template.
		rm -rf configs/${HOST_NAME}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${INIT_HOST_ROOT_POOL_COMPRESS_TURN_ON} = true ]
	then
		zfs set compression=on ${ROOT_POOL}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} There was at least one unexpected error undoing the init-host process!\n"
		return 2
	fi

	echo -e "\nAborting.\n"
	return 0
}

init_host ()
{

	INIT_HOST_ROOT_POOL_COMPRESS_TURN_ON=false
	INIT_HOST_REPO_MODIFIED=false
	INIT_HOST_SYSTEM_MODIFIED=false
	INIT_HOST_TOOR_PASSWORD_CHANGED=false
	INIT_HOST_TOOR_SHELL_CHANGED=false
	INIT_HOST_ARBITRARY_USER_ADDED=false
	INIT_HOST_TZSETUP_DONE=false

	trap 'undo_init_host ; exit 3' HUP INT QUIT KILL TERM

	ERROR_COUNT=0

	# ASSUME: we have to assume we only have base userland at this point. No local repo either.

	HOST_NAME=${1}
	DOMAIN_NAME=${2}

	# Check that the host name is valid.
	test_valid_host_name "${HOST_NAME}"
	if [ "${VALID_HOST_NAME}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The hostname can not be '${ORNG}${HOST_NAME}${NRML}'."
		echo -e "       It must only contain letters, numbers and hyphens."
		echo -e "       It must not begin or end with a hyphen."
		echo -e "       Aborting.\n"
		return 1
	fi

	# Check that the domain name is valid.
	test_valid_fqhn  "${DOMAIN_NAME}"
	if [ "${VALID_FQHN}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The domain name can not be '${ORNG}${DOMAIN_NAME}${NRML}'."
		echo -e "       It must only contain letters, numbers, periods and hyphens."
		echo -e "       It must not begin or end with a hyphen or a period."
		echo -e "       Aborting.\n"
		return 1
	fi

	# Update pkgng repositories.
	echo -e "\n${YELL}First we need to update pkg (pkgng) repositories...${NRML}\n"
	pkg update
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to update pkg (pkgng) repositories.\n       Aborting.\n"
		return 1
	fi

	# Install essential packages.
	echo -e "\n${YELL}Next we need to install some essential packages...${NRML}\n"
	pause_prompt 8
	pkg update -f
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	pkg install -y ${ESSENTIAL_PACKAGES}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} A problem was encountered whilst installing required packages!\n"
		undo_init_host
		return 2
	fi

	# Initialise the local private repo.
	init_local_repo
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to initialise the local git repo.\n"
		undo_init_host
		return 2
	fi

	# Initialise the git config, so we can commit and push without warnings.
	init_git_config
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to initialise the git configuration.\n"
		undo_init_host
		return 2
	fi

	# Check that the local repo is not empty, otherwise pull a fresh skeleton.
	if [ ! -d "/${REPO_NAME}/configs" ]
	then
		# Get a skeleton from the public upstream skeleton repo.
		echo -e "\n${ORNG}WARNING:${NRML} Repo is invalid! It is missing the configs directory."
	    echo -e "         we will attempt to fetch the upstream skeleton git repo...${NRML}\n"
		pause_prompt 8
		upgrade_repo_from_upstream --no-install-scripts
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to get a skeleton from the public upstream skeleton git repo.\n"
			undo_init_host
			return 2
		fi
	fi

	# Check that the hostname is not already taken.
	if [ -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The hostname can not be '${ORNG}${HOST_NAME}${NRML}'!"
		echo -e "       It is already registered as a host in the repo."
		undo_init_host
		return 1
	fi

	INIT_HOST_REPO_MODIFIED=true

	# Copy init-host template configs to the repo.
	mkdir configs/${HOST_NAME}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	install_file_tree config-templates/init-host configs/${HOST_NAME}/
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst creating the host entry in the local repo!\n"
		undo_init_host
		return 2
	fi

	# Get available interfaces and the quantity thereof.
	NET_IFACES=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "${NET_IFACES_IGNORED}" | cut -d: -f1`
	NUM_NET_IFACES=`echo ${NET_IFACES} | wc -w`
	if [ ${NUM_NET_IFACES} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No usable network interfaces found!\n       Aborting.\n"
		undo_init_host
		return 1
	fi

	SERVER_TYPE=""
	while [ "${SERVER_TYPE}" = "" ]
	do
		dialog --no-cancel --menu "Select the type of server:" 12 80 10 \
					 "remote" "Remote Server (Datacenter/Cloud)" \
					 "primary_local" "Primary Local Server (Internet & LAN Gateway/NAT Router)" \
					 "auxiliary_local" "Auxiliary Local Server (LAN)" \
					 2> ${DIALOG_OUT_FILE}
		SERVER_TYPE_TEMP=`cat ${DIALOG_OUT_FILE}`
		echo -e "\n"
		question_yes_no "\nYou have selected '${NRML}${SERVER_TYPE_TEMP}${LCYN}' as the server type for this host.\nIs this correct?"
		if [ "${ANSWER}" = "yes" ]
		then
			SERVER_TYPE="${SERVER_TYPE_TEMP}"
			break
		fi
		sleep 4
	done

	WAN_NET_IFACE=""
	LAN_NET_IFACE=""
	USES_PPP=""
	USES_VLAN=""
	VLAN_ID=""
	PPP_AUTHNAME=""
	PPP_AUTHKEY=""
	IS_WAN_IFACE_DHCP=""
	IS_LAN_IFACE_DHCP=""
	WAN_IFACE_IP=""
	LAN_IFACE_IP=""
	WAN_IFACE_NETMASK=""
	LAN_IFACE_NETMASK=""
	WAN_GATEWAY_IP=""

	case ${SERVER_TYPE} in
		remote)
			LAN_NET_IFACE="lo1"
			;;
		primary_local)
			if [ ${NUM_NET_IFACES} -lt 2 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Not enough network interfaces found (2 required)!\n       Aborting.\n"
				undo_init_host
				return 1
			fi
			;;
		auxiliary_local)
			WAN_NET_IFACE="NULL"
			;;
	esac

	# Configure WAN interface (if required).
	if [ "${WAN_NET_IFACE}" != "NULL" ]
	then
		if [ ${NUM_NET_IFACES} -lt 2 ]
		then
			WAN_NET_IFACE=${NET_IFACES}
			echo -e "\n${YELL}Using '${NRML}${WAN_NET_IFACE}${YELL}' as the WAN (internet facing) network interface,${NRML}"
			echo -e "${YELL}since it's all that's available.${NRML}\n"
		else
			SELECT_IFACE_PROMPT="Select the WAN network interface (internet facing):"
			while [ "${WAN_NET_IFACE}" = "" ]
			do
				dialog --no-items --no-cancel --menu "${SELECT_IFACE_PROMPT}" 12 40 10 ${NET_IFACES} 2> ${DIALOG_OUT_FILE}
				WAN_NET_IFACE_TEMP=`cat ${DIALOG_OUT_FILE}`
				echo -e "\n"
				question_yes_no "\nYou have selected '${NRML}${WAN_NET_IFACE_TEMP}${LCYN}' as the WAN interface for this host.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_NET_IFACE="${WAN_NET_IFACE_TEMP}"
					break
				fi
			done
			sleep 4
		fi

		sed -i "" "s/WAN_NET_IFACE/${WAN_NET_IFACE}/g" configs/${HOST_NAME}/etc/rc.conf
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.nic_id "${WAN_NET_IFACE}"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		if [ ${ERROR_COUNT} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst configuring the WAN interface NIC ID!\n"
			undo_init_host
			return 2
		fi

		# Optionally configure PPP.
		question_yes_no "\nDo you want to use PPPoE for the WAN interface (internet facing)?"
		USES_PPP=${ANSWER}
		if [ "${USES_PPP}" = "yes" ]
		then
			question_yes_no "\nDoes your PPPoE connection require a VLAN tag?"
			USES_VLAN=${ANSWER}
			if [ "${USES_VLAN}" = "yes" ]
			then
				while [ "${VLAN_ID}" = "" ]
				do
					echo -e ""
					readee -p "${LCYN}Enter VLAN ID (tag): ${NRML}" VLAN_ID_TEMP
					# Check that the VLAN ID only contains numbers being a minimum of 1 and maximum of 4096.
					test_valid_integer "${VLAN_ID_TEMP}" 1 4096
					if [ "${VALID_INTEGER}" = "no" ]
					then
						echo -e "\n${LRED}ERROR:${NRML} The VLAN ID can not be '${ORNG}${VLAN_ID}${NRML}'."
						echo -e "       It must be a number between 1 and 4096.\n"
					else
						question_yes_no "\nYou have entered '${NRML}${VLAN_ID_TEMP}${LCYN}' as the VLAN ID.\nIs this correct?"
						if [ "${ANSWER}" = "yes" ]
						then
							VLAN_ID=${VLAN_ID_TEMP}
							break
						fi
					fi
					sleep 4
				done
				sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"up\"\\${CARRIAGE_RETURN}ifconfig_${WAN_NET_IFACE}_${VLAN_ID}=\"up\"/" configs/${HOST_NAME}/etc/rc.conf
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				sed -i "" "s/^#vlans_${WAN_NET_IFACE}=\"\"/vlans_${WAN_NET_IFACE}=\"${VLAN_ID}\"/" configs/${HOST_NAME}/etc/rc.conf
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				sed -i "" "s/PPP_IFACE/${WAN_NET_IFACE}_${VLAN_ID}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.vlan_id "${VLAN_ID}"
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			else
				sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"up\"/" configs/${HOST_NAME}/etc/rc.conf
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				sed -i "" "s/PPP_IFACE/${WAN_NET_IFACE}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			fi
	
			# Get PPP authname.
			while [ "${PPP_AUTHNAME}" = "" ]
			do
				echo -e ""
				readee -p "${LCYN}Enter PPP authname (dialing username): ${NRML}" PPP_AUTHNAME_TEMP
				
				if [ "${PPP_AUTHNAME_TEMP}" = "" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Authname empty, try again!\n"
				else
					question_yes_no "\nYou have entered '${NRML}${PPP_AUTHNAME_TEMP}${LCYN}' as the PPP authname.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						PPP_AUTHNAME=${PPP_AUTHNAME_TEMP}
						break
					fi
				fi
				sleep 4
			done

			# Get PPP authkey.
			while [ "${PPP_AUTHKEY}" = "" ]
			do
				echo -e ""
				readee -s -p "${LCYN}Enter PPP authkey (dialing password): ${NRML}" PPP_AUTHKEY_TEMP1
				readee -s -p "${LCYN}Re-enter PPP authkey                : ${NRML}" PPP_AUTHKEY_TEMP2

				if [ "${PPP_AUTHKEY_TEMP1}" != "${PPP_AUTHKEY_TEMP2}" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Authkey mismatch, try again!\n"
				elif [ "${PPP_AUTHKEY_TEMP1}" = "" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Authkey not entered, try again!\n"
				else
					PPP_AUTHKEY=${PPP_AUTHKEY_TEMP1}
					break
				fi
				sleep 4
			done

			echo -e ""

			sed -i "" "s/isp_authname/${PPP_AUTHNAME}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			sed -i "" "s/isp_authkey/${PPP_AUTHKEY}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			sysrc -f configs/${HOST_NAME}/etc/rc.conf "ppp_enable=YES" > /dev/null 2>&1
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			sysrc -f configs/${HOST_NAME}/etc/rc.conf "ppp_nat=YES" > /dev/null 2>&1
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.id "tun${WAN_PPP_TUN_ID}"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.type "pppoe"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.ppp_authname "${PPP_AUTHNAME}"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.ppp_authkey "${PPP_AUTHKEY}"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.ppp_nat_enabled true
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		else
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.type "ethernet"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.id "${WAN_NET_IFACE}"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi
		# END: configure PPP.

		if [ ${ERROR_COUNT} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst configuring PPPoE!\n"
			undo_init_host
			return 2
		fi

		# Configure WAN interface IP address, subnet mask and gateway.
		question_yes_no "\nDo you want to use DHCP for the WAN interface?"
		IS_WAN_IFACE_DHCP=${ANSWER}
		if [ "${IS_WAN_IFACE_DHCP}" = "no" ]
		then
			# Set up static IP and netmask for WAN interface.
			while [ "${WAN_IFACE_IP}" = "" ]
			do
				echo -e ""
				readee -p "${LCYN}Enter static IP for WAN interface: ${NRML}" WAN_IFACE_IP_TEMP
				test_valid_inet_address "${WAN_IFACE_IP_TEMP}"
				if [ "${VALID_INET_ADDRESS}" = "yes" ]
				then
					get_class_c_subnet ${WAN_IFACE_IP_TEMP}
					get_class_b_subnet ${WAN_IFACE_IP_TEMP}
					WAN_SUBNET_C="${CLASS_C_SUBNET}"
					WAN_SUBNET_B="${CLASS_B_SUBNET}"
					if [ "${WAN_SUBNET_B}" = "${FDO_LAN_SUBNET_B}" ]
					then
						echo -e "\n${LRED}ERROR:${NRML} In a gateway configuration the WAN interface IP address must not be in"
						echo -e "       the '${ORNG}${FDO_LAN_SUBNET_B}.*.*${NRML}' subnet!\n"
					else
						question_yes_no "\nYou have entered '${NRML}${WAN_IFACE_IP_TEMP}${LCYN}' as the WAN interface IP address.\nIs this correct?"
						if [ "${ANSWER}" = "yes" ]
						then
							WAN_IFACE_IP=${WAN_IFACE_IP_TEMP}
							break
						fi
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} IP address is invalid!\n"
				fi
				sleep 4
			done

			while [ "${WAN_IFACE_NETMASK}" = "" ]
			do
				echo -e ""
				readee -p "${LCYN}Enter netmask for WAN interface: ${NRML}" WAN_IFACE_NETMASK_TEMP
				test_valid_inet_address "${WAN_IFACE_NETMASK_TEMP}"
				if [ "${VALID_INET_ADDRESS}" = "yes" ]
				then
					question_yes_no "\nYou have entered '${NRML}${WAN_IFACE_NETMASK_TEMP}${LCYN}' as the WAN interface netmask.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						WAN_IFACE_NETMASK=${WAN_IFACE_NETMASK_TEMP}
						break
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} Subnet mask is invalid!\n"
				fi
				sleep 4
			done

			# Set default router.
			while [ "${WAN_GATEWAY_IP}" = "" ]
			do
				echo -e ""
				readee -p "${LCYN}Enter the gateway (default router) IP address for this host: ${NRML}" WAN_GATEWAY_IP_TEMP
				test_valid_inet_address "${WAN_GATEWAY_IP_TEMP}"
				if [ "${VALID_INET_ADDRESS}" = "yes" ]
				then
					question_yes_no "\nYou have entered '${NRML}${WAN_GATEWAY_IP_TEMP}${LCYN}' as the gateway (default router).\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						WAN_GATEWAY_IP=${WAN_GATEWAY_IP_TEMP}
						break
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} Gateway (default router) IP address is invalid!\n"
				fi
				sleep 4
			done
	
			if [ "${USES_PPP}" = "yes" ]
			then
				sed -i "" "s|^ set ifaddr .*| set ifaddr ${WAN_IFACE_IP} ${WAN_GATEWAY_IP} ${WAN_IFACE_NETMASK} 0.0.0.0|" configs/${HOST_NAME}/etc/ppp/ppp.conf
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			else
				sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"inet ${WAN_IFACE_IP} netmask ${WAN_IFACE_NETMASK}\"/" configs/${HOST_NAME}/etc/rc.conf
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				sed -i "" "s/^#defaultrouter=\"\"/defaultrouter=\"${WAN_GATEWAY_IP}\"/" configs/${HOST_NAME}/etc/rc.conf
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			fi
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.ip_assignment "static"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.ip_address "${WAN_IFACE_IP}"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.ip_netmask "${WAN_IFACE_NETMASK}"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.ip_gateway "${WAN_GATEWAY_IP}"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		else
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.ip_assignment "dhcp"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			if [ "${USES_PPP}" = "no" ]
			then
				# WAN IP interface is pure ethernet and uses DHCP.
				sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"DHCP\"/" configs/${HOST_NAME}/etc/rc.conf
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			fi
		fi
		# END: if IS_WAN_IFACE_DHCP = no.

		sysrc -f configs/${HOST_NAME}/etc/rc.conf "gateway_enable=YES" > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.is_gateway_router true
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		if [ ${ERROR_COUNT} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst configuring the WAN interface IP!\n"
			undo_init_host
			return 2
		fi

	fi
	# END: configure WAN interface.


	# Configure LAN interface.
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		REMAINING_NET_IFACES=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "${NET_IFACES_IGNORED}|^${WAN_NET_IFACE}" | cut -d: -f1`
		NUM_REMAINING_NET_IFACES=`echo ${REMAINING_NET_IFACES} | wc -w`
		if [ ${NUM_REMAINING_NET_IFACES} -lt 2 ]
		then
			LAN_NET_IFACE=${REMAINING_NET_IFACES}
			echo -e "\n\n${YELL}Using '${NRML}${LAN_NET_IFACE}${YELL}' as the LAN network interface,${NRML}"
			echo -e "${YELL}since it's all that's available.${NRML}\n"
		else
			SELECT_IFACE_PROMPT="Select the LAN network interface:"
			while [ "${LAN_NET_IFACE}" = "" ]
			do
				dialog --no-items --no-cancel --menu "${SELECT_IFACE_PROMPT}" 12 40 10 ${REMAINING_NET_IFACES} 2> ${DIALOG_OUT_FILE}
				LAN_NET_IFACE_TEMP=`cat ${DIALOG_OUT_FILE}`
				echo -e "\n"
				question_yes_no "\nYou have selected '${NRML}${LAN_NET_IFACE_TEMP}${LCYN}' as the LAN interface for this host.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					LAN_NET_IFACE="${LAN_NET_IFACE_TEMP}"
					break
				fi
				sleep 4
			done
		fi
	fi

	if [ "${SERVER_TYPE}" = "remote" ]
	then
		sysrc -f configs/${HOST_NAME}/etc/rc.conf cloned_interfaces+="${LAN_NET_IFACE}" > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.type "loopback"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	else
		${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.type "ethernet"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	sed -i "" "s/LAN_NET_IFACE/${LAN_NET_IFACE}/g" configs/${HOST_NAME}/etc/rc.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.lan.nic_id "${LAN_NET_IFACE}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.lan.id "${LAN_NET_IFACE}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	LAN_SUBNET_C="${SERVERS_LAN_SUBNET_C}"
	LAN_IFACE_NETMASK="${FDO_LAN_SUBNET_MASK}"

	if [ "${WAN_NET_IFACE}" != "NULL" ]
	then
		# ASSUME: this host is a remote or primary_local type server.
		LAN_IFACE_IP="${FDO_LAN_GATEWAY_IP}"
		sed -i "" "s/^#ifconfig_${LAN_NET_IFACE}=\"\"/ifconfig_${LAN_NET_IFACE}=\"inet ${LAN_IFACE_IP} netmask ${LAN_IFACE_NETMASK}\"/" configs/${HOST_NAME}/etc/rc.conf
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.lan.ip_assignment "static"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.lan.ip_address "${LAN_IFACE_IP}"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.lan.ip_netmask "${LAN_IFACE_NETMASK}"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		if [ "${USES_PPP}" = "yes" ]
		then
			sed -i "" "s/^ #nat/ nat/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			sed -i "" "s/LAN_SUBNET_C/${LAN_SUBNET_C}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi
	else
		# ASSUME: this host is an aux_local type server.
		question_yes_no "\nDo you want to use DHCP for the LAN interface?"
		IS_LAN_IFACE_DHCP=${ANSWER}
		if [ "${IS_LAN_IFACE_DHCP}" = "no" ]
		then
			# Set up static IP and netmask for LAN interface.
			SELECT_IP_LIST=""
			CURRENT_IP=${AUX_LOCAL_SERVER_IP_MIN}
			while [ ${CURRENT_IP} -le ${AUX_LOCAL_SERVER_IP_MAX} ]
			do
				SELECT_IP_LIST="${SELECT_IP_LIST} ${CURRENT_IP} ${LAN_SUBNET_C}.${CURRENT_IP}"
				CURRENT_IP=$(( ${CURRENT_IP} + 1 ))
			done

			while [ "${LAN_IFACE_IP}" = "" ]
			do
				dialog --no-cancel --menu "Select LAN interface IP:" 18 40 16 ${SELECT_IP_LIST} 2> ${DIALOG_OUT_FILE}
				IP_LAST_DIGIT=`cat ${DIALOG_OUT_FILE}`
				LAN_IFACE_IP_TEMP="${LAN_SUBNET_C}.${IP_LAST_DIGIT}"
				if [ "${LAN_IFACE_IP_TEMP}" = "" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} No IP address selected! Try again.\n"
					pause_prompt 8
				else
					echo -e "\n"
					question_yes_no "\nYou have selected '${NRML}${LAN_IFACE_IP_TEMP}${LCYN}' as the LAN interface IP address.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						LAN_IFACE_IP=${LAN_IFACE_IP_TEMP}
						break
					fi
				fi
				sleep 4
			done
			sed -i "" "s/^#ifconfig_${LAN_NET_IFACE}=\"\"/ifconfig_${LAN_NET_IFACE}=\"inet ${LAN_IFACE_IP} netmask ${LAN_IFACE_NETMASK}\"/" configs/${HOST_NAME}/etc/rc.conf
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.lan.ip_assignment "static"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.lan.ip_address "${LAN_IFACE_IP}"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.lan.ip_netmask "${LAN_IFACE_NETMASK}"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		else
			sed -i "" "s/^#ifconfig_${LAN_NET_IFACE}=\"\"/ifconfig_${LAN_NET_IFACE}=\"DHCP\"/" configs/${HOST_NAME}/etc/rc.conf
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.lan.ip_assignment "dhcp"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi
		# END: if IS_LAN_IFACE_DHCP = no.

		${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.is_gateway_router false
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	# END: if WAN_NET_IFACE != NULL.

	# Pre-configure jail.conf with network configuration.
	sed -i "" "s|JAILS_LAN_SUBNET_C|${JAILS_LAN_SUBNET_C}|g" configs/${HOST_NAME}/etc/jail.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sed -i "" "s|LAN_NET_IFACE|${LAN_NET_IFACE}|g" configs/${HOST_NAME}/etc/jail.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Update hostname.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "hostname=${HOST_NAME}.${DOMAIN_NAME}" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sed -i "" "s/FDO_LAN_IP/${LAN_IFACE_IP}/g" configs/${HOST_NAME}/etc/hosts
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sed -i "" "s/FDO_HOST_NAME/${HOST_NAME}/g" configs/${HOST_NAME}/etc/hosts
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sed -i "" "s/FDO_DOMAIN_NAME/${DOMAIN_NAME}/g" configs/${HOST_NAME}/etc/hosts
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	hostname ${HOST_NAME}.${DOMAIN_NAME}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst configuring the LAN interface!\n"
		undo_init_host
		return 2
	fi

	# END: configure LAN interface.


	# Configure firewall / NAT router.
	if [ "${WAN_NET_IFACE}" != "NULL" ] && [ "${USES_PPP}" = "no" ]
	then
		sed -i "" "s|WAN_NET_IFACE|${WAN_NET_IFACE}|g" configs/${HOST_NAME}/etc/pf.conf
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		sed -i "" "s|LAN_NET_IFACE|${LAN_NET_IFACE}|g" configs/${HOST_NAME}/etc/pf.conf
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		sysrc -f configs/${HOST_NAME}/etc/rc.conf "pf_enable=YES" > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		sysrc -f configs/${HOST_NAME}/etc/rc.conf "pflog_enable=YES" > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .network.interface.wan.pf_nat_enabled true
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Configure DNS resolution in a static, persistent resolv.conf file.
	sed -i "" "s|DOMAIN_NAME|${DOMAIN_NAME}|" configs/${HOST_NAME}/etc/resolv.conf.static
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Save server type to host config.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .general.server_type "${SERVER_TYPE}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst finalising the network configuration!\n"
		undo_init_host
		return 2
	fi

	# Ask if we want to continue past point of no return.
	question_yes_no "\nWe will now make permanent changes to the new host system,\nwould you like to continue?"
	if [ "${ANSWER}" = "no" ]
	then
		undo_init_host
		return 1
	fi

	#### POINT OF NO RETURN ####

	# Backup existing core system config files.
	for CONFIG_FILE in `find config-templates/init-host/ -type f -print | sed "s|^config-templates/init-host||"`
	do
		if [ -e "${CONFIG_FILE}" ]
		then
			backup_file ${CONFIG_FILE} init-host
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi
	done

	# Turn on compression on root pool if it's off.
	ROOT_POOL=`df -l / 2> /dev/null | tail -1 | cut -d/ -f1`
	if [ "${}" != "" ]
	then
		if [ `zfs get -H -o value compression ${ROOT_POOL}` = "off" ]
		then
			INIT_HOST_ROOT_POOL_COMPRESS_TURN_ON=true
			zfs set compression=on ${ROOT_POOL}
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi
	fi

	INIT_HOST_SYSTEM_MODIFIED=true

	# Remove any cloud provider init.
	if [ -e /usr/local/etc/rc.d/digitalocean ]
	then
		chmod -x /usr/local/etc/rc.d/digitalocean
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ -e /usr/local/etc/rc.d/digitaloceanpre ]
	then
		chmod -x /usr/local/etc/rc.d/digitaloceanpre
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Install init-host configs to the system so that FDO user has a useful profile.
	install_file_tree configs/${HOST_NAME} /
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst preparing the host configuration!\n"
		undo_init_host
		return 2
	fi

	# Set password for toor user.
	echo -e "\n${YELL}Next we need to set a password for the toor user (interactive root shell${NRML}"
	echo -e "${YELL}account). This can be the same as the root user password.${NRML}"
	echo -e "${LCYN}"
	passwd toor
	echo -e "${NRML}"

	INIT_HOST_TOOR_PASSWORD_CHANGED=true

	# Set login shell for toor user.
	chsh -s ${LOGIN_SHELL} toor > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to change the shell for the user '${ORNG}toor${NRML}'!\n"
		undo_init_host
		return 2
	fi

	INIT_HOST_TOOR_SHELL_CHANGED=true

	# Add arbitrary ssh login user.
	echo -e "\n${YELL}Next we will add an arbitrary user so that we can login via SSH.${NRML}"
	echo -e "${YELL}It's recommended NOT to use an easy to guess username like admin or your own${NRML}"
	echo -e "${YELL}name.${NRML}"

	# Get valid login name.
	ARBITRARY_USERNAME=""
	while [ "${ARBITRARY_USERNAME}" = "" ]
	do
		echo -e ""
		readee -p "${LCYN}Enter login account username: ${NRML}" ARBITRARY_USERNAME_TEMP

		# Check that the username only contains letters, numbers, periods, underscores and hyphens with a minimum of 3 characters.
		TEST=`echo "${ARBITRARY_USERNAME_TEMP}" | sed -r "s/^[a-z0-9][a-z0-9\.\_\-]+[a-z0-9]//" | wc -L`
		if [ ${TEST} -ne 0 ] || [ "${ARBITRARY_USERNAME_TEMP}" = "" ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The username can not be '${ORNG}${ARBITRARY_USERNAME_TEMP}${NRML}'."
			echo -e "       It must be at least three characters and only contain lower case"
			echo -e "       letters, numbers, periods, underscores and hyphens.\n"
		elif [ `cat /etc/passwd | cut -d: -f1 | egrep "^${ARBITRARY_USERNAME_TEMP}$" | wc -l` -lt 1 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The username '${ORNG}${ARBITRARY_USERNAME_TEMP}${NRML}' already exists on this host.\n"
		else
			question_yes_no "\nYou have entered '${NRML}${ARBITRARY_USERNAME_TEMP}${LCYN}' as the login account username.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				ARBITRARY_USERNAME=${ARBITRARY_USERNAME_TEMP}
				break
			fi
		fi
		sleep 4
	done

	# Add arbitrary user to the system.
	pw useradd ${ARBITRARY_USERNAME} -m -s ${LOGIN_SHELL} -c "FDo login user" -G "operator wheel"
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to add the arbitrary user '${ORNG}${ARBITRARY_USERNAME}${NRML}'!\n"
		undo_init_host
		return 2
	fi

	INIT_HOST_ARBITRARY_USER_ADDED=true

	# Set a password for the arbitrary user.
	echo -e "\n${YELL}And now give this user account a password.${NRML}\n"
	echo -e "${LCYN}"
	passwd ${ARBITRARY_USERNAME}
	echo -e "${NRML}"

	echo -e "\n${LGRN}You should now be able to switch user from ${ARBITRARY_USERNAME}${NRML}"
	echo -e "${LGRN}to toor using the command:${NRML}"
	echo -e "${LBLU}root${NRML}\n"

	# Store ARBITRARY_USERNAME in the host config file.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .general.arbitrary_username "${ARBITRARY_USERNAME}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Timezone setup.
	echo -e ""
	question_yes "\nLet's perform the hosts timezone setup.\nCan we proceed?"
	tzsetup
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} System timezone setup via 'tzsetup' failed!\n"
		undo_init_host
		return 2
	fi

	INIT_HOST_TZSETUP_DONE=true

	TZ_AVAILABLE=`cat /usr/share/zoneinfo/zone.tab | egrep -v "^#" | awk '{print $3}' | sort`
	TZ=""
	while [ "${TZ}" = "" ]
	do
		dialog --no-cancel --no-items --menu "Select timezone for the hosts TZ environment variable:" 30 60 26 ${TZ_AVAILABLE} 2> ${DIALOG_OUT_FILE}
		TZ_TEMP=`cat ${DIALOG_OUT_FILE}`
		echo -e "\n"
		question_yes_no "\nYou have selected '${NRML}${TZ_TEMP}${LCYN}' for the TZ for this host.\nIs this correct?"
		if [ "${ANSWER}" = "yes" ]
		then
			TZ="${TZ_TEMP}"
			break
		fi
		sleep 4
	done
	sed -i "" "s|HOST_TIMEZONE|${TZ}|" configs/${HOST_NAME}/etc/profile
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sed -i "" "s|HOST_TIMEZONE|${TZ}|" configs/${HOST_NAME}/etc/csh.login
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set correct time/date from ntp.org.
	echo -e "\n${YELL}Setting correct time and date from ntp.org...${NRML}\n"
	service ntpd stop
	ntpdate pool.ntp.org
	service ntpd start

	# Locale setup.
	echo -e "\n"
	question_yes_no "\nWould you like to configure the locale for this host?"
	if [ "${ANSWER}" = "yes" ]
	then
		LOCALE_AVAILABLE=`ls -1 /usr/share/locale/ | egrep -v "^UTF-8" | sed "s|/$||" | sort`
		LOCALE=""
		while [ "${LOCALE}" = "" ]
		do
			dialog --no-cancel --no-items --menu "Select the locale for the host:" 30 60 26 ${LOCALE_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			LOCALE_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${LOCALE_TEMP}${LCYN}' for the locale for this host.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				LOCALE="${LOCALE_TEMP}"
				break
			fi
			sleep 4
		done
		LOCALE_CHARSET=$(echo ${LOCALE} | cut -d. -f2)
		sed -i "" "s|HOST_LOCALE|${LOCALE}|" configs/${HOST_NAME}/etc/profile
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		sed -i "" "s|HOST_CHARSET|${LOCALE_CHARSET}|" configs/${HOST_NAME}/etc/profile
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		sed -i "" "s|HOST_LOCALE|${LOCALE}|" configs/${HOST_NAME}/etc/csh.login
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		sed -i "" "s|HOST_CHARSET|${LOCALE_CHARSET}|" configs/${HOST_NAME}/etc/csh.login
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	else
		sed -i "" "s|\(^.*HOST_LOCALE.*\)|#\1|" configs/${HOST_NAME}/etc/profile
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		sed -i "" "s|\(^.*HOST_CHARSET.*\)|#\1|" configs/${HOST_NAME}/etc/profile
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		sed -i "" "s|\(^.*HOST_LOCALE.*\)|#\1|" configs/${HOST_NAME}/etc/csh.login
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		sed -i "" "s|\(^.*HOST_CHARSET.*\)|#\1|" configs/${HOST_NAME}/etc/csh.login
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong during the host configuration!\n"
		undo_init_host
		return 2
	fi

	# Add host system compat level and init marker to host config file.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .general.host_system_compat ${LATEST_HOST_SYS_COMPAT}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	#### CONFIG PROFILE FINISHED ####

	# Install scripts to the system.
	install_scripts /
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install final init-host configs to the system.
	install_file_tree configs/${HOST_NAME} /
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Create ssl certs directory.
	mkdir -p /usr/local/etc/ssl/certs
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# If not using DHCP, symlink resolv.conf.static to resolv.conf.
	if [ "${IS_PRIMARY_IFACE_DHCP}" = "no" ] || [ "${USES_PPP}" = "yes" ]
	then
		if [ -e "/etc/resolv.conf" ]
		then
			backup_file /etc/resolv.conf init-host
			rm /etc/resolv.conf
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi
		ln -s /etc/resolv.conf.static /etc/resolv.conf
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Remove the .gitignore from the local repo configs directory (if it exists).
	git rm configs/.gitignore 2> /dev/null
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst finalising the host configuration!\n"
		undo_init_host
		return 2
	fi

	# Commit this hosts config to the local repo.
	echo -e "\n${YELL}Committing this hosts config to the local repo...${NRML}\n"
	git add configs/${HOST_NAME}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	git commit -m "Adding new host; ${HOST_NAME}."
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst commiting changes to the configs repo!\n"
		undo_init_host
		return 2
	fi

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to the private remote repo...${NRML}\n"
		git_push origin master
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
			echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished setting up the new host:${NRML}"
	echo -e "${ORNG}${HOST_NAME}${NRML}.\n\n"
	question_yes_no "Would you like to reboot now for new settings to take full effect?\n[RECOMMENDED]"
	echo -e "\n"
	if [ "${ANSWER}" = "yes" ]
	then
		reboot
	fi

	return 0
}

patch_host()
{

	PATCH_HOST_NEEDS_REBOOT="no"

	echo -e "\n${YELL}We are now going to perform a '${LBLU}freebsd-update fetch${NRML}' operation.${NRML}"
	echo -e "${YELL}It may take a while...${NRML}\n"

	NOW=`date "+%Y-%m-%d_%H-%M-%S"`
	PAGER=cat freebsd-update fetch > /tmp/fdo-freebsd-update-output.host.fetch.${NOW}
	if [ ${?} -ne 0 ]
	then
		tail -4 /tmp/fdo-freebsd-update-output.host.fetch.${NOW} | egrep "WARNING: FreeBSD .*-RELEASE-.* HAS PASSED ITS END-OF-LIFE DATE" > /dev/null
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The '${LBLU}freebsd-update fetch${NRML}' operation failed!"
			echo -e "       Check for network related issues.\n       Aborting.\n"
			return 1
		else
			question_yes_no "It seems you are on an unsupported version of FreeBSD.\nWould you like to continue?"
			if [ "${ANSWER}" = "no" ]
			then
				return 1
			fi
		fi
	fi

	cat /tmp/fdo-freebsd-update-output.host.fetch.${NOW} | tail -1 | grep "^No updates needed" > /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LGRN}This host does not need patches installed, it's already fully patched.${NRML}\n"
		return 0
	fi

	echo -e "\n${YELL}And now let's perform a '${NRML}freebsd-update install${YELL}' operation...${NRML}\n"

	PAGER=cat freebsd-update install > /tmp/fdo-freebsd-update-output.host.install.${NOW}
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The '${LBLU}freebsd-update install${NRML}' operation failed!"
		echo -e "       Check FDo documentation for help.\n       Aborting.\n"
		return 2
	fi

	echo -e "\n${LGRN}This host has been successfully patched!${NRML}\n"

	FREEBSD_INSTALLED_KERNEL_VERSION=`freebsd-version -k`
	FREEBSD_RUNNING_KERNEL_VERSION=`uname -v`
	if [ "${FREEBSD_RUNNING_KERNEL_VERSION}" != "${FREEBSD_INSTALLED_KERNEL_VERSION}" ]
	then
		PATCH_HOST_NEEDS_REBOOT="yes"
		echo -e "\n${ORNG}ATTENTION: Please reboot when appropriate to pick up changes in patched kernel.${NRML}\n"
	fi

	return 0
}

setup_vnc_desktop()
{

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo!"
		echo -e "       Please use the '${LBLU}init-host${NRML}' subcommand first.\n       Aborting.\n"
		return 1
	fi

	# Check for unsaved registered host config files.
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent > /dev/null 2>&1
	if [ ${?} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the '${LBLU}check-configs${NRML}' subcommand to see what's out-of-date."
		echo -e "       Please use the '${LBLU}update-config${NRML}' subcommand to keep the repo up-to-date.\n       Aborting.\n"
		return 1
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Update pkgng repositories.
	echo -e "\n${YELL}Next we need to update pkg (pkgng) repositories...${NRML}\n"
	pkg update
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to update pkg (pkgng) repositories.\n       Aborting.\n"
		return 1
	fi

	# Install desktop / vnc packages.
	echo -e "\n${YELL}Next we need to install some required packages...${NRML}\n"
	pause_prompt 8
	pkg update -f
	pkg install -y ${VNC_DESKTOP_PACKAGES}
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to install required packages.\n       Aborting.\n"
		return 1
	fi

	ARBITRARY_USERNAME=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .general.arbitrary_username`
	if [ ${?} -ne 0 ] || [ "${ARBITRARY_USERNAME}" = "null" ] || [ "${ARBITRARY_USERNAME}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} There was a problem retrieving the arbitrary username for this host!\n"
		return 2
	fi

	# Copy setup-vnc-desktop template configs to this hosts' repo profile.
	install_file_tree config-templates/setup-vnc-desktop configs/${HOST_NAME}/

	# Rename ARBITRARY_USERNAME home folder in host config profile.
	if [ -d configs/${HOST_NAME}/home/${ARBITRARY_USERNAME} ]
	then
		mv configs/${HOST_NAME}/home/ARBITRARY_USERNAME/* configs/${HOST_NAME}/home/ARBITRARY_USERNAME/.[!.]* configs/${HOST_NAME}/home/${ARBITRARY_USERNAME}/
	else
		mv configs/${HOST_NAME}/home/ARBITRARY_USERNAME configs/${HOST_NAME}/home/${ARBITRARY_USERNAME}
	fi

	# Enable DBUS in rc.conf.
	sed -i "" "s/dbus_enable=\"NO\"/dbus_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf

	# Substitute FDo username in rc.local and rc.shutdown.local.
	sed -i "" "s|ARBITRARY_USERNAME|${ARBITRARY_USERNAME}|" configs/${HOST_NAME}/etc/rc.local
	sed -i "" "s|ARBITRARY_USERNAME|${ARBITRARY_USERNAME}|" configs/${HOST_NAME}/etc/rc.shutdown.local

	# Uncomment VNC related lines in rc.local and rc.shutdown.local.
	sed -i "" "s/^#FDO_VNC_DESKTOP#//" configs/${HOST_NAME}/etc/rc.local
	sed -i "" "s/^#FDO_VNC_DESKTOP#//" configs/${HOST_NAME}/etc/rc.shutdown.local

	# Install host configs to the system.
	install_file_tree configs/${HOST_NAME} /

	# Change ownership of the ARBITRARY_USERNAME home folder.
	chown -R ${ARBITRARY_USERNAME}:${ARBITRARY_USERNAME} /home/${ARBITRARY_USERNAME}

	# Start dbus.
	service dbus start

	echo -e "\n${YELL}The next prompt will ask for the VNC session password...${NRML}\n"
	pause_prompt 8

	# Run vncserver for the first time, will prompt for vnc passwords.
	sh /etc/rc.local

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	pause_prompt 8
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'setup-vnc-desktop'; ${HOST_NAME}."

	pause_prompt 8

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
		git_push origin master
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
			echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
		fi
	fi

	# Get the LAN interface for this host.
	CONFIG_LAN_NET_IFACE=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .network.interface.lan.id`
	if [ ${?} -ne 0 ] || [ "${CONFIG_LAN_NET_IFACE}" = "null" ] || [ "${CONFIG_LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} Failed to get the LAN interface id from the host config file!\n"
		return 2
	fi
	LAN_NET_IFACE=""
	HOST_LAN_IP_ADDRESSES=""
	NET_IFACES=`ifconfig -l`
	for IFACE in ${NET_IFACES}
	do
		if [ "${IFACE}" = "${CONFIG_LAN_NET_IFACE}" ]
		then
			HOST_LAN_IP_ADDRESSES=`ifconfig ${IFACE} | egrep "inet.*netmask" | awk '{print $2}' | egrep "${SERVERS_LAN_SUBNET_C}." | sort`
			if [ "${HOST_LAN_IP_ADDRESSES}" != "" ]
			then
				LAN_NET_IFACE="${IFACE}"
			fi
		fi
	done

	# Get the LAN IP address of this host.
	for IP_ADDRESS in ${HOST_LAN_IP_ADDRESSES}
	do
		# Let's ASSUME that the first and lowest (numerically) IP is the primary LAN IP.
		HOST_LAN_IP="${IP_ADDRESS}"
		break
	done

	# Get the default route IP for accessing this host from outside the LAN.
	DEFAULT_ROUTE_IP=`route -nv get 1 | tail -1 | awk '{print $5}'`

	# Get the default route IP for accessing this host from outside the LAN.
	FULL_HOST_NAME=`hostname -f`

	echo -e "\n${LGRN}Congratulations! We have now finished setting up a VNC accessible desktop.${NRML}\n"
	echo -e "${YELL}To access the VNC session, use a VNC Viewer (e.g. TigerVNC or SSVNC) with SSH${NRML}"
	echo -e "${YELL}enabled and one of the following URIs:${NRML}"
	echo -e "Remotely:"
	echo -e "${LGRN}${ARBITRARY_USERNAME}@${FULL_HOST_NAME}:10${NRML}"
	echo -e "${LGRN}${ARBITRARY_USERNAME}@${DEFAULT_ROUTE_IP}:10${NRML}"
	if [ "${LAN_NET_IFACE}" != "" ]
	then
		echo -e "Locally:"
		echo -e "${LGRN}${ARBITRARY_USERNAME}@${HOST_NAME}:10${NRML}"
		echo -e "${LGRN}${ARBITRARY_USERNAME}@${HOST_LAN_IP}:10${NRML}\n\n"
	fi

	return 0
}

undo_init_hotdesk ()
{

	ERROR_COUNT=0

	# Stop any previously stopped services.
	if [ ${INIT_HOTDESK_YPBIND_START} = true ]
	then
		service ypbind stop > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_HOTDESK_YPSERV_START} = true ]
	then
		service ypserv stop > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_HOTDESK_NFSD_START} = true ]
	then
		service nfsd stop > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_HOTDESK_MOUNTD_START} = true ]
	then
		service mountd stop > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_HOTDESK_LOCKD_START} = true ]
	then
		service lockd stop > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_HOTDESK_RPCBIND_START} = true ]
	then
		service rpcbind stop > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Undo host system modifications.
	if [ ${INIT_HOTDESK_MODIFIED} = true ]
	then
		# Roll back local repo to last good commit (!!!DANGEROUS!!!).
		if [ "${COMMIT_BEFORE_INIT_HOTDESK}" != "" ]
		then
			git reset --hard ${COMMIT_BEFORE_INIT_HOTDESK}
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi

		# Install back old host configs.
		install_file_tree configs/${HOST_NAME} /
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		# Restore any backed up system files.
		if [ "${ETC_EXPORTS_BACKUP_FILE}" != "" ]
		then
			mv "${ETC_EXPORTS_BACKUP_FILE}" "/etc/exports"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi
		if [ "${VAR_YP_MAKEFILE_BACKUP_FILE}" != "" ]
		then
			mv "${VAR_YP_MAKEFILE_BACKUP_FILE}" "/var/yp/Makefile"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi
		if [ "${VAR_YP_MASTER_PASSWD_BACKUP_FILE}" != "" ]
		then
			mv "${VAR_YP_MASTER_PASSWD_BACKUP_FILE}" "/var/yp/master.passwd"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi

	fi

	# Reload any previously reloaded services.
	if [ ${INIT_HOTDESK_YPBIND_RESTART} = true ]
	then
		service ypbind restart > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_HOTDESK_YPSERV_RESTART} = true ]
	then
		service ypserv restart > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_HOTDESK_MOUNTD_RELOAD} = true ]
	then
		service mountd reload > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Remove and additonally created groups.
	if [ ${INIT_HOTDESK_ADD_USERS_GROUP} = true ]
	then
		pw group del users > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Destroy any created filesystems.
	if [ ${INIT_HOTDESK_FILESYSTEMS_CREATED} = true ]
	then
		# Destroy the hotdesk base filesystem and any children.
		zfs destroy -rf ${HOTDESK_POOL_NAME}/${HOTDESK_ROOT_FS} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} There was at least one unexpected error undoing init-hotdesk!\n"
		return 2
	fi

	echo -e "\nAborting.\n"
	return 0
}

init_hotdesk ()
{

	INIT_HOTDESK_MODIFIED=false
	INIT_HOTDESK_FILESYSTEMS_CREATED=false
	INIT_HOTDESK_ADD_USERS_GROUP=false
	INIT_HOTDESK_RPCBIND_START=false
	INIT_HOTDESK_LOCKD_START=false
	INIT_HOTDESK_MOUNTD_START=false
	INIT_HOTDESK_MOUNTD_RELOAD=false
	INIT_HOTDESK_NFSD_START=false
	INIT_HOTDESK_YPBIND_START=false
	INIT_HOTDESK_YPBIND_RESTART=false
	INIT_HOTDESK_YPSERV_START=false
	INIT_HOTDESK_YPSERV_RESTART=false

	trap 'undo_init_hotdesk exit 3' HUP INT QUIT KILL TERM

	# Save git commit reference so we can roll back changes later.
	COMMIT_BEFORE_INIT_HOTDESK=`git log --format=format:%H -1`

	ERROR_COUNT=0

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the '${LBLU}init-host${NRML}' subcommand first.\n       Aborting.\n"
		return 1
	fi

	# Check for unsaved registered host config files.
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent > /dev/null 2>&1
	if [ ${?} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the '${LBLU}check-configs${NRML}' subcommand to see what's out-of-date."
		echo -e "       Please use the '${LBLU}update-config${NRML}' subcommand to keep the repo up-to-date.\n       Aborting.\n"
		return 1
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Check that the host.conf file is accessible.
	TEST_CONTENTS=`${UCL_CMD} get -u -f ${HOST_CONF_PATH} .general 2>&1`
	if [ ${?} -ne 0 ] || [ "${TEST_CONTENTS}" = "null" ] || [ "${TEST_CONTENTS}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to access the config file '${HOST_CONF_PATH}'!\n       Aborting.\n"
		return 2
	fi

	# Check that the hotdesk subsystem is not already initialised.
	HOTDESK_SUBSYS_COMPAT=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .subsystems.hotdesk_compat`
	if [ ${?} -eq 0 ] && [ "${HOTDESK_SUBSYS_COMPAT}" != "null" ] && [ "${HOTDESK_SUBSYS_COMPAT}" != "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the hotdesk subsystem is already initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} dismantle-hotdesk${NRML}\n       Aborting.\n"
		return 1
	fi

	# Get pool name to use for hotdesk users' home folders.
	HOTDESK_POOL_NAME=""
	POOLS_AVAILABLE=`zpool list -H -o name`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n       Aborting.\n"
		return 1
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		HOTDESK_POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${HOTDESK_POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool for hotdesk user home folders:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			HOTDESK_POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${HOTDESK_POOL_NAME_TEMP}${LCYN}' to store the hotdesk users home folders.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				HOTDESK_POOL_NAME="${HOTDESK_POOL_NAME_TEMP}"
				break
			fi
			sleep 4
		done
	fi

	# Test for existing hotdesk filesystems and prompt how to proceed.
	HOTDESK_FILESYSTEM_EXISTS="no"
	zfs list -H ${HOTDESK_POOL_NAME}/${HOTDESK_ROOT_FS} > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The ZFS filesystem '${ORNG}${HOTDESK_POOL_NAME}/${HOTDESK_ROOT_FS}${NRML}' already exists!\n"
		question_yes_no "\nIt seems as though '${NRML}init-hotdesk${LCYN}' has already been applied to this host.\nWould you like to proceed?"
		if [ "${ANSWER}" = "yes" ]
		then
			# Ask whether to purge, archive or reuse existing hotdesk base filesystems.
			question_purge_archive_reuse "\nWould you like to purge, archive or reuse the existing hotdesk base filesystem\nand all it's children filesystems? [CAUTION]"
			if [ "${ANSWER}" = "purge" ]
			then
				zfs destroy -Rf ${HOTDESK_POOL_NAME}/${HOTDESK_ROOT_FS}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			elif [ "${ANSWER}" = "archive" ]
			then
				NOW=`date "+%Y-%m-%d_%H-%M-%S"`
				zfs rename -f ${HOTDESK_POOL_NAME}/${HOTDESK_ROOT_FS} ${HOTDESK_POOL_NAME}/${HOTDESK_ROOT_FS}_renamed-by-init-hotdesk-${NOW}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			elif [ "${ANSWER}" = "reuse" ]
			then
				HOTDESK_FILESYSTEM_EXISTS="yes"
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} Unable to proceed.\n       Aborting.\n"
			return 1
		fi
	fi

	# Get the LAN interface of this host.
	CONFIG_LAN_NET_IFACE=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .network.interface.lan.id`
	if [ ${?} -ne 0 ] || [ "${CONFIG_LAN_NET_IFACE}" = "null" ] || [ "${CONFIG_LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the LAN interface id from the host config file!\n       Aborting.\n"
		return 2
	fi
	LAN_NET_IFACE=""
	HOST_LAN_IP_ADDRESSES=""
	NET_IFACES=`ifconfig -l`
	for IFACE in ${NET_IFACES}
	do
		if [ "${IFACE}" = "${CONFIG_LAN_NET_IFACE}" ]
		then
			HOST_LAN_IP_ADDRESSES=`ifconfig ${IFACE} | egrep "inet.*netmask" | awk '{print $2}' | egrep "${SERVERS_LAN_SUBNET_C}." | sort`
			if [ "${HOST_LAN_IP_ADDRESSES}" != "" ]
			then
				LAN_NET_IFACE="${IFACE}"
			fi
		fi
	done

	# Exit if the LAN subnet interface was not found.
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The LAN interface '${ORNG}${CONFIG_LAN_NET_IFACE}${NRML}' does not provide a valid '${ORNG}${SERVERS_LAN_SUBNET_C}.*${NRML}' subnet!\n       Aborting.\n"
		return 1
	fi

	# Get IP to use for NIS service.
	NIS_HOST_IP=""
	NUM_HOST_LAN_IP=`echo ${HOST_LAN_IP_ADDRESSES} | wc -w`
	if [ ${NUM_HOST_LAN_IP} -lt 2 ]
	then
		NIS_HOST_IP=${HOST_LAN_IP_ADDRESSES}
	else
		while [ "${NIS_HOST_IP}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select IP address to use for NIS server:" 12 60 10 ${HOST_LAN_IP_ADDRESSES} 2> ${DIALOG_OUT_FILE}
			NIS_HOST_IP_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${NIS_HOST_IP_TEMP}${LCYN}' to use for the NIS server.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				NIS_HOST_IP="${NIS_HOST_IP_TEMP}"
				break
			fi
			sleep 4
		done
	fi

	# Get the NIS domainname.
	NIS_DOMAIN_NAME=""
	while [ "${NIS_DOMAIN_NAME}" = "" ]
	do
		echo -e ""
		readee -p "${LCYN}Enter NIS domain name (need not be the same as the host): ${NRML}" NIS_DOMAIN_NAME_TEMP
		# Check that the nisdomainname is a valid domain name.
		test_valid_fqhn "${NIS_DOMAIN_NAME_TEMP}"
		if [ "${VALID_FQHN}" = "yes" ]
		then
			question_yes_no "\nYou have entered '${NRML}${NIS_DOMAIN_NAME_TEMP}${LCYN}' as the NIS domain name.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				NIS_DOMAIN_NAME="${NIS_DOMAIN_NAME_TEMP}"
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The NIS domain name can not be '${ORNG}${NIS_DOMAIN_NAME_TEMP}${NRML}'."
			echo -e "       It must only contain letters, numbers, periods and hyphens."
			echo -e "       It must not begin or end with a hyphen or a period.\n"
		fi
	done

	INIT_HOTDESK_MODIFIED=true

	# Set mountd service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "mountd_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set nfs_server service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "nfs_server_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set nis_client service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "nis_client_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set nis_server service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "nis_server_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set nis_yppasswdd service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "nis_yppasswdd_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set rpc_lockd service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "rpc_lockd_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set rpc_statd service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "rpc_statd_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set rpcbind service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "rpcbind_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set NIS domain name in rc.conf.
	sed -i "" "s/NIS_DOMAIN_NAME/${NIS_DOMAIN_NAME}/" configs/${HOST_NAME}/etc/rc.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set NIS host IP address in rc.conf.
	sed -i "" "s/NIS_HOST_IP/${NIS_HOST_IP}/" configs/${HOST_NAME}/etc/rc.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Add subsystems compat level and init marker to host config file.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .subsystems.hotdesk_compat ${LATEST_HOTDESK_SUBSYS_COMPAT}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Create or update the exports file in the local repo.
	touch /etc/exports > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	backup_file /etc/exports init-hotdesk
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	ETC_EXPORTS_BACKUP_FILE="${BACKUP_FILE_PATH}"
	cp /etc/exports configs/${HOST_NAME}/etc/exports
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	question_yes_no "\n\nWould you like to allow non-FreeBSD NIS clients to connect to this server?"
	if [ "${ANSWER}" = "yes" ]
	then
		backup_file /var/yp/Makefile init-hotdesk
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		VAR_YP_MAKEFILE_BACKUP_FILE="${BACKUP_FILE_PATH}"

		sed -i "" "s/^#UNSECURE/UNSECURE/" /var/yp/Makefile
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Create or update the NIS master password file.
	touch /var/yp/master.passwd > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	backup_file /var/yp/master.passwd init-hotdesk
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	VAR_YP_MASTER_PASSWD_BACKUP_FILE="${BACKUP_FILE_PATH}"
	chmod 600 /var/yp/master.passwd > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install host configs to the system.
	install_file_tree configs/${HOST_NAME} /
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst preparing the hotdesk NIS/NFS services!\n"
		undo_init_hotdesk
		return 2
	fi

	question_yes "\nNow we need to restart the network to register the NIS domain name.\nCan we proceed?"

	# Restart network stack to pick up changes in rc.conf. 
	echo -e "\n${YELL}Restarting network stack...${NRML}\n"
	/etc/netstart > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	sleep 16

	# Start / reload the NFS services.
	echo -e "\n${YELL}Starting NFS services...${NRML}\n"
	service rpcbind status > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_HOTDESK_RPCBIND_START=true
		service rpcbind start
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	service lockd status > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_HOTDESK_LOCKD_START=true
		service lockd start
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	service mountd status > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_HOTDESK_MOUNTD_START=true
		service mountd start
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	else
		INIT_HOTDESK_MOUNTD_RELOAD=true
		service mountd reload
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	service nfsd status > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_HOTDESK_NFSD_START=true
		service nfsd start
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst (re)starting network and NFS services!\n"
		undo_init_hotdesk
		return 2
	fi

	echo -e "\n${YELL}Now we will initialise the NIS maps. Follow the steps below:${NRML}\n"
	echo -e "${YELL}1.) Enter '${NRML}y${YELL}' when prompted to '${NRML}... quit on non fatal errors${YELL}'.${NRML}"
	echo -e "${YELL}2.) Enter '${NRML}y${YELL}' if prompted to '${NRML}... destroy the existing\n    /var/yp/${NIS_DOMAIN_NAME}${YELL}'.${NRML}"
	echo -e "${YELL}3.) Press '${NRML}Ctrl${YELL}' and '${NRML}D${YELL}' keys together when prompted for '${NRML}next host to add${YELL}'.${NRML}"
	echo -e "${YELL}4.) Enter '${NRML}y${YELL}' when prompted to confirm NIS server list is correct.${NRML}\n"

	ypinit -m ${NIS_DOMAIN_NAME}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The NIS maps failed to initialise."
		echo -e "       Consult FDo documentation for help.\n       Aborting.\n"
		undo_init_hotdesk
		return 2
	fi

	# Start / restart the NIS services.
	service ypserv status > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_HOTDESK_YPSERV_START=true
		service ypserv start
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	else
		INIT_HOTDESK_YPSERV_RESTART=true
		service ypserv restart
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	service ypbind status > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_HOTDESK_YPBIND_START=true
		service ypbind start
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	else
		INIT_HOTDESK_YPBIND_RESTART=true
		service ypbind restart
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst (re)starting NIS services!\n"
		undo_init_hotdesk
		return 2
	fi

	# Let's add a group called users to support some Linux distribution based workstation / client.
	pw group show users > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_HOTDESK_ADD_USERS_GROUP=true
		pw group add users -g 100 > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} An unexpected error occurred whilst adding a 'users' group!\n"
		undo_init_hotdesk
		return 2
	fi

	# Create the ZFS filesystem for the root of hotdesk users home folders.
	if [ "${HOTDESK_FILESYSTEM_EXISTS}" = "no" ]
	then
		echo -e "\n${YELL}Creating ZFS filesystems for hotdesk home directories...${NRML}\n"
		INIT_HOTDESK_FILESYSTEMS_CREATED=true
		zfs create -o mountpoint=${HOTDESK_ROOT_MP} ${HOTDESK_POOL_NAME}/${HOTDESK_ROOT_FS}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} An unexpected error occurred whilst creating hotdesk filesystems!\n"
		undo_init_hotdesk
		return 2
	fi

	# Copy init-hotdesk template configs to this hosts' repo profile.
	install_file_tree config-templates/init-hotdesk configs/${HOST_NAME}/
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	echo -e ""

	# Store subsystem configuration details.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .storage.hotdesk_pool "${HOTDESK_POOL_NAME}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${HOTDESK_CONF_PATH} .general.root_filesystem "${HOTDESK_ROOT_FS}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${HOTDESK_CONF_PATH} .general.root_mountpoint "${HOTDESK_ROOT_MP}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst storing the hotdesk configuration!\n"
		undo_hotdesk
		return 2
	fi

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	git commit -m "Updating host after 'init-hotdesk'; ${HOST_NAME}."
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst commiting changes to the configs repo!\n"
		undo_init_hotdesk
		return 2
	fi

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
		git_push origin master
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
			echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
		fi
	fi

	# Cleanup backup files.
	rm "${ETC_EXPORTS_BACKUP_FILE}" > /dev/null 2>&1
	rm "${VAR_YP_MAKEFILE_BACKUP_FILE}" > /dev/null 2>&1
	rm "${VAR_YP_MASTER_PASSWD_BACKUP_FILE}" > /dev/null 2>&1

	echo -e "\n${LGRN}Congratulations! We have now finished setting up NIS/NFS hotdesking.${NRML}\n"
	echo -e "\n${YELL}To register hotdesk users on this server; use the command:${NRML}"
	echo -e "${LBLU}fdo-hotdesk-add-user${NRML}\n"

	echo -e "${YELL}Hotdesk home directory pool name:${NRML}   ${HOTDESK_POOL_NAME}"
	echo -e "${YELL}Hotdesk home directory filesystem:${NRML}  ${HOTDESK_POOL_NAME}/${HOTDESK_ROOT_FS}"
	echo -e "${YELL}Hotdesk home directory path:${NRML}        ${HOTDESK_ROOT_MP}"
	echo -e "${YELL}NIS domain name:${NRML}                    ${NIS_DOMAIN_NAME}"
	echo -e "${YELL}NIS server IP address:${NRML}              ${NIS_HOST_IP}\n"

	return 0
}

undo_init_sshfs_daemon ()
{

	ERROR_COUNT=0

	# Undo host system modifications.
	if [ ${INIT_SSHFS_DAEMON_MODIFIED} = true ]
	then
		service sshfsd onestatus  > /dev/null 2>&1
		if [ ${?} -eq 0 ]
		then
			service sshfsd onestop
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi

		# Roll back local repo to last good commit (!!!DANGEROUS!!!).
		if [ "${COMMIT_BEFORE_INIT_SSHFS_DAEMON}" != "" ]
		then
			git reset --hard ${COMMIT_BEFORE_INIT_SSHFS_DAEMON}
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi

		# Install back old host configs.
		install_file_tree configs/${HOST_NAME} /
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Unload any loaded kernel modules.
	if [ ${INIT_VMS_TAP_LOAD} = true ]
	then
		kldunload if_tap
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} There was at least one unexpected error undoing the init-sshfs-daemon process!\n"
		return 2
	fi

	echo -e "\nAborting.\n"
	return 0
}

init_sshfs_daemon ()
{

	INIT_SSHFS_FUSE_LOAD=false
	INIT_SSHFS_DAEMON_MODIFIED=false

	trap 'undo_init_sshfs_daemon ; exit 3' HUP INT QUIT KILL TERM

	# Save git commit reference so we can roll back changes later.
	COMMIT_BEFORE_INIT_SSHFS_DAEMON=`git log --format=format:%H -1`

	ERROR_COUNT=0

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the '${LBLU}init-host${NRML}' subcommand first.\n       Aborting.\n"
		return 1
	fi

	# Check for unsaved registered host config files.
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent > /dev/null 2>&1
	if [ ${?} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the '${LBLU}check-configs${NRML}' subcommand to see what's out-of-date."
		echo -e "       Please use the '${LBLU}update-config${NRML}' subcommand to keep the repo up-to-date.\n       Aborting.\n"
		return 1
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Check that the host.conf file is accessible.
	TEST_CONTENTS=`${UCL_CMD} get -u -f ${HOST_CONF_PATH} .general 2>&1`
	if [ ${?} -ne 0 ] || [ "${TEST_CONTENTS}" = "null" ] || [ "${TEST_CONTENTS}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to access the config file '${HOST_CONF_PATH}'!\n       Aborting.\n"
		return 2
	fi

	# Check that the sshfs-daemon subsystem is not already initialised.
	SSHFSD_SUBSYS_COMPAT=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .subsystems.sshfs-daemon_compat`
	if [ ${?} -eq 0 ] && [ "${SSHFSD_SUBSYS_COMPAT}" != "null" ] && [ "${SSHFSD_SUBSYS_COMPAT}" != "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the SSHFS-daemon subsystem is already initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} dismantle-sshfs-daemon${NRML}\n       Aborting.\n"
		return 1
	fi

	# Install required packages.
	echo -e "\n${YELL}First we need to install some required packages...${NRML}\n"
	pause_prompt 8
	pkg update -f
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	pkg install -y ${SSHFS_DAEMON_PACKAGES}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} A problem was encountered whilst installing required packages!\n"
		undo_init_sshfs_daemon
		return 2
	fi

	# Load required kernel modules.
	kldstat | grep fuse.ko > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_SSHFS_FUSE_LOAD=true
		kldload fuse 2> /dev/null
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} A problem was encountered whilst loading required kernel modules.\n"
		undo_init_sshfs_daemon
		return 2
	fi

	INIT_SSHFS_DAEMON_MODIFIED=true

	# Set FUSE support to load on boot.
	sysrc -f configs/${HOST_NAME}/boot/loader.conf "fuse_load=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set sshfsd service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "sshfsd_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Copy init-sshfs-daemon template configs to this hosts' repo profile.
	install_file_tree config-templates/init-sshfs-daemon configs/${HOST_NAME}/
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Add subsystems compat level and init marker to host config file.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .subsystems.sshfs-daemon_compat ${LATEST_SSHFSD_SUBSYS_COMPAT}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install host configs to the system.
	install_file_tree configs/${HOST_NAME} /
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst configuring the sshfs daemon!\n"
		undo_init_sshfs_daemon
		return 2
	fi

	echo -e "\n"

	# Start sshfsd service for the first time.
	service sshfsd onestart
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} Something went wrong starting the 'sshfsd' service!"
	fi

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	git commit -m "Updating host after 'init-sshfs-daemon'; ${HOST_NAME}."
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst commiting changes to the configs repo!\n"
		undo_init_sshfs_daemon
		return 2
	fi

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
		git_push origin master
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
			echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished initialising the sshfs daemon subsystem.${NRML}\n"
	echo -e "\n${YELL}To create a sshfs connection, use the command:${NRML}"
	echo -e "${LBLU}fdo-sshfs-add-connection${NRML}\n"

	return 0
}

undo_init_jails ()
{

	ERROR_COUNT=0

	service jail status | egrep "^ template " > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		# Stop the template jail.
		echo -e "\n${YELL}Stopping the template jail...\n"
		service jail onestop template > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	else
		echo -e "\n${YELL}The template jail appears to be stopped.\n"
	fi

	# Wait for I/O to settle.
	sleep 4

	# Check if the jail did not stop or appears to be still running.
	jls | tail -n +2 | awk '{print $3}' | egrep "${JAIL_TO_REVERT}" > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		# Remove the jail and unmount nullfs mounted certificates directory.
		JAIL_ID_FILE=`ls -1 /var/run/jail_${JAIL_TO_REVERT}.id | head -1`
		JAIL_ID=`cat ${JAIL_ID_FILE}`
		jail -r ${JAIL_ID} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		umount -f /jls/${JAIL_TO_REVERT}/usr/local/etc/ssl/certs > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${INIT_JAILS_FILESYSTEMS_CREATED} = true ]
	then
		# Destroy the template jail filesystem.
		zfs destroy -rf ${JAILS_POOL_NAME}/jails > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${INIT_JAILS_HOST_MODIFIED} = true ]
	then
		# Roll back local repo to last good commit (!!!DANGEROUS!!!).
		if [ "${COMMIT_BEFORE_INIT_JAILS}" != "" ]
		then
			git reset --hard ${COMMIT_BEFORE_INIT_JAILS}
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi

		# Install back old host configs.
		install_file_tree configs/${HOST_NAME} /
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Remove base system tarballs now that they are no longer needed.
	rm /tmp/jail-base.txz > /dev/null 2>&1
	rm /tmp/jail-lib32.txz > /dev/null 2>&1
	rm /tmp/jail-src.txz > /dev/null 2>&1

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} There was at least one unexpected error undoing the init-jails process!\n"
		return 2
	fi

	echo -e "\nAborting.\n"
	return 0
}

init_jails ()
{

	INIT_JAILS_FILESYSTEMS_CREATED=false
	INIT_JAILS_HOST_MODIFIED=false

	trap 'undo_init_jails ; exit 3' HUP INT QUIT KILL TERM

	# Save git commit reference so we can roll back changes later.
	COMMIT_BEFORE_INIT_JAILS=`git log --format=format:%H -1`

	ERROR_COUNT=0

	get_enabled_nat_services

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the '${LBLU}init-host${NRML}' subcommand first.\n       Aborting.\n"
		return 1
	fi

	# Check for unsaved registered host config files.
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent > /dev/null 2>&1
	if [ ${?} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the '${LBLU}check-configs${NRML}' subcommand to see what's out-of-date."
		echo -e "       Please use the '${LBLU}update-config${NRML}' subcommand to keep the repo up-to-date.\n       Aborting.\n"
		return 1
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Check that the host.conf file is accessible.
	TEST_CONTENTS=`${UCL_CMD} get -u -f ${HOST_CONF_PATH} .general 2>&1`
	if [ ${?} -ne 0 ] || [ "${TEST_CONTENTS}" = "null" ] || [ "${TEST_CONTENTS}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to access the config file '${HOST_CONF_PATH}'!\n       Aborting.\n"
		return 2
	fi

	# Check that the jails subsystem is not already initialised.
	JAILS_SUBSYS_COMPAT=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .subsystems.jails_compat`
	if [ ${?} -eq 0 ] && [ "${JAILS_SUBSYS_COMPAT}" != "null" ] && [ "${JAILS_SUBSYS_COMPAT}" != "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the jails subsystem is already initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} dismantle-jails${NRML}\n       Aborting.\n"
		return 1
	fi

	# Get the LAN interface that the jails will run on.
	CONFIG_LAN_NET_IFACE=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .network.interface.lan.id`
	if [ ${?} -ne 0 ] || [ "${CONFIG_LAN_NET_IFACE}" = "null" ] || [ "${CONFIG_LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the LAN interface id from the host config file!\n       Aborting.\n"
		return 2
	fi
	LAN_NET_IFACE=""
	HOST_LAN_IP_ADDRESSES=""
	NET_IFACES=`ifconfig -l`
	for IFACE in ${NET_IFACES}
	do
		if [ "${IFACE}" = "${CONFIG_LAN_NET_IFACE}" ]
		then
			HOST_LAN_IP_ADDRESSES=`ifconfig ${IFACE} | egrep "inet.*netmask" | awk '{print $2}' | egrep "${SERVERS_LAN_SUBNET_C}." | sort`
			if [ "${HOST_LAN_IP_ADDRESSES}" != "" ]
			then
				LAN_NET_IFACE="${IFACE}"
			fi
		fi
	done

	# Exit if the LAN subnet interface was not found.
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The LAN interface '${ORNG}${CONFIG_LAN_NET_IFACE}${NRML}' does not provide a valid '${ORNG}${SERVERS_LAN_SUBNET_C}.*${NRML}' subnet!\n       Aborting.\n"
		return 1
	fi

	# Get pool name to use for base of jails.
	JAILS_POOL_NAME=""
	POOLS_AVAILABLE=`zpool list -H -o name`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n       Aborting.\n"
		return 1
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		JAILS_POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${JAILS_POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool to use for jails filesystems:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			JAILS_POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${JAILS_POOL_NAME_TEMP}${LCYN}' to store the service jails.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				JAILS_POOL_NAME="${JAILS_POOL_NAME_TEMP}"
				break
			fi
			sleep 4
		done
	fi

	# Test for existing jail base filesystem and prompt how to proceed.
	JAILS_FILESYSTEM_EXISTS="no"
	zfs list -H ${JAILS_POOL_NAME}/jails > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The ZFS filesystem '${ORNG}${JAILS_POOL_NAME}/jails${NRML}' already exists!\n"
		question_yes_no "\nIt seems as though '${NRML}init-jails${LCYN}' has already been applied to this host.\nWould you like to proceed?"
		if [ "${ANSWER}" = "yes" ]
		then
			# Ask whether to purge, archive or reuse exsiting jail base filesystem.
			question_purge_archive_reuse "\nWould you like to purge, archive or reuse the existing jail base filesystem\nand all it's children filesystems? [CAUTION]"
			if [ "${ANSWER}" = "purge" ]
			then
				zfs destroy -Rf ${JAILS_POOL_NAME}/jails
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			elif [ "${ANSWER}" = "archive" ]
			then
				NOW=`date "+%Y-%m-%d_%H-%M-%S"`
				zfs rename -f ${JAILS_POOL_NAME}/jails ${JAILS_POOL_NAME}/jails_renamed-by-init-jails-${NOW}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			elif [ "${ANSWER}" = "reuse" ]
			then
				JAILS_FILESYSTEM_EXISTS="yes"
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} Unable to proceed.\n       Aborting.\n"
			return 1
		fi
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} There was at least one unexpected error preparing 'init-jails'!\n"
		undo_init_jails
		return 2
	fi

	patch_host
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Updating of host to latest patch level failed.\n"
		undo_init_jails
		return 2
	fi

	# Get version strings.
	FREEBSD_VERSION_STRING=`freebsd-version`
	FREEBSD_VERSION=`freebsd-version | cut -d- -f1`
	FREEBSD_MAJOR_VERSION=`echo ${FREEBSD_VERSION} | cut -d. -f1`
	FREEBSD_CADENCE=`freebsd-version | cut -d- -f2`
	FREEBSD_PATCH_LEVEL=`freebsd-version | cut -d- -f3`

	# Download relevant base system tarballs.
	echo -e "\n${YELL}Downloading FreeBSD base system tarballs...${NRML}\n"
	fetch -o /tmp/jail-base.txz ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/${FREEBSD_VERSION}-${FREEBSD_CADENCE}/base.txz
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fetch -o /tmp/jail-lib32.txz ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/${FREEBSD_VERSION}-${FREEBSD_CADENCE}/lib32.txz
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fetch -o /tmp/jail-src.txz ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/${FREEBSD_VERSION}-${FREEBSD_CADENCE}/src.txz
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to download the base system tarballs.\n"
		undo_init_jails
		return 1
	fi

	# Create ZFS filesystems for service jail template.
	if [ "${JAILS_FILESYSTEM_EXISTS}" = "no" ]
	then
		INIT_JAILS_FILESYSTEMS_CREATED=true
		echo -e "\n${YELL}Creating ZFS filesystems for template jail...${NRML}\n"
		zfs create -o mountpoint=/jls ${JAILS_POOL_NAME}/jails
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	zfs list ${JAILS_POOL_NAME}/jails/template > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		zfs create ${JAILS_POOL_NAME}/jails/template
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Mount the filesystems if they are not already.
	zfs mount | egrep "^${JAILS_POOL_NAME}/jails " > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		zfs mount ${JAILS_POOL_NAME}/jails
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	zfs mount | egrep "^${JAILS_POOL_NAME}/jails/template "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${JAILS_POOL_NAME}/jails/template
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install base system tarballs into the template jail directory.
	echo -e "\n${YELL}Extracting FreeBSD base system tarballs into template jail...${NRML}\n"
	tar -JxC /jls/template/ -f /tmp/jail-base.txz
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	tar -JxC /jls/template/ -f /tmp/jail-lib32.txz
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	tar -JxC /jls/template/ -f /tmp/jail-src.txz
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Remove base system tarballs now that they are no longer needed.
	rm /tmp/jail-base.txz > /dev/null 2>&1
	rm /tmp/jail-lib32.txz > /dev/null 2>&1
	rm /tmp/jail-src.txz > /dev/null 2>&1

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst preparing the template jail filesystem!\n"
		undo_init_jails
		return 2
	fi

	INIT_JAILS_HOST_MODIFIED=true

	# Copy init-jails template configs to this hosts' repo profile.
	install_file_tree config-templates/init-jails configs/${HOST_NAME}/
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	echo -e ""

	# Set some basic configuration for the jail subsystem.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .storage.jails_pool "${JAILS_POOL_NAME}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sed -i "" "s/jail_enable=\"NO\"/jail_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sed -i "" "s/^#template/template/" configs/${HOST_NAME}/etc/jail.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Only run sshd on LAN host (not jail) IPs.
	for IP_ADDRESS in ${HOST_LAN_IP_ADDRESSES}
	do
		# Add port forwarding rules to pf and ppp config.
		IS_REPO_CONF="yes" PF_CONF_PATH="/${REPO_NAME}/configs/${HOST_NAME}/etc/pf.conf" fdo-pf-add-port-forward-rule host_sshd ${IP_ADDRESS} 22 none --non-interactive
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		IS_REPO_CONF="yes" PPP_CONF_PATH="/${REPO_NAME}/configs/${HOST_NAME}/etc/ppp/ppp.conf" fdo-ppp-add-port-forward-rule host_sshd ${IP_ADDRESS} 22 none --non-interactive
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		# Set this hosts sshd to only run on the primary LAN IP.
		sed -i "" "s/#ListenAddress .*/ListenAddress ${IP_ADDRESS}/" configs/${HOST_NAME}/etc/ssh/sshd_config
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		# Let's ASSUME that the first and lowest (numerically) IP is the primary LAN IP.
		break
	done

	# Install host configs to the system.
	install_file_tree configs/${HOST_NAME} /
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install jail_template configs to the template jail.
	install_file_tree config-templates/jail_template /jls/template/
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Create nullfs mountpoint for hosts ssl certs.
	mkdir -p /jls/template/usr/local/etc/ssl/certs
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Copy certain host specific config files to the template jail.
	HOST_CONFIG_FILES=`find config-templates/jail_template -type f | sed "s|^config-templates/jail_template/||"`
	for CONFIG_FILE in ${HOST_CONFIG_FILES}
	do
		FILE_CONTENTS=`cat config-templates/jail_template/${CONFIG_FILE}`
		if [ "${FILE_CONTENTS}" = "COPY_FROM_HOST" ]
		then
			cp /${CONFIG_FILE} /jls/template/${CONFIG_FILE}
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		elif [ "${FILE_CONTENTS}" = "COPY_STATIC_FROM_HOST" ]
		then
			STATIC_CONFIG_FILE="${CONFIG_FILE}.static"
			cp /${STATIC_CONFIG_FILE} /jls/template/${CONFIG_FILE}
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi
	done

	# Run tzsetup for the jail.
	tzsetup -s -C /jls/template `cat /var/db/zoneinfo` > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ "${IS_PPP_NAT_ENABLED}" = "YES" ]
	then
		# TODO: resolve why ppp can't reconnect on service restart.
		#service ppp restart > /dev/null 2>&1
		service ppp stop > /dev/null 2>&1
		sleep 4
		service ppp start > /dev/null 2>&1
		sleep 4
		service ppp start > /dev/null 2>&1
	fi
	if [ "${IS_PF_NAT_ENABLED}" = "YES" ]
	then
		service pf reload > /dev/null 2>&1
	fi
	service sshd reload > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	service jail start template > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst configuring the template jail!\n"
		undo_init_jails
		return 2
	fi

	NOW=`date "+%Y-%m-%d_%H-%M-%S"`
	echo -e "\n${YELL}Updating template jail to latest patch release...${NRML}\n"
	PAGER=cat freebsd-update -b /jls/template fetch > /tmp/fdo-freebsd-update.output.template-jail.fetch.${NOW}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	PAGER=cat freebsd-update -b /jls/template install > /tmp/fdo-freebsd-update.output.template-jail.install.${NOW}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	service jail restart template
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst updating the template jail base!\n"
		undo_init_jails
		return 2
	fi

	# Install essential packages into the template jail.
	echo -e "\n${YELL}Next we need to install some essential packages into the template jail.${NRML}\n"
	pause_prompt 8
	pkg -j template update -f
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	pkg -j template install -y ${ESSENTIAL_JAIL_PACKAGES}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst installing the template jail packages!\n"
		undo_init_jails
		return 2
	fi

	# Stop the template jail now that we're done making the template.
	service jail stop template
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Disable template jail from running again.
	sed -i "" "s/^template/#template/" configs/${HOST_NAME}/etc/jail.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Add subsystems compat level and init marker to host config file.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .subsystems.jails_compat ${LATEST_JAILS_SUBSYS_COMPAT}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install updated host configs to the system (after disabling template jail).
	install_file_tree configs/${HOST_NAME} /
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Take snapshot of the template for use in create-jail*.
	zfs snapshot ${JAILS_POOL_NAME}/jails/template@${FREEBSD_VERSION_STRING}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst finalising the template jail packages!\n"
		undo_init_jails
		return 2
	fi

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	git commit -m "Updating host after 'init-jails'; ${HOST_NAME}."
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst commiting changes to the configs repo!\n"
		undo_init_jails
		return 2
	fi

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
		git_push origin master
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
			echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished initialising the jails subsystem.${NRML}\n"
	echo -e "\n${YELL}To create jails, use the command:${NRML}"
	echo -e "${LBLU}${SCRIPT_NAME} create-jail${NRML}\n"

	return 0
}

start_jail_service ()
{
	# ${1} is jail name.
	# ${2} is service name.
	# ${3} may be --allow-restart.

	get_jail_id_from_name "${1}"

	echo -e "\n${YELL}Starting the service '${NRML}${2}${YELL}' in the jail '${NRML}${1}${YELL}'...${NRML}\n"

	jexec ${JAIL_ID} service "${2}" start > /dev/null 2>&1

	if [ ${?} -ne 0 ] && [ "${3}" = "--allow-restart" ]
	then
		jexec ${JAIL_ID} service "${2}" restart > /dev/null 2>&1
	fi

	if [ ${?} -ne 0 ]
	then
		echo -e "${ORNG}WARNING:${NRML} Failed to start service '${ORNG}${2}${NRML}' in jail '${ORNG}${1}${NRML}'!\n"
		return 2
	else
		echo -e "${YELL}INFO:${NRML} Successfully started service '${ORNG}${2}${NRML}' in jail '${ORNG}${1}${NRML}'!\n"
		return 0
	fi

}

find_jails_from_recipe_name ()
{
	FIND_RECIPE_NAME="${1}"
	FOUND_RECIPE_JAILS=""
	for TEST_JAIL_NAME in `ls -1 /jls | cut -d/ -f1`
	do
		if [ -f "/jls/${TEST_JAIL_NAME}${RECIPE_CONF_PATH}" ]
		then
			TEST_RECIPE_NAME=`${UCL_CMD} get -f /jls/${TEST_JAIL_NAME}${RECIPE_CONF_PATH} -q .general.jail_recipe`
			if [ "${TEST_RECIPE_NAME}" = "${FIND_RECIPE_NAME}" ]
			then
				if [ "${FOUND_RECIPE_JAILS}" = "" ]
				then
					FOUND_RECIPE_JAILS="${TEST_JAIL_NAME}"
				else
					FOUND_RECIPE_JAILS="${FOUND_RECIPE_JAILS} ${TEST_JAIL_NAME}"
				fi
			fi
		fi
	done

	return 0
}

# WARNING: Only for use by developers on a 'local' only repo.
# Only to be used on last created jail directly afterwards.
# It does a hard reset of the git repo.
revert_create_jail ()
{
	JAIL_TO_REVERT=${1}
	ERROR_COUNT=0

	# Sanity tests.
	JAILS_POOL_NAME=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .storage.jails_pool`
	if [ ${?} -ne 0 ] || [ "${JAILS_POOL_NAME}" = "null" ] || [ "${JAILS_POOL_NAME}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the jails pool name from the host config file!\n       Aborting.\n"
		return 2
	fi

	zfs list -H ${JAILS_POOL_NAME}/jails/${JAIL_TO_REVERT} > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The jail '${ORNG}${JAIL_TO_REVERT}${NRML}' does not seem to exist!\n       Aborting.\n"
		return 1
	fi

	# ASSUME: commit after create jail is not much use, since we can't remove a previous range
	# of commits using 'git revert' without creating conflicts that need manual intervention.
	COMMIT_BEFORE_CREATE_JAIL=`${UCL_CMD} get -f configs/${JAIL_TO_REVERT}@${HOST_NAME}${RECIPE_CONF_PATH} -q .general.git_commit_before_create_jail`
	if [ ${?} -ne 0 ] || [ "${COMMIT_BEFORE_CREATE_JAIL}" = "null" ]
	then
		COMMIT_BEFORE_CREATE_JAIL=""
	fi

	# Get list of affected jails (by recipe name).
	AFFECTED_JAIL_RECIPES=`${UCL_CMD} get -f configs/${JAIL_TO_REVERT}@${HOST_NAME}${RECIPE_CONF_PATH} -q .general.affected_recipe_jails`
	if [ ${?} -ne 0 ] || [ "${AFFECTED_JAIL_RECIPES}" = "null" ]
	then
		AFFECTED_JAIL_RECIPES=""
	fi

	echo -e "\n${YELL}Reverting create jail for '${NRML}${JAIL_TO_REVERT}${YELL}'...${NRML}\n"

	service jail status | egrep "^ ${JAIL_TO_REVERT} " > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		# Stop the jail.
		echo -e "\n${YELL}Stopping the jail '${JAIL_TO_REVERT}'...\n"
		service jail stop ${JAIL_TO_REVERT} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	else
		echo -e "\n${YELL}The jail '${JAIL_TO_REVERT}' appears to be stopped.\n"
	fi

	# Wait for I/O to settle.
	sleep 8

	# Check if the jail did not stop or appears to be still running.
	jls | tail -n +2 | awk '{print $3}' | egrep "${JAIL_TO_REVERT}" > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		# Remove the jail and unmount nullfs mounted certificates directory.
		JAIL_ID_FILE=`ls -1 /var/run/jail_${JAIL_TO_REVERT}.id | head -1`
		JAIL_ID=`cat ${JAIL_ID_FILE}`
		jail -r ${JAIL_ID} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		umount -f /jls/${JAIL_TO_REVERT}/usr/local/etc/ssl/certs > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	echo -e "\n"

	# Destroy additional jail recipe filesystems in reverse order.
	REV_SIDES_FILESYSTEMS=`echo ${SIDES_FILESYSTEMS} | rev`
	for REV_SIDES_FILESYSTEM in ${REV_SIDES_FILESYSTEMS}
	do
		SIDES_FILESYSTEM=`echo ${REV_SIDES_FILESYSTEM} | rev`
		zfs destroy -f ${SIDES_FILESYSTEM} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	done

	# Destroy the jail filesystem.
	zfs destroy -rf ${JAILS_POOL_NAME}/jails/${JAIL_TO_REVERT} > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	cd "/${REPO_NAME}"

	# Delete jail config directory from local repo.
	rm -rf configs/${JAIL_TO_REVERT}@${HOST_NAME} > /dev/null 2>&1

	# Roll back local repo to last good commit (!!!DANGEROUS!!!).
	if [ "${COMMIT_BEFORE_CREATE_JAIL}" != "" ]
	then
		git reset --hard ${COMMIT_BEFORE_CREATE_JAIL}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Remove untracked config files from host and config repo.
	rm /etc/fstab.${JAIL_TO_REVERT} > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	rm configs/${HOST_NAME}/etc/fstab.${JAIL_TO_REVERT} > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install back old host configs.
	install_file_tree configs/${HOST_NAME} /
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install back affected jail configs.
	for AFFECTED_JAIL_RECIPE in ${AFFECTED_JAIL_RECIPES}
	do
		echo -e "\n${YELL}Reverting configs for jails affected by recipe '${NRML}${AFFECTED_JAIL_RECIPE}${YELL}':${NRML}"
		find_jails_from_recipe_name ${AFFECTED_JAIL_RECIPE}
		for AFFECTED_JAIL in ${FOUND_RECIPE_JAILS}
		do
			# Use install_config to reinstate configs for jail found to be affected.
			echo -e "${YELL}${AFFECTED_JAIL}...${NRML}"
			install_configs configs/${AFFECTED_JAIL}@${HOST_NAME} /jls/${AFFECTED_JAIL}/
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${ORNG}WARNING:${NRML} Something went wrong reverting repo configs to the '${ORNG}${AFFECTED_JAIL}${NRML}' jail!\n"
				ERROR_COUNT=$(( ${ERROR_COUNT} + 1 ))
			fi
		done
	done

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} There was at least one unexpected error reverting the jail creation!\n"
		return 2
	fi

	echo -e "\n${YELL}Finished reverting jail creation!${NRML}\nAborting.\n"
	return 0
}

create_jail ()
{

	JAIL_NAME=${1}
	JAIL_HOST_NAME=${2}
	if [ "${3}" = "--non-interactive" ]
	then
		IS_INTERACTIVE="no"
	else
		IS_INTERACTIVE="yes"
	fi

	trap 'revert_create_jail ${JAIL_NAME}; exit 3' HUP INT QUIT KILL TERM

	ERROR_COUNT=0

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the the '${LBLU}init-host${NRML}' subcommand first.\n       Aborting.\n"
		return 1
	fi

	# Check for unsaved registered host config files.
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered\nconfig files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent > /dev/null 2>&1
	if [ ${?} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the '${LBLU}check-configs${NRML}' subcommand to see what's out-of-date."
		echo -e "       Please use the '${LBLU}update-config${NRML}' subcommannd to keep the repo up-to-date.\n       Aborting.\n"
		return 1
	fi

	# Check that the host.conf file is accessible.
	TEST_CONTENTS=`${UCL_CMD} get -u -f ${HOST_CONF_PATH} .general 2>&1`
	if [ ${?} -ne 0 ] || [ "${TEST_CONTENTS}" = "null" ] || [ "${TEST_CONTENTS}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to access the config file '${HOST_CONF_PATH}'!\n       Aborting.\n"
		return 2
	fi

	# Check that the jails.conf file is accessible.
	TEST_CONTENTS=`${UCL_CMD} get -u -f ${JAILS_CONF_PATH} .general 2>&1`
	if [ ${?} -ne 0 ] || [ "${TEST_CONTENTS}" = "null" ] || [ "${TEST_CONTENTS}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to access the config file '${JAILS_CONF_PATH}'!\n       Aborting.\n"
		return 2
	fi

	# Check that the jails subsystem is initialised.
	JAILS_SUBSYS_COMPAT=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .subsystems.jails_compat`
	if [ ${?} -ne 0 ] || [ "${JAILS_SUBSYS_COMPAT}" = "null" ] || [ "${JAILS_SUBSYS_COMPAT}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the jails subsystem is not initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} init-jails${NRML}\n       Aborting.\n"
		return 1
	fi

	# Get the jails pool name from the host config file.
	JAILS_POOL_NAME=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .storage.jails_pool`
	if [ ${?} -ne 0 ] || [ "${JAILS_POOL_NAME}" = "null" ] || [ "${JAILS_POOL_NAME}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the jails pool name from the host config file!\n       Aborting.\n"
		return 2
	fi

	# Check that the jail_name has not already been used.
	cat /etc/jail.conf | egrep "^${JAIL_NAME} {" > /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The jail_name '${ORNG}${JAIL_NAME}${NRML}' is already in use.\n       Aborting.\n"
		return 1
	fi

	# Check that, if specified, the jail IP address is not already in use.
	if [ "${JAIL_IP}" != "" ]
	then
		test_ping_host ${JAIL_IP}
		if [ "${VALID_HOST_PING}" = "yes" ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The jail IP address '${ORNG}${JAIL_IP}${NRML}' is already in use.\n       Aborting.\n"
			return 1
		fi
	fi

	# Get version strings.
	FREEBSD_VERSION_STRING=`freebsd-version`
	FREEBSD_VERSION=`freebsd-version | cut -d- -f1`
	FREEBSD_MAJOR_VERSION=`echo ${FREEBSD_VERSION} | cut -d. -f1`
	FREEBSD_MINOR_VERSION=`echo ${FREEBSD_VERSION} | cut -d. -f2`
	FREEBSD_CADENCE=`freebsd-version | cut -d- -f2`
	FREEBSD_PATCH_LEVEL=`freebsd-version | cut -d- -f3`
	FREEBSD_ARCH=`uname -m`

	TEMPLATE_SNAPSHOT=`zfs list -H -o name -s creation -t snapshot -r ${JAILS_POOL_NAME}/jails/template | cut -d@ -f2 | egrep "^${FREEBSD_VERSION}-RELEASE" | tail -1`

	LAN_NET_IFACE=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .network.interface.lan.id`
	if [ ${?} -ne 0 ] || [ "${LAN_NET_IFACE}" = "null" ] || [ "${LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the LAN interface id from the host config file!\n       Aborting.\n"
		return 2
	fi

	if [ "${JAIL_IP}" = "" ]
	then
		FIRST_AVAILABLE_IP=51
		while true
		do
			ifconfig ${LAN_NET_IFACE} | egrep "inet.*netmask 0xffffffff" | egrep "${JAILS_LAN_SUBNET_C}.${FIRST_AVAILABLE_IP}" > /dev/null 2>&1
			if [ ${?} -ne 0 ]
			then
				break
			else
				FIRST_AVAILABLE_IP=$(( ${FIRST_AVAILABLE_IP} + 1 ))
			fi
		done
		JAIL_IP="${JAILS_LAN_SUBNET_C}.${FIRST_AVAILABLE_IP}"
	fi

	# Create new jail filesystem by zfs send/recv from the template jail snapshot.
	echo -e "\n${YELL}Creating the new jail filesystem from the template jail...${NRML}\n"
	zfs send -e ${JAILS_POOL_NAME}/jails/template@${TEMPLATE_SNAPSHOT} | zfs recv ${JAILS_POOL_NAME}/jails/${JAIL_NAME}
	if [ ${?} -ne 0 ]
	then
		echo -e "${LRED}ERROR:${NRML} Failed to zfs send the jail template snapshot to the new jail filesystem!\n"
		revert_create_jail ${JAIL_NAME}
		return 2
	fi

	# Install template jails' configs to new jails' config repo directory.
	# NOTE: this has the side effect of giving the new jail the latest template configs regardless of snapshot state.
	mkdir configs/${JAIL_NAME}@${HOST_NAME}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	JAIL_CONFIG_FILES=`find config-templates/jail_template -type f | sed "s|^config-templates/jail_template/||"`
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	for CONFIG_FILE in ${JAIL_CONFIG_FILES}
	do
		if [ -f "/jls/template/${CONFIG_FILE}" ]
		then
			# If the config file is etc/resolv.conf, then copy it directly to the new jail, otherwise add to the registered config files.
			if [ "${CONFIG_FILE}" = "etc/resolv.conf" ]
			then
				cp /jls/template/${CONFIG_FILE} /jls/${JAIL_NAME}/${CONFIG_FILE}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			else
				CONFIG_FILE_DIR=`dirname ${CONFIG_FILE}`
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				if [ ! -d ${CONFIG_FILE_DIR} ]
				then
					mkdir -p configs/${JAIL_NAME}@${HOST_NAME}/${CONFIG_FILE_DIR}
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				fi
				cp /jls/template/${CONFIG_FILE} configs/${JAIL_NAME}@${HOST_NAME}/${CONFIG_FILE}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			fi
		fi
	done

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong in copying template configs to the new jail!\n"
		revert_create_jail ${JAIL_NAME}
		return 2
	fi

	# Save the previous git commit reference to file, for later use in reverting operations.
	COMMIT_BEFORE_CREATE_JAIL=`git log --format=format:%H -1`
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${JAIL_NAME}@${HOST_NAME}${RECIPE_CONF_PATH} .general.git_commit_before_create_jail "${COMMIT_BEFORE_CREATE_JAIL}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Create entry in /etc/jail.conf.
	echo "" >> configs/${HOST_NAME}/etc/jail.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	echo "${JAIL_NAME} {" >> configs/${HOST_NAME}/etc/jail.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	echo "        exec.prestart += \"/sbin/ifconfig ${LAN_NET_IFACE} inet ${JAIL_IP} netmask 255.255.255.255 alias\";" >> configs/${HOST_NAME}/etc/jail.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	echo "        exec.poststop += \"/sbin/ifconfig ${LAN_NET_IFACE} inet ${JAIL_IP} netmask 255.255.255.255 -alias\";" >> configs/${HOST_NAME}/etc/jail.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	echo "        host.hostname = \"${JAIL_HOST_NAME}\";" >> configs/${HOST_NAME}/etc/jail.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	echo "        ip4.addr = ${JAIL_IP};" >> configs/${HOST_NAME}/etc/jail.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	echo "}" >> configs/${HOST_NAME}/etc/jail.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Prepare the jail fstab.
	cp configs/${HOST_NAME}/etc/fstab.template configs/${HOST_NAME}/etc/fstab.${JAIL_NAME} > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sed -i "" "s|/jls/template/|/jls/${JAIL_NAME}/|" configs/${HOST_NAME}/etc/fstab.${JAIL_NAME} > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Add jail to jail_list in '/etc/rc.conf'.
	egrep "jail_list.*${JAIL_NAME}" configs/${HOST_NAME}/etc/rc.conf > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		sed -i "" "s|jail_list=\"\(.*\)\"|jail_list=\"\1 ${JAIL_NAME}\"|" configs/${HOST_NAME}/etc/rc.conf > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	else
		echo -e "\n${ORNG}WARNING:${NRML} The jail name '${ORNG}${JAIL_NAME}${NRML}' already exists in jail_list (/etc/rc.conf)!\n"
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong in configuring the host configs for the new jail!\n"
		revert_create_jail ${JAIL_NAME}
		return 2
	fi

	# Install latest scripts to the jail.
	install_scripts /jls/${JAIL_NAME}/
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install host configs to the system.
	install_file_tree configs/${HOST_NAME} /
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install initial config templates to the new jail.
	install_file_tree configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong in configuring the host configs for the new jail!\n"
		revert_create_jail ${JAIL_NAME}
		return 2
	fi

	if [ "${IS_INTERACTIVE}" = "yes" ]
	then
		# Add changes to the local config repo.
		git add configs/${HOST_NAME}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		git add configs/${JAIL_NAME}@${HOST_NAME}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
		git commit -m "Updating host after 'create-jail ${JAIL_NAME} ${JAIL_HOST_NAME}'; ${HOST_NAME}."
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		if [ ${ERROR_COUNT} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst commiting changes to the configs repo!\n"
			revert_create_jail ${JAIL_NAME}
			return 2
		fi

		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
			git_push origin master
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
				echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
			fi
		fi

		echo -e "\n${LGRN}Congratulations! We have now finished creating the jail '${NRML}${JAIL_NAME}${LGRN}'.${NRML}\n"
		echo -e "\n${YELL}To login to the jail, use the command:${NRML}"
		echo -e "${LBLU}jlogin ${JAIL_NAME}${NRML}\n"

		question_yes_no "Would you like to start the jail '${NRML}${JAIL_NAME}${LCYN}' now?"
		if [ "${ANSWER}" = "yes" ]
		then
			service jail start ${JAIL_NAME}
		fi
	else
		service jail start ${JAIL_NAME}
	fi

	echo -e ""
	return 0
}

edit_recipe_configs ()
{

	echo -e "\n"

	for CONFIG_FILE in ${RECIPE_CONFIG_FILES}
	do
		# Skip directories and certain unintersting files.
		FILE_PATH=`echo ${CONFIG_FILE} | sed "s|[^/]*\/[^/]*\/||"`
		FILE_NAME=`basename ${CONFIG_FILE}`
		if [ -d ${CONFIG_FILE} ] || [ "${FILE_NAME}" = "${PKG_REPO_CONF_FILE}" ] || [ "${FILE_NAME}" = "${PKG_REPO_CERT_FILE}" ] \
			|| [ "${FILE_PATH}" = "usr/local/etc/pkg/repos/freebsd.conf" ] || [ "${FILE_NAME}" = ".empty" ] \
			|| [ "${FILE_PATH}" = "${RECIPE_CONF_PATH}" ]
		then
			continue
		fi

		# Skip files modified prior to recipe (e.g. from create_jail).
		CONFIG_FILE_MODIFIED_TIMESTAMP=`stat -f "%Sm" -t "%s" ${CONFIG_FILE}`
		if [ ${PRE_RECIPE_TIMESTAMP} -gt ${CONFIG_FILE_MODIFIED_TIMESTAMP} ]
		then
			continue
		fi

		# Prompt user and if yes, display the config file in EDITOR.
		question_yes_no "Would you like to edit the recipe config '${NRML}${CONFIG_FILE}${LCYN}'?"
		if [ "${ANSWER}" = "yes" ]
		then
			if [ "${EDITOR}" = "" ]
			then
				EDITOR=ee
			fi
			echo ""
			${EDITOR} ${CONFIG_FILE}
			echo ""
		fi
	done

	return 0
}

create_jail_from_recipe ()
{

	JAIL_NAME="${1}"
	JAIL_HOST_NAME="${2}"
	JAIL_RECIPE_NAME="${3}"
	SIDES_POOL_NAME="fdo-jail-recipe-sides-pool-name"

	trap 'revert_create_jail ${JAIL_NAME}; exit 3' HUP INT QUIT KILL TERM

	ERROR_COUNT=0

	get_enabled_nat_services

	# Source the recipe.
	if [ -f "jail-recipes/${JAIL_RECIPE_NAME}/${JAIL_RECIPE_NAME}" ]
	then
		. "jail-recipes/${JAIL_RECIPE_NAME}/${JAIL_RECIPE_NAME}"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	else
		echo -e "\n${LRED}ERROR:${NRML} Unable to find the referenced recipe!"
		echo -e "       Check that the recipe '${ORNG}${JAIL_RECIPE_NAME}${NRML}' exists.\n       Aborting.\n"
		return 1
	fi

	# Do any preparation needed before cooking (e.g. display useful information, ask questions).
	# This should not involve any persistent changes to the system or any other jails.
	prep_recipe

	if [ "${PREP_SUCCESS}" = "yes" ]
	then
		echo -e "${LGRN}Recipe prep successful.${NRML}\n"
	elif [ "${PREP_SUCCESS}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Jail recipe prep was unsuccessful!\n       Aborting.\n"
		return 1
	else
		# We should never get here.
		echo -e "\n${ORNG}WARNING:${NRML} The recipe prep did not return a valid PREP_SUCCESS value!\n"
	fi

	# Check if SIDES_POOL_NAME is used for this recipe.
	echo "${SIDES_FILESYSTEMS}" | egrep "${SIDES_POOL_NAME}" > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		# Get pool name to use for additional recipe filesystems.
		SIDES_POOL_NAME=""
		POOLS_AVAILABLE=`zpool list -H -o name`
		NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
		if [ ${NUM_POOLS} -lt 1 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n       Aborting.\n"
			return 1
		fi
		if [ ${NUM_POOLS} -lt 2 ]
		then
			SIDES_POOL_NAME=${POOLS_AVAILABLE}
		else
			while [ "${SIDES_POOL_NAME}" = "" ]
			do
				dialog --no-items --no-cancel --menu "Select pool to use for additional ZFS filesystems:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
				SIDES_POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
				echo -e "\n"
				question_yes_no "\nYou have selected '${NRML}${SIDES_POOL_NAME_TEMP}${LCYN}' to use for additional filesystems.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					SIDES_POOL_NAME="${SIDES_POOL_NAME_TEMP}"
					break
				fi
				sleep 4
			done
		fi
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst preparing the jail recipe! [1]\n"
		revert_create_jail ${JAIL_NAME}
		return 2
	fi

	echo -e "\n\n${YELL}Creating a blank jail with the IP address '${NRML}${JAIL_IP}${YELL}'...${NRML}\n"

	# Create a blank jail (non-interactively).
	create_jail ${JAIL_NAME} ${JAIL_HOST_NAME} --non-interactive
	if [ ${?} -ne 0 ]
	then
		EXIT_CODE=${?}
		echo -e "\n${LRED}ERROR:${NRML} Creation of blank jail failed!\n"
		revert_create_jail ${JAIL_NAME}
		return ${EXIT_CODE}
	fi

	# Source the recipe again to pick up any updated variables.
	. jail-recipes/${JAIL_RECIPE_NAME}/${JAIL_RECIPE_NAME}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Sleep for 1 second to avoid timestamp conflicts.
	sleep 1

	PRE_RECIPE_TIMESTAMP=`date "+%s"`
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst preparing the jail recipe! [2]\n"
		revert_create_jail ${JAIL_NAME}
		return 2
	fi

	echo -e "\n\n${YELL}Creating any additional jail recipe filesystems...${NRML}\n"

	# Create additional jail recipe filesystems.
	COUNT_SIDES_FILESYSTEMS=0
	for SIDES_FILESYSTEM in ${SIDES_FILESYSTEMS}
	do
		COUNT_SIDES_FILESYSTEMS=$(( ${COUNT_SIDES_FILESYSTEMS} + 1 ))
		SIDES_MOUNTPOINT=`echo ${SIDES_MOUNTPOINTS} | awk -v column="${COUNT_SIDES_FILESYSTEMS}" '{print $column}'`
		zfs create -o mountpoint=${SIDES_MOUNTPOINT} ${SIDES_FILESYSTEM} > /dev/null 2>&1
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to create filesystem for the following additional filesystem:"
			echo -e "       ${ORNG}${SIDES_FILESYSTEM}${NRML}\n"
			revert_create_jail ${JAIL_NAME}
			return 2
		fi
	done

	# Install recipe config templates to new jails' config repo directory.
	install_file_tree jail-recipes/${JAIL_RECIPE_NAME}/config-templates configs/${JAIL_NAME}@${HOST_NAME}/
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set the correct jail ABI in the jails' pkg repo config file.
	sed -i "" "s|FDO_JAIL_ABI|${FREEBSD_MAJOR_VERSION}_${FREEBSD_MINOR_VERSION}${FREEBSD_ARCH}|" configs/${JAIL_NAME}@${HOST_NAME}/usr/local/etc/pkg/repos/FDo-pkg.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install initial config templates to the new jail.
	install_file_tree configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst installing the jail recipe configs!\n"
		revert_create_jail ${JAIL_NAME}
		return 2
	fi

	question_yes "\nShall we proceed to cook the recipe?"

	echo -e "\n\n${YELL}Cooking '${NRML}${JAIL_RECIPE_NAME}${YELL}' recipe for '${NRML}${JAIL_NAME}${YELL}'...${NRML}\n"

	# Cook the sourced recipe.
	cook_recipe

	# Add any port forwarding rules.
	if [ ${RECIPE_TCP_PORTS} ] && [ ${RECIPE_UDP_PORTS} ]
	then
		IS_REPO_CONF="yes" PF_CONF_PATH="configs/${HOST_NAME}/etc/pf.conf" fdo-pf-add-port-forward-rule "jail_${JAIL_NAME}" ${JAIL_IP} ${RECIPE_TCP_PORTS} ${RECIPE_UDP_PORTS} --non-interactive
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} failed to add port forwarding rules to pf!\n"
			RECIPE_SUCCESS="no"
		fi
		IS_REPO_CONF="yes" PPP_CONF_PATH="configs/${HOST_NAME}/etc/ppp/ppp.conf" fdo-ppp-add-port-forward-rule "jail_${JAIL_NAME}" ${JAIL_IP} ${RECIPE_TCP_PORTS} ${RECIPE_UDP_PORTS} --non-interactive
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} failed to add port forwarding rules to ppp nat!\n"
			RECIPE_SUCCESS="no"
		fi
	fi

	if [ "${RECIPE_SUCCESS}" = "yes" ] || [ "${RECIPE_SUCCESS}" = "devel" ]
	then
		# Get seasoning suggestion message from recipe.conf.
		SEASONING_SUGGESTION_MSG=`${UCL_CMD} get -f configs/${JAIL_NAME}@${HOST_NAME}${RECIPE_CONF_PATH} .seasoning_suggestion.message`
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		if [ "${SEASONING_SUGGESTION_MSG}" != "" ] && [ "${SEASONING_SUGGESTION_MSG}" != "null" ]
		then
			# Echo the seasoning suggestion message to the terminal, expanding any variables.
			eval echo -e "\"\n${YELL}Seasoning suggestion:${NRML}\n${SEASONING_SUGGESTION}\n\""
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

			# Set the seasoning suggestion message in recipe.conf after expanding any variables.
			EXPANDED_SEASONING_SUGGESTION_MSG=`eval echo -e "\"${SEASONING_SUGGESTION}\""`
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			${UCL_CMD} set -f configs/${JAIL_NAME}@${HOST_NAME}${RECIPE_CONF_PATH} .seasoning_suggestion.message "${EXPANDED_SEASONING_SUGGESTION_MSG}"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi

		if [ ${ERROR_COUNT} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst compiling or showing seasonal suggestions!\n"
			revert_create_jail ${JAIL_NAME}
			return 2
		fi

		pause_prompt 18

		# Interactively edit the configs touched by the recipe.
		RECIPE_CONFIG_FILES=`find configs/${JAIL_NAME}@${HOST_NAME} -print`
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		edit_recipe_configs

		# Save recipe name to recipe.conf.
		${UCL_CMD} set -f configs/${JAIL_NAME}@${HOST_NAME}${RECIPE_CONF_PATH} .general.jail_recipe "${JAIL_RECIPE_NAME}"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		# Add recipe compat level to recipe.conf.
		${UCL_CMD} set -f configs/${JAIL_NAME}@${HOST_NAME}${RECIPE_CONF_PATH} .general.recipe_compat ${RECIPE_COMPAT}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		# Install any new or modfied configs.
		install_file_tree configs/${HOST_NAME} /
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		install_file_tree configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		if [ ${ERROR_COUNT} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Something went wrong during post-cooking configuration!\n"
			revert_create_jail ${JAIL_NAME}
			return 2
		fi

		# Restart pf if required.
		if [ "${RECIPE_REQUIRES_NAT_RELOAD}" = "yes" ]
		then
			echo -e "\n"
			question_yes_no "Changes made by this recipe require restarting the NAT router service.\nWould you like to restart it now?"
			if [ "${ANSWER}" = "yes" ]
			then
				echo -e ""
				if [ "${IS_PPP_NAT_ENABLED}" = "YES" ]
				then
					# TODO: resolve why ppp can't reconnect on service restart.
					#service ppp restart > /dev/null 2>&1
					service ppp stop > /dev/null 2>&1
					sleep 4
					service ppp start > /dev/null 2>&1
					sleep 4
					service ppp start > /dev/null 2>&1
				fi
				if [ "${IS_PF_NAT_ENABLED}" = "YES" ]
				then
					service pf reload > /dev/null 2>&1
				fi
			fi
		fi

		# Restart jail if required.
		if [ "${RECIPE_REQUIRES_JAIL_RESTART}" = "yes" ]
		then
			service jail restart ${JAIL_NAME}
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi

		# Start jail recipe services.
		for SERVICE in ${START_JAIL_SERVICES}
		do
			start_jail_service ${JAIL_NAME} ${SERVICE} --allow-restart
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			sleep 4
		done

		if [ ${ERROR_COUNT} -ne 0 ]
		then
			# ASSUME: the jail restart and jail services restart are not errors critical to jail recipe creation.
			echo -e "\n${ORNG}WARNING:${NRML} Something went wrong whilst restarting the jail or it's services!\n"
		fi

	elif [ "${RECIPE_SUCCESS}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Jail recipe failed!\n"
		revert_create_jail ${JAIL_NAME}
		return 1
	else
		echo -e "\n${ORNG}WARNING:${NRML} The recipe did not return a valid RECIPE_SUCCESS value!"
		echo -e "         Consider reverting the jail creation by running the command:${NRML}"
		echo -e "${LBLU}         ${SCRIPT_NAME} revert-create-jail ${JAIL_NAME}${NRML}\n"
	fi

	if [ "${RECIPE_SUCCESS}" = "devel" ]
	then
		echo -e "\n${LGRN}After tasting your new recipe, you may run the command:${NRML}"
		echo -e "${LBLU}${SCRIPT_NAME} revert-create-jail ${JAIL_NAME}${NRML}\n"

		question_yes_no "Would you like to commit the changes to the config repo?"
		if [ "${ANSWER}" = "yes" ]
		then
			RECIPE_SUCCESS="yes"
		else
			echo -e ""
		fi
	fi

	if [ "${RECIPE_SUCCESS}" = "yes" ]
	then
		# Commit changes to the configs repo.
		git add configs/${HOST_NAME}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		git add configs/${JAIL_NAME}@${HOST_NAME}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		git commit -m "Updating host after 'create-jail-from-recipe ${JAIL_NAME} ${JAIL_HOST_NAME} ${JAIL_RECIPE_NAME}'; ${HOST_NAME}."
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		if [ ${ERROR_COUNT} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst commiting changes to the configs repo!\n"
			revert_create_jail ${JAIL_NAME}
			return 2
		fi

		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
			git_push origin master
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
				echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
			fi
		fi

		if [ -f /jls/${JAIL_NAME}/usr/local/etc/ssl/jail-certs.list ]
		then
			echo -e "\n${ORNG}NOTICE:${NRML} This jail requires some SSL certificates to be placed in the directory  "
			echo -e "         '${ORNG}/usr/local/etc/ssl/certs${NRML}'. They can be copied or symlinked to the     "
			echo -e "         correct file name either manually or by using the '${LBLU}fdo-cert-manager${NRML}'   "
			echo -e "         utility. To see a list of the required certificate files, use the      "
			echo -e "         following command:                                                     "
			echo -e "         ${LBLU}cat /jls/${JAIL_NAME}/usr/local/etc/ssl/jail-certs.list${NRML}\n"
		fi

		echo -e "\n${LGRN}Congratulations! We have now finished creating the jail '${NRML}${JAIL_NAME}${LGRN}'.${NRML}\n"
		echo -e "${YELL}To login to the jail, use the command:${NRML}"
		echo -e "${LBLU}jlogin ${JAIL_NAME}${NRML}\n"
	fi

	return 0
}

undo_init_vms ()
{

	ERROR_COUNT=0

	# Stop any running VMs.
	for VM_NAME_TEMP in `${FDO_VMS_LIST_PATH} --concise --type=all | egrep -v " stopped$" | awk '{print $1}'`
	do
		${FDO_VMS_STOP_PATH} "${VM_NAME_TEMP}" --force
	done

	# Undo any network config changes.
	if [ ${INIT_VMS_NET_LINK_TAP_UP_ON_OPEN_ONE} = true ]
	then
		sysctl net.link.tap.up_on_open=0 > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_VMS_BRIDGE_UP} = true ]
	then
		ifconfig ${VM_BRIDGE_IFACE} down > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_VMS_BRIDGE_ADDM} = true ]
	then
		ifconfig ${VM_BRIDGE_IFACE} deletem ${LAN_NET_IFACE} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_VMS_BRIDGE_CREATE} = true ]
	then
		ifconfig ${VM_BRIDGE_IFACE} destroy > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Unload any loaded kernel modules.
	if [ ${INIT_VMS_TAP_LOAD} = true ]
	then
		kldunload if_tap
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_VMS_BRIDGE_LOAD} = true ]
	then
		kldunload if_bridge
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_VMS_BRIDGESTP_LOAD} = true ]
	then
		kldunload bridgestp
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_VMS_VMM_LOAD} = true ]
	then
		kldunload vmm
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Destroy any created filesystems.
	if [ ${INIT_VMS_FILESYSTEMS_CREATED} = true ]
	then
		# Destroy the VMs base filesystem and any children.
		zfs destroy -rf ${VMS_POOL_NAME}/${VMS_ROOT_FS} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Undo host system modifications.
	if [ ${INIT_VMS_HOST_MODIFIED} = true ]
	then
		# Roll back local repo to last good commit (!!!DANGEROUS!!!).
		if [ "${COMMIT_BEFORE_INIT_VMS}" != "" ]
		then
			git reset --hard ${COMMIT_BEFORE_INIT_VMS}
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi

		# Install back old host configs.
		install_file_tree configs/${HOST_NAME} /
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} There was at least one unexpected error undoing the init-vms process!\n"
		return 2
	fi

	echo -e "\nAborting.\n"
	return 0
}

init_vms ()
{

	INIT_VMS_TAP_LOAD=false
	INIT_VMS_BRIDGE_LOAD=false
	INIT_VMS_BRIDGESTP_LOAD=false
	INIT_VMS_VMM_LOAD=false
	INIT_VMS_NET_LINK_TAP_UP_ON_OPEN_ONE=false
	INIT_VMS_BRIDGE_CREATE=false
	INIT_VMS_BRIDGE_ADDM=false
	INIT_VMS_BRIDGE_UP=false
	INIT_VMS_FILESYSTEMS_CREATED=false
	INIT_VMS_HOST_MODIFIED=false

	trap 'undo_init_vms ; exit 3' HUP INT QUIT KILL TERM

	# Save git commit reference so we can roll back changes later.
	COMMIT_BEFORE_INIT_VMS=`git log --format=format:%H -1`

	ERROR_COUNT=0

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the '${LBLU}init-host${NRML}' subcommand first."
		echo -e "       Aborting.\n"
		return 1
	fi

	# Check for unsaved registered host config files.
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent > /dev/null 2>&1
	if [ ${?} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the '${LBLU}check-configs${NRML}' subcommand to see what's out-of-date."
		echo -e "       Please use the '${LBLU}update-config${NRML}' subcommand to keep the repo up-to-date.\n       Aborting.\n"
		return 1
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Check that the host.conf file is accessible.
	TEST_CONTENTS=`${UCL_CMD} get -u -f ${HOST_CONF_PATH} .general 2>&1`
	if [ ${?} -ne 0 ] || [ "${TEST_CONTENTS}" = "null" ] || [ "${TEST_CONTENTS}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to access the config file '${HOST_CONF_PATH}'!\n       Aborting.\n"
		return 2
	fi

	# Check that the VMs subsystem is not already initialised.
	VMS_SUBSYS_COMPAT=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .subsystems.vms_compat`
	if [ ${?} -eq 0 ] && [ "${VMS_SUBSYS_COMPAT}" != "null" ] && [ "${VMS_SUBSYS_COMPAT}" != "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the VMs subsystem is already initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} dismantle-vms${NRML}\n       Aborting.\n"
		return 1
	fi

	# Get the LAN interface for this host.
	CONFIG_LAN_NET_IFACE=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .network.interface.lan.id`
	if [ ${?} -ne 0 ] || [ "${CONFIG_LAN_NET_IFACE}" = "null" ] || [ "${CONFIG_LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the LAN interface id from the host config file!\n       Aborting.\n"
		return 2
	fi
	LAN_NET_IFACE=""
	HOST_LAN_IP_ADDRESSES=""
	NET_IFACES=`ifconfig -l`
	for IFACE in ${NET_IFACES}
	do
		if [ "${IFACE}" = "${CONFIG_LAN_NET_IFACE}" ]
		then
			HOST_LAN_IP_ADDRESSES=`ifconfig ${IFACE} | egrep "inet.*netmask" | awk '{print $2}' | egrep "${SERVERS_LAN_SUBNET_C}." | sort`
			if [ "${HOST_LAN_IP_ADDRESSES}" != "" ]
			then
				LAN_NET_IFACE="${IFACE}"
			fi
		fi
	done

	# Exit if the LAN subnet interface was not found.
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The LAN interface '${ORNG}${CONFIG_LAN_NET_IFACE}${NRML}' does not provide a valid '${ORNG}${SERVERS_LAN_SUBNET_C}.*${NRML}' subnet!\n       Aborting.\n"
		return 1
	fi

	# Get pool name to use for base of VM image filesystems.
	VMS_POOL_NAME=""
	POOLS_AVAILABLE=`zpool list -H -o name`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n       Aborting.\n"
		return 1
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		VMS_POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${VMS_POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool to use for VM image filesystems:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			VMS_POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${VMS_POOL_NAME_TEMP}${LCYN}' to store the VM image filesystems.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VMS_POOL_NAME="${VMS_POOL_NAME_TEMP}"
				break
			fi
			sleep 4
		done
	fi

	# Test for existing VMs filesystems and prompt how to proceed.
	VMS_FILESYSTEM_EXISTS="no"
	zfs list -H ${VMS_POOL_NAME}/${VMS_ROOT_FS} > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The ZFS filesystem '${ORNG}${VMS_POOL_NAME}/${VMS_ROOT_FS}${NRML}' already exists!\n"
		question_yes_no "\nIt seems as though '${NRML}init-vms${LCYN}' has already been applied to this host.\nWould you like to proceed?"
		if [ "${ANSWER}" = "yes" ]
		then
			# Ask whether to purge, archive or reuse existing VMs base filesystems.
			question_purge_archive_reuse "\nWould you like to purge, archive or reuse the existing VMs base filesystem\nand all it's children filesystems? [CAUTION]"
			if [ "${ANSWER}" = "purge" ]
			then
				zfs destroy -Rf ${VMS_POOL_NAME}/${VMS_ROOT_FS}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			elif [ "${ANSWER}" = "archive" ]
			then
				NOW=`date "+%Y-%m-%d_%H-%M-%S"`
				zfs rename -f ${VMS_POOL_NAME}/${VMS_ROOT_FS} ${VMS_POOL_NAME}/${VMS_ROOT_FS}_renamed-by-init-vms-${NOW}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			elif [ "${ANSWER}" = "reuse" ]
			then
				VMS_FILESYSTEM_EXISTS="yes"
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} Unable to proceed.\n       Aborting.\n"
			return 1
		fi
	fi

	# Install required packages.
	echo -e "\n${YELL}First we need to install some required packages...${NRML}\n"
	pause_prompt 8
	pkg update -f
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	pkg install -y ${VM_SUBSYSTEM_PACKAGES}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} A problem was encountered whilst installing required packages!\n"
		undo_init_vms
		return 2
	fi

	# Load required kernel modules.
	kldstat -n if_tap > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_VMS_TAP_LOAD=true
		kldload if_tap 2> /dev/null
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	kldstat -n if_bridge > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_VMS_BRIDGE_LOAD=true
		kldload if_bridge 2> /dev/null
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	kldstat -n bridgestp > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_VMS_BRIDGESTP_LOAD=true
		kldload bridgestp 2> /dev/null
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	kldstat -n vmm > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_VMS_VMM_LOAD=true
		kldload vmm 2> /dev/null
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ `sysctl -n net.link.tap.up_on_open` -ne 1 ]
	then
		INIT_VMS_NET_LINK_TAP_UP_ON_OPEN_ONE=true
		sysctl net.link.tap.up_on_open=1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} A problem was encountered whilst loading the VM subsystem kernel modules!\n"
		undo_init_vms
		return 2
	fi

	# Get next available bridge id.
	VM_BRIDGE_ID=-1
	VM_BRIDGE_ID_TEMP=0
	while [ ${VM_BRIDGE_ID} -lt 0 ]
	do
		ifconfig "bridge${VM_BRIDGE_ID_TEMP}" > /dev/null 2>&1
		RESULT1=${?}
		sysrc "ifconfig_bridge${VM_BRIDGE_ID_TEMP}" > /dev/null 2>&1
		RESULT2=${?}
		if [ ${RESULT1} -eq 0 ] || [ ${RESULT2} -eq 0 ]
		then
			VM_BRIDGE_ID_TEMP=$(( ${VM_BRIDGE_ID_TEMP} + 1 ))
		else
			VM_BRIDGE_ID=${VM_BRIDGE_ID_TEMP}
		fi
	done

	VM_BRIDGE_IFACE="bridge${VM_BRIDGE_ID}"

	# Setup initial bridge interface.
	INIT_VMS_BRIDGE_CREATE=true
	ifconfig ${VM_BRIDGE_IFACE} create > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	INIT_VMS_BRIDGE_ADDM=true
	ifconfig ${VM_BRIDGE_IFACE} addm ${LAN_NET_IFACE} > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	INIT_VMS_BRIDGE_UP=true
	ifconfig ${VM_BRIDGE_IFACE} up > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to configure the network for the VM subsystem!\n"
		undo_init_vms
		return 2
	fi

	# Create ZFS filesystems for VM images.
	if [ "${VMS_FILESYSTEM_EXISTS}" = "no" ]
	then
		echo -e "\n${YELL}Creating ZFS filesystems for VM images...${NRML}\n"
		INIT_VMS_FILESYSTEMS_CREATED=true
		zfs create -o mountpoint="${VMS_ROOT_PATH}" -o compression=on -o recordsize=8k ${VMS_POOL_NAME}/${VMS_ROOT_FS}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	zfs list ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_RESOURCES_DIRNAME} > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		zfs create -o recordsize=512k ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_RESOURCES_DIRNAME}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	zfs list ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TEMPLATES_DIRNAME} > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		zfs create ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TEMPLATES_DIRNAME}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	zfs list ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_INSTANCES_DIRNAME} > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		zfs create ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_INSTANCES_DIRNAME}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	question_yes_no "\nShould the VM resources directory be accessible by non-root users [RECOMMENDED]?"
	if [ "${ANSWER}" = "yes" ]
	then
		chmod 777 "${VMS_ROOT_PATH}/${VM_RESOURCES_DIRNAME}" > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} An unexpected error occurred whilst creating VM subsystem filesystems!\n"
		undo_init_vms
		return 2
	fi

	# Mount the filesystems if they are not already.
	zfs mount | egrep "^${VMS_POOL_NAME}/${VMS_ROOT_FS} "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${VMS_POOL_NAME}/${VMS_ROOT_FS}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	zfs mount | egrep "^${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_RESOURCES_DIRNAME} "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_RESOURCES_DIRNAME}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	zfs mount | egrep "^${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TEMPLATES_DIRNAME} "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TEMPLATES_DIRNAME}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	zfs mount | egrep "^${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_INSTANCES_DIRNAME} "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_INSTANCES_DIRNAME}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} An unexpected error occurred whilst mounting VM subsystem filesystems!\n"
		undo_init_vms
		return 2
	fi

	INIT_VMS_HOST_MODIFIED=true

	# Ask if the fdo_vms service should be enabled on startup.
	question_yes_no "\nWould you like the VM service to be enabled on system startup?"
	if [ "${ANSWER}" = "yes" ]
	then
		echo -e ""
		sysrc -f configs/${HOST_NAME}/etc/rc.conf fdo_vms_enable="YES" > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Copy init-vms template configs to this hosts' repo profile.
	install_file_tree config-templates/init-vms configs/${HOST_NAME}/
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	echo -e ""

	# Set persitent bridge interface configuration.
	sysrc -f configs/${HOST_NAME}/boot/loader.conf if_tap_load="YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sysrc -f configs/${HOST_NAME}/boot/loader.conf if_bridge_load="YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sysrc -f configs/${HOST_NAME}/boot/loader.conf bridgestp_load="YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sysrc -f configs/${HOST_NAME}/boot/loader.conf vmm_load="YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sysrc -f configs/${HOST_NAME}/etc/rc.conf cloned_interfaces+="${VM_BRIDGE_IFACE}" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sed -i "" "s/^#ifconfig_VM_BRIDGE_IFACE=\"\"/ifconfig_${VM_BRIDGE_IFACE}=\"addm ${LAN_NET_IFACE}\"/" configs/${HOST_NAME}/etc/rc.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sed -i "" "s/^#net.link.tap.up_on_open=.*/net.link.tap.up_on_open=1/" configs/${HOST_NAME}/etc/sysctl.conf
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Store subsystem configuration details.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .storage.vms_pool "${VMS_POOL_NAME}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .network.bridge_id_num "${VM_BRIDGE_ID}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .network.bridge_nic_id "${LAN_NET_IFACE}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .network.vnc_port_offset "${DEFAULT_VM_VNC_PORT_NUM_START}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Add subsystems compat level and init marker to host config file.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .subsystems.vms_compat ${LATEST_VMS_SUBSYS_COMPAT}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install host configs to the system.
	install_file_tree configs/${HOST_NAME} /
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst finalising the VMs initialisation!\n"
		undo_init_vms
		return 2
	fi

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	git commit -m "Updating host after 'init-vms'; ${HOST_NAME}."
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst commiting changes to the configs repo!\n"
		undo_init_vms
		return 2
	fi

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
		git_push origin master
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
			echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished initialising the VM subsystem.${NRML}\n"
	echo -e "\n${YELL}To create a template VM, use the command:${NRML}"
	echo -e "${LBLU}${SCRIPT_NAME} create-vm-template${NRML}\n"

	return 0
}

undo_create_vm_template ()
{
	if [ ${CREATE_VM_TEMPLATE_MODIFIED} = true ]
	then
		ERROR_COUNT=0

		# Stop the template VM.
		VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-stop "${VM_NAME}" --force

		# Undo temporary network configuration.
		ifconfig ${VM_BRIDGE_IFACE} deletem ${VM_TAP_IFACE} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		ifconfig ${VM_TAP_IFACE} destroy > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		# Destroy any ZFS filesystems that were created.
		zfs destroy -rf ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		# Roll back local repo to last good commit (!!!DANGEROUS!!!).
		if [ "`git status -s`" != "" ]
		then
			git reset --hard ${COMMIT_BEFORE_CREATE_VM_TEMPLATE}
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi

		if [ ${ERROR_COUNT} -ne 0 ]
		then
			echo -e "\n${ORNG}WARNING:${NRML} There was an error during the undo of create-vm-template!\n"
		fi
	fi

	echo -e "\nAborting.\n"
	return 0
}

undo_create_vm_instance ()
{
	if [ ${CREATE_VM_INSTANCE_MODIFIED} = true ]
	then
		ERROR_COUNT=0

		# Stop the instance VM.
		VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-stop "${VM_NAME}" --force

		# Undo temporary network configuration.
		ifconfig ${VM_BRIDGE_IFACE} deletem ${VM_TAP_IFACE} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		ifconfig ${VM_TAP_IFACE} destroy > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		# Destroy any ZFS filesystems that were created.
		zfs destroy -rf ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		# Roll back local repo to last good commit (!!!DANGEROUS!!!).
		if [ "`git status -s`" != "" ]
		then
			git reset --hard ${COMMIT_BEFORE_CREATE_VM_INSTANCE}
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi

		if [ ${ERROR_COUNT} -ne 0 ]
		then
			echo -e "\n${ORNG}WARNING:${NRML} There was an error during the undo of create-vm-instance!\n"
		fi
	fi

	echo -e "\nAborting.\n"
	return 0
}

create_vm_image_handler ()
{
	VM_IMAGES_FINISHED=false
	while [ ${VM_IMAGES_FINISHED} = false ]
	do
		ERROR_COUNT=0
		while true
		do
			echo -e "\n${YELL}! You may now prepare the ${VM_TYPE} VM '${NRML}${VM_NAME}${YELL}'!${NRML}\n"
			echo -e "${LCYN}Choose from the following options:${NRML}\n"
			echo -e "${LCYN}  restart - Restart the VM (stop / start).${NRML}"
			echo -e "${LCYN}  insert  - Attach an additional ISO image (CD/DVD/USB).${NRML}"
			echo -e "${LCYN}  eject   - Eject an ISO image (CD/DVD/USB).${NRML}"
			echo -e "${LCYN}  attach  - Attach an additional disk image.${NRML}"
			echo -e "${LCYN}  detach  - Detach an additional disk image.${NRML}"
			echo -e "${LCYN}  list    - List additional images.${NRML}"
			echo -e "${LCYN}  finish  - When ${VM_TYPE} configuration is finished.${NRML}"
			echo -e "${LCYN}  abort   - Abort the create ${VM_TYPE} operation.${NRML}\n"
			readee -p "${LCYN}Choose action (restart|insert|eject|attach|detach|list|finish|abort): ${NRML}" ANSWER
			if [ "${ANSWER}" = "restart" ] \
			|| [ "${ANSWER}" = "insert" ] \
			|| [ "${ANSWER}" = "eject" ] \
			|| [ "${ANSWER}" = "attach" ] \
			|| [ "${ANSWER}" = "detach" ] \
			|| [ "${ANSWER}" = "list" ] \
			|| [ "${ANSWER}" = "finish" ] \
			|| [ "${ANSWER}" = "abort" ]
			then
				break
			fi
			echo -e ""
		done


		if [ "${ANSWER}" = "abort" ]
		then
			question_yes_no "\nAre you sure you want to abort? All changes will be lost."
			if [ "${ANSWER}" = "yes" ]
			then
				return 1
			fi
		fi


		if [ "${ANSWER}" = "finish" ]
		then
			question_yes_no "\nAre you sure you are finished preparing the ${VM_TYPE} VM?\nThe next step is to shutdown and save the ${VM_TYPE} for use."
			if [ "${ANSWER}" = "yes" ]
			then
				VM_IMAGES_FINISHED=true
			fi
		fi


		if [ "${ANSWER}" = "restart" ]
		then
			echo -e "\n${YELL}Please try to shutdown the VM gracefully first, if possible.${NRML}\n"
			question_yes "Proceed?"

			# Stop the VM.
			VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-stop "${VM_NAME}" --force

			# Pause for 4 seconds, to allow I/O to settle.
			sleep 4

			# Start the VM.
			VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-start "${VM_NAME}" --wait
		fi


		if [ "${ANSWER}" = "list" ]
		then

			# Retrieve existing image types.
			# ASSUME: 'null' is empty slot.
			IMAGE_1_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.1.type`
			IMAGE_1_FILENAME=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.1.filename`
			IMAGE_1_SECTOR_SIZE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.1.sectorsize`
			IMAGE_2_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.2.type`
			IMAGE_2_FILENAME=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.2.filename`
			IMAGE_2_SECTOR_SIZE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.2.sectorsize`

			echo -e ""
			echo -e "${LGRN}Images:${NRML}"
			echo -e ""
			echo -e "${GREY}==============================================================================${NRML}"
			echo -e "${NRML}Slot Type  Sector-size Filename                                               ${NRML}"
			echo -e "${GREY}==============================================================================${NRML}"

			case "${IMAGE_1_TYPE}" in
				ahci-cd)
					printf "%-5s%-6s%-12s%-55s\n" "1" "ISO" "N/A" "${IMAGE_1_FILENAME}"
					;;
				ahci-hd)
					printf "%-5s%-6s%-12s%-55s\n" "1" "Disk" "${IMAGE_1_SECTOR_SIZE}" "${IMAGE_1_FILENAME}"
					;;
				null)
					printf "%-5s%-6s%-12s%-55s\n" "1" "Empty" "" ""
					;;
			esac

			echo -e "${GREY}------------------------------------------------------------------------------${NRML}"

			case "${IMAGE_2_TYPE}" in
				ahci-cd)
					printf "%-5s%-6s%-12s%-55s\n" "2" "ISO" "N/A" "${IMAGE_2_FILENAME}"
					;;
				ahci-hd)
					printf "%-5s%-6s%-12s%-55s\n" "2" "Disk" "${IMAGE_2_SECTOR_SIZE}" "${IMAGE_2_FILENAME}"
					;;
				null)
					printf "%-5s%-6s%-12s%-55s\n" "2" "Empty" "" ""
					;;
			esac

			echo -e "${GREY}------------------------------------------------------------------------------${NRML}\n"

			pause_prompt 16

		fi


		if [ "${ANSWER}" = "attach" ]
		then
			# Retrieve existing image types (assume 'null' is empty slot).
			IMAGE_1_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.1.type`
			IMAGE_2_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.2.type`

			# Check that we have an available slot.
			if [ "${IMAGE_1_TYPE}" != "null" ] &&  [ "${IMAGE_2_TYPE}" != "null" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} There are no available slots.\n       Consider detaching a disk image or ejecting an ISO image.\n"
				continue
			fi

			# Ask if the newly attached image is a new disk or existing disk.
			question_yes_no "\nDoes the disk image already exist? (Answer '${NRML}no${LCYN}' to create new disk)."
			if [ "${ANSWER}" = "yes" ]
			then
				ATTACH_EXISTING_IMAGE=true

				# Ask for next disk image file to attach.
				ATTACH_IMAGE_FILE=""
				while [ "${ATTACH_IMAGE_FILE}" = "" ]
				do
					dialog --title "Select disk image file" --fselect "${VM_RESOURCES_PATH}/" 20 80 2> ${DIALOG_OUT_FILE}
					ATTACH_IMAGE_FILE_TEMP=`cat ${DIALOG_OUT_FILE}`
					if [ -e "${ATTACH_IMAGE_FILE_TEMP}" ]
					then
						file "${ATTACH_IMAGE_FILE_TEMP}" | grep "DOS/MBR boot sector" > /dev/null
						if [ ${?} -ne 0 ]
						then
							echo -e "\n\n${ORNG}WARNING:${NRML} File selected does not appear to be a valid disk image!\n"
							pause_prompt 8
						fi
						echo -e "\n"
						question_yes_no "\nYou have selected '${NRML}${ATTACH_IMAGE_FILE_TEMP}${LCYN}' as the next disk image to attach.\nIs this correct?"
						if [ "${ANSWER}" = "yes" ]
						then
							ATTACH_IMAGE_FILE="${ATTACH_IMAGE_FILE_TEMP}"
							break
						fi
					else
						echo -e "\n\n${ORNG}WARNING:${NRML} No file selected!\n"
						question_yes_no "\nWould you like to try again?"
						if [ "${ANSWER}" = "no" ]
						then
							echo -e "\n${ORNG}Insert disk image cancelled.${NRML}\n"
							break
						fi
						echo -e ""
					fi
					sleep 4
				done
			else
				ATTACH_EXISTING_IMAGE=false

				# Ask for size of new disk image.
				ATTACH_IMAGE_SIZE_GB=0
				while [ ${ATTACH_IMAGE_SIZE_GB} -eq 0 ]
				do
					echo -e ""
					readee -p "${LCYN}Enter the size in GB of the new disk image: ${NRML}" ATTACH_IMAGE_SIZE_GB_TEMP
					# Check that the VM disk size contains only numbers.
					test_valid_integer "${ATTACH_IMAGE_SIZE_GB_TEMP}" ${VM_MIN_IMAGE_SIZE_GB} ${VM_MAX_IMAGE_SIZE_GB}
					if [ "${VALID_INTEGER}" = "yes" ]
					then
						question_yes_no "\nYou have entered '${NRML}${ATTACH_IMAGE_SIZE_GB_TEMP}${LCYN}' GB as the disk image size.\nIs this correct?"
						if [ "${ANSWER}" = "yes" ]
						then
							ATTACH_IMAGE_SIZE_GB=${ATTACH_IMAGE_SIZE_GB_TEMP}
						fi
					else
						echo -e "\n${LRED}ERROR:${NRML} The disk image size can not be '${ORNG}${ATTACH_IMAGE_SIZE_GB_TEMP}${NRML}'."
						echo -e "       It must contain only numbers of value between ${VM_MIN_IMAGE_SIZE_GB} and ${VM_MAX_IMAGE_SIZE_GB}.\n"
					fi
				done
			fi

			if [ "${ATTACH_IMAGE_FILE}" != "" ] || [ ${ATTACH_EXISTING_IMAGE} = false ]
			then
				# TODO: ask or test for next disk sectorsize.
				IMAGE_SECTOR_SIZE=${VM_DEFAULT_SECTOR_SIZE}

				# Ask for image filename.
				IMAGE_NAME=""
				while [ "${IMAGE_NAME}" = "" ]
				do
					echo -e ""
					readee -p "${LCYN}Enter the name of the disk image: ${NRML}" IMAGE_NAME_TEMP

					# Check that the disk image name is not already in use.
					zfs list -H ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME}/${IMAGE_NAME_TEMP} > /dev/null 2>&1
					if [ ${?} -eq 0 ]
					then
						echo -e "\n${LRED}ERROR:${NRML} The disk image name '${ORNG}${IMAGE_NAME_TEMP}${NRML}'\n       is already in use.\n"
						continue
					fi

					# Check that the disk image name contains only valid characters.
					test_valid_vm_name "${IMAGE_NAME_TEMP}"
					if [ "${VALID_VM_NAME}" = "yes" ]
					then
						question_yes_no "\nYou have entered:\n'${NRML}${IMAGE_NAME_TEMP}${LCYN}'\nas the name of this disk image.\nIs this correct?"
						if [ "${ANSWER}" = "yes" ]
						then
							IMAGE_NAME=${IMAGE_NAME_TEMP}
						fi
					else
						echo -e "\n${LRED}ERROR:${NRML} The disk image name is not valid."
						echo -e "       It must only contain letters, numbers and underscores."
						echo -e "       It must not begin or end with an underscore."
						echo -e "       It must be between 3 and 30 characters in length.\n"
					fi
				done

				# Image filename is concatenation of its filesystem/directory <IMAGE_NAME> and file name <IMAGE_NAME>.img.
				IMAGE_FILENAME="${IMAGE_NAME}/${IMAGE_NAME}.img"

				echo -e "\n${YELL}Creating additional disk image filesystem...${NRML}\n"
				zfs create ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME}/${IMAGE_NAME} 2> /dev/null
				if [ ${?} -ne 0 ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Failed to create the additional disk image filesystem!\n"
					# Skip to top of this while loop, we don't want to do anything else.
					continue
				fi

				if [ ${ATTACH_EXISTING_IMAGE} = true ]
				then
					# Copy next disk image to VM directory.
					echo -e "\n${YELL}Copying additional disk image to its filesystem...${NRML}\n"
					cp "${ATTACH_IMAGE_FILE}" "${VM_FS_MOUNTPOINT}/${IMAGE_FILENAME}" > /dev/null 2>&1
					if [ ${?} -ne 0 ]
					then
						echo -e "\n${ORNG}WARNING:${NRML} There was a problem copying the disk image to its filesystem!\n"
						zfs destroy -f ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME}/${IMAGE_NAME} > /dev/null 2>&1
						# Skip to top of this while loop, we don't want to do anything else.
						continue
					fi
				else
					# Create new disk image.
					echo -e "\n${YELL}Creating additional disk image in its filesystem...${NRML}\n"
					truncate -s "${ATTACH_IMAGE_SIZE_GB}G" "${VM_FS_MOUNTPOINT}/${IMAGE_FILENAME}" > /dev/null 2>&1
					if [ ${?} -ne 0 ]
					then
						echo -e "\n${ORNG}WARNING:${NRML} There was a problem creating the disk image in its filesystem!\n"
						zfs destroy -f ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME}/${IMAGE_NAME} > /dev/null 2>&1
						# Skip to top of this while loop, we don't want to do anything else.
						continue
					fi
				fi

				# Add the disk image as an ahci-hd device in the vms.conf file.
				# Prefer to use first empty slot.
				if [ "${IMAGE_1_TYPE}" = "null" ]
				then
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} -t object .${VM_TYPE}s.${VM_INDEX}.images.1 "{ type = \"ahci-hd\"; }"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .${VM_TYPE}s.${VM_INDEX}.images.1.filename  "${IMAGE_FILENAME}"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .${VM_TYPE}s.${VM_INDEX}.images.1.sectorsize  "${IMAGE_SECTOR_SIZE}"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				elif [ "${IMAGE_2_TYPE}" = "null" ]
				then
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} -t object .${VM_TYPE}s.${VM_INDEX}.images.2 "{ type = \"ahci-hd\"; }"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .${VM_TYPE}s.${VM_INDEX}.images.2.filename  "${IMAGE_FILENAME}"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .${VM_TYPE}s.${VM_INDEX}.images.2.sectorsize  "${IMAGE_SECTOR_SIZE}"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				else
					echo -e "\n${ORNG}WARNING:${NRML} No available image slots left.\n"
					# Skip to top of this while loop, we don't want to do anything else.
					continue
				fi

				if [ ${ERROR_COUNT} -ne 0 ]
				then
					echo -e "\n${ORNG}WARNING:${NRML} Something went wrong attaching the disk image.\n"
					# Skip to top of this while loop, we don't want to do anything else.
					continue
				fi

				echo -e "${YELL}\nPlease try to shutdown the VM gracefully first, if possible.${NRML}\n"
				question_yes "Proceed?"

				# Stop the VM.
				VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-stop "${VM_NAME}" --force

				# Pause for 4 seconds, to allow I/O to settle.
				sleep 4

				# Start the VM.
				VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-start "${VM_NAME}" --wait
			fi
		fi


		if [ "${ANSWER}" = "detach" ]
		then
			IMAGE_ITEMS=""
			IMAGE_1_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.1.type`
			IMAGE_1_FILENAME=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.1.filename`
			IMAGE_2_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.2.type`
			IMAGE_2_FILENAME=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.2.filename`

			CURRENT_IFS="${IFS}"
			IFS="	"

			if [ "${IMAGE_1_TYPE}" = "ahci-hd" ]
			then
				IMAGE_ITEMS="${IMAGE_ITEMS}	1	${IMAGE_1_FILENAME}"
			fi
			if [ "${IMAGE_2_TYPE}" = "ahci-hd" ]
			then
				IMAGE_ITEMS="${IMAGE_ITEMS}	2	${IMAGE_2_FILENAME}"
			fi
			if [ "${IMAGE_ITEMS}" = "" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} There are no additional disk images to detach!\n"
				continue
			fi

			IMAGE_INDEX=-1
			while [ ${IMAGE_INDEX} -lt 0 ]
			do
				dialog --menu "Select the disk image to detach:" 12 80 10 ${IMAGE_ITEMS} 2> ${DIALOG_OUT_FILE}
				IMAGE_INDEX_TEMP=`cat ${DIALOG_OUT_FILE}`
				VAR_IMAGE_FILENAME_TEMP="IMAGE_${IMAGE_INDEX_TEMP}_FILENAME"
				eval IMAGE_FILENAME_TEMP="\$${VAR_IMAGE_FILENAME_TEMP}"
				if [ -e "${VM_FS_MOUNTPOINT}/${IMAGE_FILENAME_TEMP}" ]
				then
					file "${VM_FS_MOUNTPOINT}/${IMAGE_FILENAME_TEMP}" | grep "DOS/MBR boot sector" > /dev/null
					if [ ${?} -ne 0 ]
					then
						echo -e "\n\n${ORNG}WARNING:${NRML} File selected does not appear to be a valid disk image!\n"
						pause_prompt 8
					fi
					echo -e "\n"
					question_yes_no "\nYou have selected '${NRML}${IMAGE_FILENAME_TEMP}${LCYN}' \nas the disk image to detach.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						IMAGE_INDEX="${IMAGE_INDEX_TEMP}"
						IMAGE_FILENAME="${IMAGE_FILENAME_TEMP}"
						IMAGE_NAME=`echo ${IMAGE_FILENAME} | cut -d/ -f1`
						break
					fi
				else
					echo -e "\n\n${ORNG}WARNING:${NRML} No file selected!\n"
					question_yes_no "\nWould you like to try again?"
					if [ "${ANSWER}" = "no" ]
					then
						echo -e "\n${ORNG}Detach disk image cancelled.${NRML}\n"
						break
					fi
					echo -e ""
				fi
				sleep 4
			done

			IFS="${CURRENT_IFS}"

			if [ ${IMAGE_INDEX} -ge 0 ]
			then
				echo -e "${YELL}\nPlease try to shutdown the VM gracefully first, if possible.${NRML}\n"
				question_yes "Proceed?"

				# Stop the VM.
				VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-stop "${VM_NAME}" --force

				# Allow archiving of the detached disk image.
				question_yes_no "\nWould you like to keep a copy of the detached disk image?"
				if [ "${ANSWER}" = "yes" ]
				then
					# Ask for archive file name.
					ARCHIVE_IMAGE_NAME=""
					while [ "${ARCHIVE_IMAGE_NAME}" = "" ]
					do
						echo -e ""
						readee -p "${LCYN}Enter the name for the archived disk image: ${NRML}" ARCHIVE_IMAGE_NAME_TEMP

						# Check that the disk image name is not already in use.
						if [ -e "${VM_RESOURCES_PATH}/${ARCHIVE_IMAGE_NAME_TEMP}.img" ]
						then
							echo -e "\n${LRED}ERROR:${NRML} A file already exists in the resources directory with the name:\n       ${ORNG}${ARCHIVE_IMAGE_NAME_TEMP}.img${NRML}.\n"
							continue
						fi

						# Check that the disk image name contains only valid characters.
						test_valid_vm_name "${ARCHIVE_IMAGE_NAME_TEMP}"
						if [ "${VALID_VM_NAME}" = "yes" ]
						then
							question_yes_no "\nYou have entered:\n'${NRML}${ARCHIVE_IMAGE_NAME_TEMP}${LCYN}'\nas the name of this disk image.\nIs this correct?"
							if [ "${ANSWER}" = "yes" ]
							then
								ARCHIVE_IMAGE_NAME=${ARCHIVE_IMAGE_NAME_TEMP}
							fi
						else
							echo -e "\n${LRED}ERROR:${NRML} The archive disk image name is not valid."
							echo -e "       It must only contain letters, numbers and underscores."
							echo -e "       It must not begin or end with an underscore."
							echo -e "       It must be between 3 and 30 characters in length.\n"
						fi
					done

					# Copy the detached disk image to the archive image name in the resources directory.
					echo -e "\n${YELL}Copying detached disk image as archive to the resources directory...${NRML}\n"
					cp "${VM_FS_MOUNTPOINT}/${IMAGE_FILENAME}" "${VM_RESOURCES_PATH}/${ARCHIVE_IMAGE_NAME}.img" > /dev/null 2>&1
					if [ ${?} -ne 0 ]
					then
						echo -e "\n${LRED}ERROR:${NRML} Failed to archive the additional disk image to the resources directory!\n"
						# Skip to top of this while loop, we don't want to do anything else.
						continue
					fi
				fi

				echo -e "\n${YELL}Destroying disk image filesystem...${NRML}\n"
				zfs destroy -f ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME}/${IMAGE_NAME} > /dev/null 2>&1
				if [ ${?} -ne 0 ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Failed to destroy the additional disk image filesystem!\n"
					# Skip to top of this while loop, we don't want to do anything else.
					continue
				fi

				# Remove the disk image in the vms.conf file.
				${UCL_CMD} remove -f configs/${HOST_NAME}/${VMS_CONF_PATH} -o configs/${HOST_NAME}/${VMS_CONF_PATH} .${VM_TYPE}s.${VM_INDEX}.images.${IMAGE_INDEX}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

				# Pause for 4 seconds, to allow I/O to settle.
				sleep 4

				# Start the VM.
				VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-start "${VM_NAME}" --wait

			fi

		fi


		if [ "${ANSWER}" = "insert" ]
		then
			# Retrieve existing image types (assume 'null' is empty slot).
			IMAGE_1_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.1.type`
			IMAGE_2_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.2.type`

			# Check that we have an available slot.
			if [ "${IMAGE_1_TYPE}" != "null" ] &&  [ "${IMAGE_2_TYPE}" != "null" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} There are no available slots.\n       Consider detaching a disk image or ejecting an ISO image.\n"
				continue
			fi

			# Ask for next ISO image file to insert.
			INSERT_IMAGE_FILE=""
			while [ "${INSERT_IMAGE_FILE}" = "" ]
			do
				dialog --title "Select ISO image file" --fselect "${VM_RESOURCES_PATH}/" 20 80 2> ${DIALOG_OUT_FILE}
				INSERT_IMAGE_FILE_TEMP=`cat ${DIALOG_OUT_FILE}`
				if [ -e "${INSERT_IMAGE_FILE_TEMP}" ]
				then
					file "${INSERT_IMAGE_FILE_TEMP}" | grep "ISO 9660" > /dev/null
					if [ ${?} -eq 0 ]
					then
						echo -e "\n"
						question_yes_no "\nYou have selected '${NRML}${INSERT_IMAGE_FILE_TEMP}${LCYN}' as the next ISO image to insert.\nIs this correct?"
						if [ "${ANSWER}" = "yes" ]
						then
							INSERT_IMAGE_FILE="${INSERT_IMAGE_FILE_TEMP}"
							break
						fi
					else
						echo -e "\n\n${ORNG}WARNING:${NRML} File selected is not an ISO!\n"
						pause_prompt 8
					fi
				else
					echo -e "\n\n${ORNG}WARNING:${NRML} No file selected!\n"
					question_yes_no "\nWould you like to try again?"
					if [ "${ANSWER}" = "no" ]
					then
						echo -e "\n${ORNG}Insert ISO image cancelled.${NRML}\n"
						break
					fi
					echo -e ""
				fi
				sleep 4
			done

			if [ "${INSERT_IMAGE_FILE}" != "" ]
			then
				# Copy next ISO image to VM resources directory.
				IMAGE_FILENAME=`basename "${INSERT_IMAGE_FILE}"`
				if [ "${INSERT_IMAGE_FILE}" != "${VM_RESOURCES_PATH}/${IMAGE_FILENAME}" ]
				then
					echo -e "\n${YELL}Copying ISO image to the resources directory...${NRML}\n"
					cp "${INSERT_IMAGE_FILE}" "${VM_RESOURCES_PATH}/${IMAGE_FILENAME}" > /dev/null 2>&1
					if [ ${?} -ne 0 ]
					then
						echo -e "\n${ORNG}WARNING:${NRML} There was a problem copying the ISO image\n         to the resources filesystem!\n"
						# Skip to top of this while loop, we don't want to do anything else.
						continue
					fi
				fi

				# Add the ISO image as an ahci-cd device in the vms.conf file.
				# Prefer to use first empty slot, otherwise last ahci-cd slot.
				if [ "${IMAGE_1_TYPE}" = "null" ]
				then
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} -t object .${VM_TYPE}s.${VM_INDEX}.images.1 "{ type = \"ahci-cd\"; }"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .${VM_TYPE}s.${VM_INDEX}.images.1.filename  "${IMAGE_FILENAME}"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				elif [ "${IMAGE_2_TYPE}" = "null" ]
				then
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} -t object .${VM_TYPE}s.${VM_INDEX}.images.2 "{ type = \"ahci-cd\"; }"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .${VM_TYPE}s.${VM_INDEX}.images.2.filename  "${IMAGE_FILENAME}"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				elif [ "${IMAGE_2_TYPE}" = "ahci-cd" ]
				then
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .${VM_TYPE}s.${VM_INDEX}.images.2.filename  "${IMAGE_FILENAME}"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				elif [ "${IMAGE_1_TYPE}" = "ahci-cd" ]
				then
					${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .${VM_TYPE}s.${VM_INDEX}.images.1.filename  "${IMAGE_FILENAME}"
					ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				else
					echo -e "\n${ORNG}WARNING:${NRML} No available image slots left.\n"
					# Skip to top of this while loop, we don't want to do anything else.
					continue
				fi

				if [ ${ERROR_COUNT} -ne 0 ]
				then
					echo -e "\n${ORNG}WARNING:${NRML} Something went wrong preparing next ISO image.\n"
					# Skip to top of this while loop, we don't want to do anything else.
					continue
				fi

				echo -e "${YELL}\nPlease try to shutdown the VM gracefully first, if possible.${NRML}\n"
				question_yes "Proceed?"

				# Stop the VM.
				VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-stop "${VM_NAME}" --force

				# Pause for 4 seconds, to allow I/O to settle.
				sleep 4

				# Start the VM.
				VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-start "${VM_NAME}" --wait
			fi
		fi


		if [ "${ANSWER}" = "eject" ]
		then
			IMAGE_ITEMS=""
			IMAGE_1_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.1.type`
			IMAGE_1_FILENAME=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.1.filename`
			IMAGE_2_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.2.type`
			IMAGE_2_FILENAME=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.2.filename`

			CURRENT_IFS="${IFS}"
			IFS="	"

			if [ "${IMAGE_1_TYPE}" = "ahci-cd" ]
			then
				IMAGE_ITEMS="${IMAGE_ITEMS}	1	${IMAGE_1_FILENAME}"
			fi
			if [ "${IMAGE_2_TYPE}" = "ahci-cd" ]
			then
				IMAGE_ITEMS="${IMAGE_ITEMS}	2	${IMAGE_2_FILENAME}"
			fi
			if [ "${IMAGE_ITEMS}" = "" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} There are no ISO images to eject!\n"
				continue
			fi

			IMAGE_INDEX=-1
			while [ ${IMAGE_INDEX} -lt 0 ]
			do
				dialog --menu "Select the ISO image to detach:" 12 80 10 ${IMAGE_ITEMS} 2> ${DIALOG_OUT_FILE}
				IMAGE_INDEX_TEMP=`cat ${DIALOG_OUT_FILE}`
				VAR_IMAGE_FILENAME_TEMP="IMAGE_${IMAGE_INDEX_TEMP}_FILENAME"
				eval IMAGE_FILENAME_TEMP="\$${VAR_IMAGE_FILENAME_TEMP}"
				if [ -e "${VM_RESOURCES_PATH}/${IMAGE_FILENAME_TEMP}" ]
				then
					file "${VM_RESOURCES_PATH}/${IMAGE_FILENAME_TEMP}" | grep "ISO 9660" > /dev/null
					if [ ${?} -ne 0 ]
					then
						echo -e "\n\n${ORNG}WARNING:${NRML} File selected does not appear to be a valid ISO image!\n"
						pause_prompt 8
					fi
					echo -e "\n"
					question_yes_no "\nYou have selected '${NRML}${IMAGE_FILENAME_TEMP}${LCYN}' \nas the ISO image to detach.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						IMAGE_INDEX="${IMAGE_INDEX_TEMP}"
						IMAGE_FILENAME="${IMAGE_FILENAME_TEMP}"
						break
					fi
				else
					echo -e "\n\n${ORNG}WARNING:${NRML} No file selected!\n"
					question_yes_no "\nWould you like to try again?"
					if [ "${ANSWER}" = "no" ]
					then
						echo -e "\n${ORNG}Insert ISO image cancelled.${NRML}\n"
						break
					fi
					echo -e ""
				fi
				sleep 4
			done

			IFS="${CURRENT_IFS}"

			if [ ${IMAGE_INDEX} -ge 0 ]
			then
				echo -e "${YELL}\nPlease try to shutdown the VM gracefully first, if possible.${NRML}\n"
				question_yes "Proceed?"

				# Stop the VM.
				VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-stop "${VM_NAME}" --force

				# Remove the disk image in the vms.conf file.
				${UCL_CMD} remove -f configs/${HOST_NAME}/${VMS_CONF_PATH} -o configs/${HOST_NAME}/${VMS_CONF_PATH} .${VM_TYPE}s.${VM_INDEX}.images.${IMAGE_INDEX}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

				# Pause for 4 seconds, to allow I/O to settle.
				sleep 4

				# Start the VM.
				VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-start "${VM_NAME}" --wait

			fi

		fi

	done

	return 0
}

create_vm_template ()
{

	VM_NAME="${1}"
	VM_TYPE="template"
	VM_TYPE_DIRNAME="${VM_TEMPLATES_DIRNAME}"
	CREATE_VM_TEMPLATE_MODIFIED=false

	trap 'undo_create_vm_template ; exit 3' HUP INT QUIT KILL TERM

	# Save git commit reference so we can roll back changes later.
	COMMIT_BEFORE_CREATE_VM_TEMPLATE=`git log --format=format:%H -1`

	ERROR_COUNT=0

	# Check that the template name is valid.
	test_valid_vm_name "${VM_NAME}"
	if [ "${VALID_VM_NAME}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The template name can not be '${ORNG}${VM_NAME}${NRML}'."
		echo -e "       It must only contain letters, numbers and underscores."
		echo -e "       It must not begin or end with an underscore."
		echo -e "       It must be between 3 and 30 characters in length."
		echo -e "       Aborting.\n"
		return 1
	fi

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the '${LBLU}init-host${NRML}' subcommand first.\n       Aborting.\n"
		return 1
	fi

	# Check for unsaved registered host config files.
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent > /dev/null 2>&1
	if [ ${?} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the '${LBLU}check-configs${NRML}' subcommand to see what's out-of-date."
		echo -e "       Please use the '${LBLU}update-config${NRML}' subcommand to keep the repo up-to-date.\n       Aborting.\n"
		return 1
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Check that the host.conf file is accessible.
	TEST_CONTENTS=`${UCL_CMD} get -u -f ${HOST_CONF_PATH} .general 2>&1`
	if [ ${?} -ne 0 ] || [ "${TEST_CONTENTS}" = "null" ] || [ "${TEST_CONTENTS}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to access the config file '${HOST_CONF_PATH}'!\n       Aborting.\n"
		return 2
	fi

	# Check that the vms.conf file is accessible.
	TEST_CONTENTS=`${UCL_CMD} get -u -f ${VMS_CONF_PATH} .general 2>&1`
	if [ ${?} -ne 0 ] || [ "${TEST_CONTENTS}" = "null" ] || [ "${TEST_CONTENTS}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to access the config file '${VMS_CONF_PATH}'!\n       Aborting.\n"
		return 2
	fi

	# Check that the VMs subsystem is initialised.
	VMS_SUBSYS_COMPAT=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .subsystems.vms_compat`
	if [ ${?} -ne 0 ] || [ "${VMS_SUBSYS_COMPAT}" = "null" ] || [ "${VMS_SUBSYS_COMPAT}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the VMs subsystem is not initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} init-vms${NRML}\n       Aborting.\n"
		return 1
	fi

	# Get the VMs pool name from the host config file.
	VMS_POOL_NAME=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .storage.vms_pool`
	if [ ${?} -ne 0 ] || [ "${VMS_POOL_NAME}" = "null" ] || [ "${VMS_POOL_NAME}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the VMs pool name from the host config file!\n       Aborting.\n"
		return 2
	fi

	# Check that the template name is not already used.
	VM_INDEX=0
	while [ `${UCL_CMD} get -f ${VMS_CONF_PATH} -q .templates.${VM_INDEX}` != "null" ]
	do
		TEST_TEMPLATE_NAME=`${UCL_CMD} get -f ${VMS_CONF_PATH} -q .templates.${VM_INDEX}.name`
		if [ "${VM_NAME}" = "${TEST_TEMPLATE_NAME}" ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The template '${ORNG}${VM_NAME}${NRML}' already exists.\n"
			echo -e "       To delete it, use the command:"
			echo -e "       ${LBLU}${SCRIPT_NAME} destroy-vm-template ${VM_NAME}${NRML}\n"
			echo -e "       Aborting.\n"
			return 1
		fi
		VM_INDEX=$(( ${VM_INDEX} + 1 ))
	done

	# Get the bridge id from the VMs config file.
	VM_BRIDGE_ID=`${UCL_CMD} get -f ${VMS_CONF_PATH} -q .network.bridge_id_num`
	if [ ${?} -ne 0 ] || [ "${VM_BRIDGE_ID}" = "null" ] || [ "${VM_BRIDGE_ID}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the VMs bridge id number from the VMs config file!\n       Aborting.\n"
		return 2
	fi

	# Get the bridge net interface (NIC) name from the VMs config file.
	VM_BRIDGE_NET_IFACE=`${UCL_CMD} get -f ${VMS_CONF_PATH} -q .network.bridge_nic_id`
	if [ ${?} -ne 0 ] || [ "${VM_BRIDGE_NET_IFACE}" = "null" ] || [ "${VM_BRIDGE_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the VMs bridge NIC id from the VMs config file!\n       Aborting.\n"
		return 2
	fi

	# Get the network interface used for the bridge interface.
	VM_BRIDGE_IFACE_IP_ADDRESSES=`ifconfig ${VM_BRIDGE_NET_IFACE} | egrep "inet.*netmask" | awk '{print $2}' | sort`

	# Exit if the bridge network interface has no IP addresses.
	if [ "${VM_BRIDGE_IFACE_IP_ADDRESSES}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The bridge network interface '${ORNG}${VM_BRIDGE_NET_IFACE}${NRML}' does not have any IP addresses!\n       Aborting.\n"
		return 1
	fi

	# Get the IP address of the bridge network interface.
	for IP_ADDRESS in ${VM_BRIDGE_IFACE_IP_ADDRESSES}
	do
		# Let's ASSUME that the first and lowest (numerically) IP is the chosen one.
		VM_BRIDGE_IFACE_IP="${IP_ADDRESS}"
		break
	done

	# Get the VM description.
	VM_DESCRIPTION="null"
	while [ "${VM_DESCRIPTION}" = "null" ]
	do
		echo -e ""
		readee -p "${LCYN}Enter the description for the template VM: ${NRML}" VM_DESCRIPTION_TEMP
		# Check that the VM description contains only valid characters.
		test_valid_alpha_numeric_string "${VM_DESCRIPTION_TEMP}" 0 150
		if [ "${VALID_ALPHA_NUMERIC_STRING}" = "yes" ] && [ "${VM_DESCRIPTION_TEMP}" != "null" ]
		then
			question_yes_no "\nYou have entered:\n'${NRML}${VM_DESCRIPTION_TEMP}${LCYN}'\nas the description of this template VM.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VM_DESCRIPTION=${VM_DESCRIPTION_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The VM description is not valid."
			echo -e "       It must contain only letters, numbers and spaces of length between 0 and 150."
			echo -e "       It must not be 'null'.\n"
		fi
	done

	# Get the VM core count.
	VM_NUM_CORES=0
	while [ ${VM_NUM_CORES} -eq 0 ]
	do
		echo -e ""
		readee -p "${LCYN}Enter the number of cores for the template VM: ${NRML}" VM_NUM_CORES_TEMP
		# Check that the VM core count contains only valid numbers.
		test_valid_integer "${VM_NUM_CORES_TEMP}" ${VM_MIN_CORES} ${VM_MAX_CORES}
		if [ "${VALID_INTEGER}" = "yes" ]
		then
			question_yes_no "\nYou have entered '${NRML}${VM_NUM_CORES_TEMP}${LCYN}' as the number of cores to give the VM.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VM_NUM_CORES=${VM_NUM_CORES_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The VM core count can not be '${ORNG}${VM_NUM_CORES}${NRML}'."
			echo -e "       It must contain only numbers of value between ${VM_MIN_CORES} and ${VM_MAX_CORES}.\n"
		fi
	done

	# Get the VM memory size in MegaBytes.
	VM_MEM_SIZE_MB=0
	while [ ${VM_MEM_SIZE_MB} -eq 0 ]
	do
		echo -e ""
		readee -p "${LCYN}Enter the memory size in MB of the template VM: ${NRML}" VM_MEM_SIZE_MB_TEMP
		# Check that the VM memory size contains only valid numbers.
		test_valid_integer "${VM_MEM_SIZE_MB_TEMP}" ${VM_MIN_MEM_SIZE_MB} ${VM_MAX_MEM_SIZE_MB}
		if [ "${VALID_INTEGER}" = "yes" ]
		then
			question_yes_no "\nYou have entered '${NRML}${VM_MEM_SIZE_MB_TEMP}${LCYN}' MB as the VM memory size.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VM_MEM_SIZE_MB=${VM_MEM_SIZE_MB_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The VM memory size can not be '${ORNG}${VM_MEM_SIZE_MB_TEMP}${NRML}'."
			echo -e "       It must contain only numbers of value between ${VM_MIN_MEM_SIZE_MB} and ${VM_MAX_MEM_SIZE_MB}.\n"
		fi
	done

	# TODO: get VM_NIC_DRIVER (e1000|virtio-net).
	VM_NIC_DRIVER="${VM_DEFAULT_NIC_DRIVER}"

	# TODO: get VM_BOOT_LOADER (UEFI|grub).
	VM_BOOT_LOADER="${VM_DEFAULT_BOOT_LOADER}"

	# Ask if the older standard HDD sector size is required.
	question_yes_no "\nDoes the OS disk require a 512 byte sector size? (e.g. Windows 7) [DEFAULT=no]"
	if [ "${ANSWER}" = "yes" ]
	then
		OS_DISK_SECTOR_SIZE="512"
	else
		OS_DISK_SECTOR_SIZE=${VM_DEFAULT_SECTOR_SIZE}
	fi

	# Prompt for the method; install or copy from existing VM image.
	INSTALL_OR_COPY_IMAGE=""
	while [ "${INSTALL_OR_COPY_IMAGE}" = "" ]
	do
		echo -e "\n${LCYN}Do you want to install an OS or copy from an existing image?${NRML}"
		readee -p "${LCYN}(install|copy): ${NRML}" INSTALL_OR_COPY_IMAGE_TEMP
		# Check input validation.
		if [ "${INSTALL_OR_COPY_IMAGE_TEMP}" = "install" ] || [ "${INSTALL_OR_COPY_IMAGE_TEMP}" = "copy" ]
		then
			INSTALL_OR_COPY_IMAGE="${INSTALL_OR_COPY_IMAGE_TEMP}"
		fi
	done

	if [ "${INSTALL_OR_COPY_IMAGE}" = "install" ]
	then
		# Get the VMs' disk size in GigaBytes.
		VM_IMAGE_SIZE_GB=0
		while [ ${VM_IMAGE_SIZE_GB} -eq 0 ]
		do
			echo -e ""
			readee -p "${LCYN}Enter the size in GB of the OS disk image: ${NRML}" VM_IMAGE_SIZE_GB_TEMP
			# Check that the VM disk size contains only numbers.
			test_valid_integer "${VM_IMAGE_SIZE_GB_TEMP}" ${VM_MIN_IMAGE_SIZE_GB} ${VM_MAX_IMAGE_SIZE_GB}
			if [ "${VALID_INTEGER}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${VM_IMAGE_SIZE_GB_TEMP}${LCYN}' GB as the disk image size.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					VM_IMAGE_SIZE_GB=${VM_IMAGE_SIZE_GB_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The disk image size can not be '${ORNG}${VM_IMAGE_SIZE_GB_TEMP}${NRML}'."
				echo -e "       It must contain only numbers of value between ${VM_MIN_IMAGE_SIZE_GB} and ${VM_MAX_IMAGE_SIZE_GB}.\n"
			fi
		done

		# Get the installer ISO path.
		OS_INSTALLER_ISO=""
		while [ "${OS_INSTALLER_ISO}" = "" ]
		do
			# Ask for installer ISO file.
			dialog --title "Select OS installer ISO" --fselect "${VM_RESOURCES_PATH}/" 20 80 2> ${DIALOG_OUT_FILE}
			OS_INSTALLER_ISO_TEMP=`cat ${DIALOG_OUT_FILE}`
			if [ -e "${OS_INSTALLER_ISO_TEMP}" ]
			then
				file "${OS_INSTALLER_ISO_TEMP}" | grep "ISO 9660" > /dev/null
				if [ ${?} -eq 0 ]
				then
					echo -e "\n"
					question_yes_no "\nYou have selected '${NRML}${OS_INSTALLER_ISO_TEMP}${LCYN}' as the OS installer ISO.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						OS_INSTALLER_ISO="${OS_INSTALLER_ISO_TEMP}"
						VM_OS_INSTALL_ISO_FILE=`basename "${OS_INSTALLER_ISO}"`
						break
					fi
				else
					echo -e "\n\n${ORNG}WARNING:${NRML} File selected is not an ISO!\n"
					pause_prompt 8
				fi
			else
				echo -e "\n\n${ORNG}WARNING:${NRML} No file selected!\n"
				question_yes_no "\nWould you like to try again?"
				if [ "${ANSWER}" = "no" ]
				then
					echo -e "\nAborting.\n"
					return 1
				fi
				echo -e ""
			fi
			sleep 4
		done
	fi

	if [ "${INSTALL_OR_COPY_IMAGE}" = "copy" ]
	then
		# Get the existing VM OS image file path.
		EXISTING_IMAGE_PATH=""
		while [ "${EXISTING_IMAGE_PATH}" = "" ]
		do
			# Ask for existing disk image path.
			dialog --title "Select existing disk image (raw)" --fselect "${VM_RESOURCES_PATH}/" 20 80 2> ${DIALOG_OUT_FILE}
			EXISTING_IMAGE_PATH_TEMP=`cat ${DIALOG_OUT_FILE}`
			if [ -e "${EXISTING_IMAGE_PATH_TEMP}" ]
			then
				get_file_size_in_gigabytes "${EXISTING_IMAGE_PATH_TEMP}"
				VM_IMAGE_SIZE_GB=${FILE_SIZE_IN_GB}
				if [ ${VM_IMAGE_SIZE_GB} -gt 0 ]
				then
					file "${EXISTING_IMAGE_PATH_TEMP}" | grep "DOS/MBR boot sector" > /dev/null
					if [ ${?} -ne 0 ]
					then
						echo -e "\n\n${ORNG}WARNING:${NRML} File selected does not appear to be a valid OS disk image!\n"
						pause_prompt 8
					fi
					echo -e "\n"
					question_yes_no "\nYou have selected '${NRML}${EXISTING_IMAGE_PATH_TEMP}${LCYN}' as the existing image file.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						EXISTING_IMAGE_PATH="${EXISTING_IMAGE_PATH_TEMP}"
						break
					fi
				else
					echo -e "\n\n${ORNG}WARNING:${NRML} File selected is less than 1GB, too small!\n"
					pause_prompt 8
				fi
			else
				echo -e "\n\n${ORNG}WARNING:${NRML} No file selected!\n"
				question_yes_no "\nWould you like to try again?"
				if [ "${ANSWER}" = "no" ]
				then
					echo -e "\nAborting.\n"
					return 1
				fi
				echo -e ""
			fi
			sleep 4
		done
	fi

	# Get IP to use for VNC.
	VM_VNC_HOST_IP=""
	NUM_HOST_IP=`echo ${VM_BRIDGE_IFACE_IP_ADDRESSES} | wc -w`
	if [ ${NUM_HOST_IP} -lt 2 ]
	then
		VM_VNC_HOST_IP=${VM_BRIDGE_IFACE_IP_ADDRESSES}
	else
		while [ "${VM_VNC_HOST_IP}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select IP address for VNC access:" 12 60 10 ${VM_BRIDGE_IFACE_IP_ADDRESSES} 2> ${DIALOG_OUT_FILE}
			VM_VNC_HOST_IP_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${VM_VNC_HOST_IP_TEMP}${LCYN}' to use for the VNC session.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VM_VNC_HOST_IP="${VM_VNC_HOST_IP_TEMP}"
				break
			fi
			sleep 4
		done
	fi

	# Get next available VNC port.
	get_next_vnc_port_num
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the next available VNC port number!\n       Aborting."
		return 2
	fi
	VM_VNC_PORT=${VNC_PORT_NUM}

	# Get next available tap interface id.
	VM_TAP_ID=-1
	VM_TAP_ID_TEMP=0
	while [ ${VM_TAP_ID} -lt 0 ]
	do
		ifconfig "tap${VM_TAP_ID_TEMP}" > /dev/null 2>&1
		RESULT1=${?}
		sysrc "cloned_interfaces" | egrep -w "tap${VM_TAP_ID_TEMP}" > /dev/null 2>&1
		RESULT2=${?}
		if [ ${RESULT1} -eq 0 ] || [ ${RESULT2} -eq 0 ]
		then
			VM_TAP_ID_TEMP=$(( ${VM_TAP_ID_TEMP} + 1 ))
		else
			VM_TAP_ID=${VM_TAP_ID_TEMP}
		fi
	done

	# Get VNC screen size (resolution) to use for the VM.
	VM_VNC_SCREEN_SIZE=""
	while [ "${VM_VNC_SCREEN_SIZE}" = "" ]
	do
		dialog --no-items --no-cancel --menu "Select VNC screen size (if unsure, use 1024x768):" 18 60 16 ${VNC_SCREEN_SIZES} 2> ${DIALOG_OUT_FILE}
		VM_VNC_SCREEN_SIZE_TEMP=`cat ${DIALOG_OUT_FILE}`
		echo -e "\n"
		question_yes_no "\nYou have selected '${NRML}${VM_VNC_SCREEN_SIZE_TEMP}${LCYN}' as the VMs' VNC screen size.\nIs this correct?"
		if [ "${ANSWER}" = "yes" ]
		then
			VM_VNC_SCREEN_SIZE="${VM_VNC_SCREEN_SIZE_TEMP}"
			break
		fi
		sleep 4
	done

	# Get the VMs' VNC password.
	VM_VNC_PASSWORD="null"
	while [ "${VM_VNC_PASSWORD}" = "null" ]
	do
		echo -e ""
		readee -p "${LCYN}Enter the password for the VMs' VNC session: ${NRML}" VM_VNC_PASSWORD_TEMP
		# Check that the VMs' VNC password contains only valid characters.
		test_valid_alpha_numeric_string "${VM_VNC_PASSWORD_TEMP}" 3 20
		if [ "${VALID_ALPHA_NUMERIC_STRING}" = "yes" ] && [ "${VM_VNC_PASSWORD_TEMP}" != "null" ]
		then
			question_yes_no "\nYou have entered:\n'${NRML}${VM_VNC_PASSWORD_TEMP}${LCYN}'\nas the VNC password of this template VM.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VM_VNC_PASSWORD=${VM_VNC_PASSWORD_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The VMs' VNC password is not valid."
			echo -e "       It must contain only letters, numbers and spaces of length between 3 and 20."
			echo -e "       It must not be 'null'.\n"
		fi
	done

	VM_VNC_SCREEN_WIDTH=`echo "${VM_VNC_SCREEN_SIZE}" | cut -dx -f1`
	VM_VNC_SCREEN_HEIGHT=`echo "${VM_VNC_SCREEN_SIZE}" | cut -dx -f2`
	VM_TAP_IFACE="tap${VM_TAP_ID}"
	VM_BRIDGE_IFACE="bridge${VM_BRIDGE_ID}"

	# DEBUG info.
	if [ ${DEBUG} = true ]
	then
		echo -e "\nDEBUG info:\n"
		echo -e "VM_NAME=${VM_NAME}"
		echo -e "VM_TEMPLATE_DESCRIPTION=${VM_TEMPLATE_DESCRIPTION}"
		echo -e "VM_INDEX=${VM_INDEX}"
		echo -e "VM_TAP_IFACE=${VM_TAP_IFACE}"
		echo -e "VM_BRIDGE_IFACE=${VM_BRIDGE_IFACE}"
		echo -e "VM_NUM_CORES=${VM_NUM_CORES}"
		echo -e "VM_MEM_SIZE_MB=${VM_MEM_SIZE_MB}"
		echo -e "VM_IMAGE_SIZE_GB=${VM_IMAGE_SIZE_GB}"
		echo -e "OS_DISK_SECTOR_SIZE=${OS_DISK_SECTOR_SIZE}"
		echo -e "VM_BRIDGE_IFACE_IP=${VM_BRIDGE_IFACE_IP}"
		echo -e "VM_VNC_HOST_IP=${VM_VNC_HOST_IP}"
		echo -e "VM_VNC_PORT=${VM_VNC_PORT}"
		echo -e "VM_VNC_SCREEN_WIDTH=${VM_VNC_SCREEN_WIDTH}"
		echo -e "VM_VNC_SCREEN_HEIGHT=${VM_VNC_SCREEN_HEIGHT}"
		echo -e "VM_VNC_PASSWORD=${VM_VNC_PASSWORD}"
	fi

	CREATE_VM_TEMPLATE_MODIFIED=true

	echo -e "\n${YELL}Creating new template VM...${NRML}\n"

	# Create new tap interface and add it to the VM bridge.
	ifconfig ${VM_TAP_IFACE} create > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	ifconfig ${VM_BRIDGE_IFACE} addm ${VM_TAP_IFACE} > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to configure the network for the template VM!\n"
		undo_create_vm_template
		return 2
	fi

	# Create ZFS filesystem for VM images.
	VM_FS_MOUNTPOINT_STRING=`zfs get -H mountpoint ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME} 2> /dev/null`
	if [ ${?} -ne 0 ]
	then
		# ZFS filesystem doesn't yet exist, so let's create it.
		echo -e "\n${YELL}Creating ZFS filesystem for the template VM OS image...${NRML}\n"
		zfs create ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME} 2> /dev/null
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		VM_FS_MOUNTPOINT_STRING=`zfs get -H mountpoint ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME} 2> /dev/null`
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	else
		echo -e "\n${YELL}ZFS filesystem for the template VM image already exists...${NRML}\n"
	fi

	# Get the ZFS filesystem mountpoint, and see if it has the expected mountpoint.
	EXPECTED_VM_FS_MOUNTPOINT="${VMS_ROOT_PATH}/${VM_TYPE_DIRNAME}/${VM_NAME}"
	VM_FS_MOUNTPOINT=`echo ${VM_FS_MOUNTPOINT_STRING} | awk '{print $3}'`
	if [ "${VM_FS_MOUNTPOINT}" != "${EXPECTED_VM_FS_MOUNTPOINT}" ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The VM filesystem has an unexpected mountpoint!\n"
	fi

	# Add VM network configuration to '/etc/rc.conf'.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf cloned_interfaces+="${VM_TAP_IFACE}" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sysrc -f configs/${HOST_NAME}/etc/rc.conf ifconfig_${VM_BRIDGE_IFACE}+="addm ${VM_TAP_IFACE}" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Add VM configuration to 'vms.conf'.
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} -t object .templates.${VM_INDEX} "{ name = \"${VM_NAME}\"; }"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.cores "${VM_NUM_CORES}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.memory_size "${VM_MEM_SIZE_MB}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.description "${VM_DESCRIPTION}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.path "${VM_FS_MOUNTPOINT}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.tap_interface "${VM_TAP_IFACE}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.nic_driver "${VM_NIC_DRIVER}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.boot_loader "${VM_BOOT_LOADER}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.vnc_enabled "enabled"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.vnc_ipv4_address "${VM_VNC_HOST_IP}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.vnc_port "${VM_VNC_PORT}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.vnc_width "${VM_VNC_SCREEN_WIDTH}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.vnc_height "${VM_VNC_SCREEN_HEIGHT}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.vnc_password "${VM_VNC_PASSWORD}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} -t array .templates.${VM_INDEX}.images "[ { type = \"ahci-hd\"; } ]"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.images.0.filename  "os_disk.img"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.images.0.sectorsize  "${OS_DISK_SECTOR_SIZE}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Prepare OS disk images.
	if [ "${INSTALL_OR_COPY_IMAGE}" = "install" ]
	then
		# Create the new VMs' disk image.
		truncate -s "${VM_IMAGE_SIZE_GB}G" "${VM_FS_MOUNTPOINT}/os_disk.img"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		if [ "${OS_INSTALLER_ISO}" != "${VM_RESOURCES_PATH}/${VM_OS_INSTALL_ISO_FILE}" ]
		then
			cp "${OS_INSTALLER_ISO}" "${VM_RESOURCES_PATH}/${VM_OS_INSTALL_ISO_FILE}" > /dev/null 2>&1
			if [ ${?} -ne 0 ]
			then
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
				echo -e "\n${ORNG}WARNING:${NRML} There was a problem copying the OS installer ISO\n         to the resources filesystem!\n"
			fi
		fi

		# Add the installer ISO image as an ahci-cd device in the vms.conf file.
		${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} -t object .templates.${VM_INDEX}.images.1 "{ type = \"ahci-cd\"; }"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_INDEX}.images.1.filename  "${VM_OS_INSTALL_ISO_FILE}"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ "${INSTALL_OR_COPY_IMAGE}" = "copy" ]
	then
		# Copy the existing template VM OS image to the template VM filesystem.
		echo -e "\n${YELL}Copying existing VM OS image to the template VM filesystem...${NRML}\n"
		cp "${EXISTING_IMAGE_PATH}" "${VM_FS_MOUNTPOINT}/os_disk.img"
		if [ ${?} -ne 0 ]
		then
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			echo -e "\n${ORNG}WARNING:${NRML} There was a problem copying the existing VM OS image\n         to the template VM filesystem!\n"
		fi
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong during disk/ISO image preparation!\n"
		undo_create_vm_template
		return 2
	fi

	# Start template VM for the first time.
	echo -e "\n${YELL}Starting template VM '${NRML}${VM_NAME}${YELL}' for the first time...${NRML}\n"
	VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-start "${VM_NAME}" --wait

	# Inform user that next step is to login via VNC to the template and perform the installation / configuration.
	echo -e "\n${YELL}The template VM should now be running.${NRML}"
	if [ "${INSTALL_OR_COPY_IMAGE}" = "install" ]
	then
		echo -e "${YELL}The OS installer ISO should also be attached and ready to boot ${NRML}"
		echo -e "${YELL}into the installation environment.${NRML}"
		echo -e "${YELL}You should now connect via VNC and install the VM OS, ${NRML}"
		echo -e "${YELL}then reboot it when finished.${NRML}\n"
	fi
	if [ "${INSTALL_OR_COPY_IMAGE}" = "copy" ]
	then
		echo -e "${YELL}The OS disk image should be copied and ready to boot. ${NRML}"
		echo -e "${YELL}You should now connect via VNC and configure the VM OS, ${NRML}"
		echo -e "${YELL}then reboot it when finished.${NRML}\n"
	fi
	echo -e "${YELL}Connect to the template VM using a VNC viewer ${NRML}"
	echo -e "${YELL}(e.g. TigerVNC or SSVNC) using the following:${NRML}\n"
	echo -e "${LGRN}VNC URI:      ${VM_VNC_HOST_IP}:${VM_VNC_PORT}${NRML}"
	echo -e "${LGRN}VNC Password: ${VM_VNC_PASSWORD}${NRML}\n"

	pause_prompt 16

	# Recursive ISO and disk image handler, for use in preparing the VM.
	create_vm_image_handler
	EXIT_CODE=${?}
	if [ ${EXIT_CODE} -ne 0 ]
	then
		undo_create_vm_template
		return ${EXIT_CODE}
	fi

	# The template VM preparation is finished, let's shutdown and save the template for use.
	echo -e "${YELL}\nPlease try to shutdown the VM gracefully, if possible.${NRML}\n"
	question_yes "Proceed?"

	# Stop the template VM.
	VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-stop "${VM_NAME}" --force

	# Snapshot the template VM for use by 'create-vm-instance'.
	zfs snapshot -r ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME}@latest
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong trying to snapshot the template VM filesystem!\n"
		undo_create_vm_template
		return 2
	fi

	# Install host configs to the system.
	install_file_tree configs/${HOST_NAME} /

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'create-vm-template ${VM_NAME}'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
		git_push origin master
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
			echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! The template VM '${NRML}${VM_NAME}${LGRN}'${NRML}"
	echo -e "${LGRN}is ready to use.${NRML}\n"
	echo -e "${YELL}To create a new VM, use the command:${NRML}"
	echo -e "${LBLU}${SCRIPT_NAME} create-vm-instance${NRML}\n"

	return 0
}

create_vm_instance ()
{

	VM_TEMPLATE_NAME="${1}"
	VM_NAME="${2}"
	VM_TYPE="instance"
	VM_TYPE_DIRNAME="${VM_INSTANCES_DIRNAME}"
	CREATE_VM_INSTANCE_MODIFIED=false

	trap 'undo_create_vm_instance ; exit 3' HUP INT QUIT KILL TERM

	# Save git commit reference so we can roll back changes later.
	COMMIT_BEFORE_CREATE_VM_INSTANCE=`git log --format=format:%H -1`

	ERROR_COUNT=0

	# Check that the instance name is valid.
	test_valid_vm_name "${VM_NAME}"
	if [ "${VALID_VM_NAME}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The instance name can not be '${ORNG}${VM_NAME}${NRML}'."
		echo -e "       It must only contain letters, numbers and underscores."
		echo -e "       It must not begin or end with an underscore."
		echo -e "       It must be between 3 and 30 characters in length."
		echo -e "       Aborting.\n"
		return 1
	fi

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the '${LBLU}init-host${NRML}' subcommand first.\n       Aborting.\n"
		return 1
	fi

	# Check for unsaved registered host config files.
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent > /dev/null 2>&1
	if [ ${?} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the '${LBLU}check-configs${NRML}' subcommand to see what's out-of-date."
		echo -e "       Please use the '${LBLU}update-config${NRML}' subcommand to keep the repo up-to-date.\n       Aborting.\n"
		return 1
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Check that the host.conf file is accessible.
	TEST_CONTENTS=`${UCL_CMD} get -u -f ${HOST_CONF_PATH} .general 2>&1`
	if [ ${?} -ne 0 ] || [ "${TEST_CONTENTS}" = "null" ] || [ "${TEST_CONTENTS}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to access the config file '${HOST_CONF_PATH}'!\n       Aborting.\n"
		return 2
	fi

	# Check that the vms.conf file is accessible.
	TEST_CONTENTS=`${UCL_CMD} get -u -f ${VMS_CONF_PATH} .general 2>&1`
	if [ ${?} -ne 0 ] || [ "${TEST_CONTENTS}" = "null" ] || [ "${TEST_CONTENTS}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to access the config file '${VMS_CONF_PATH}'!\n       Aborting.\n"
		return 2
	fi

	# Check that the VMs subsystem is initialised.
	VMS_SUBSYS_COMPAT=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .subsystems.vms_compat`
	if [ ${?} -ne 0 ] || [ "${VMS_SUBSYS_COMPAT}" = "null" ] || [ "${VMS_SUBSYS_COMPAT}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the VMs subsystem is not initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} init-vms${NRML}\n       Aborting.\n"
		return 1
	fi

	# Get the VMs pool name from the host config file.
	VMS_POOL_NAME=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .storage.vms_pool`
	if [ ${?} -ne 0 ] || [ "${VMS_POOL_NAME}" = "null" ] || [ "${VMS_POOL_NAME}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the VMs pool name from the host config file!\n       Aborting.\n"
		return 2
	fi

	# Check that the template exists.
	VM_TEMPLATE_EXISTS=false
	VM_TEMPLATE_INDEX=0
	while [ `${UCL_CMD} get -f ${VMS_CONF_PATH} -q .templates.${VM_TEMPLATE_INDEX}` != "null" ]
	do
		TEST_TEMPLATE_NAME=`${UCL_CMD} get -f ${VMS_CONF_PATH} -q .templates.${VM_TEMPLATE_INDEX}.name`
		if [ "${VM_TEMPLATE_NAME}" = "${TEST_TEMPLATE_NAME}" ]
		then
			VM_TEMPLATE_EXISTS=true
			# We don't want to iterate VM_TEMPLATE_INDEX anymore.
			break
		fi
		VM_TEMPLATE_INDEX=$(( ${VM_TEMPLATE_INDEX} + 1 ))
	done
	if [ ${VM_TEMPLATE_EXISTS} = false ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The template VM '${ORNG}${VM_TEMPLATE_NAME}${NRML}' does not exist on this host.\n"
		echo -e "       Aborting.\n"
		return 1
	fi

	# Check that the instance name is not already used.
	VM_INDEX=0
	while [ `${UCL_CMD} get -f ${VMS_CONF_PATH} -q .instances.${VM_INDEX}` != "null" ]
	do
		TEST_INSTANCE_NAME=`${UCL_CMD} get -f ${VMS_CONF_PATH} -q .instances.${VM_INDEX}.name`
		if [ "${VM_NAME}" = "${TEST_INSTANCE_NAME}" ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The instance '${ORNG}${VM_NAME}${NRML}' already exists.\n"
			echo -e "       To delete it, use the command:"
			echo -e "       ${LBLU}${SCRIPT_NAME} destroy-vm-instance ${VM_NAME}${NRML}\n"
			echo -e "       Aborting.\n"
			return 1
		fi
		VM_INDEX=$(( ${VM_INDEX} + 1 ))
	done

	# Check that the template ZFS filesystem exists.
	zfs list -H ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TEMPLATES_DIRNAME}/${VM_TEMPLATE_NAME} > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The template VM filesystem: "
		echo -e "       ${ORNG}${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TEMPLATES_DIRNAME}/${VM_TEMPLATE_NAME}${NRML}"
		echo -e "       does not exist!"
		echo -e "       Aborting.\n"
		return 1
	fi

	# Check that the instance ZFS filesystem does not already exist.
	VM_FS_MOUNTPOINT_STRING=`zfs get -H mountpoint ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME} 2> /dev/null`
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The instance VM filesystem: "
		echo -e "       ${ORNG}${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME}${NRML}"
		echo -e "       already exists. To delete it, use the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} destroy-vm-instance ${VM_NAME}${NRML}\n"
		echo -e "       Aborting.\n"
		return 1
	fi

	# Get the bridge id from the VMs config file.
	VM_BRIDGE_ID=`${UCL_CMD} get -f ${VMS_CONF_PATH} -q .network.bridge_id_num`
	if [ ${?} -ne 0 ] || [ "${VM_BRIDGE_ID}" = "null" ] || [ "${VM_BRIDGE_ID}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the VMs bridge id number from the VMs config file!\n       Aborting.\n"
		return 2
	fi

	# Get the bridge net interface (NIC) name from the VMs config file.
	VM_BRIDGE_NET_IFACE=`${UCL_CMD} get -f ${VMS_CONF_PATH} -q .network.bridge_nic_id`
	if [ ${?} -ne 0 ] || [ "${VM_BRIDGE_NET_IFACE}" = "null" ] || [ "${VM_BRIDGE_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the VMs bridge NIC id from the VMs config file!\n       Aborting.\n"
		return 2
	fi

	# Get the network interface used for the bridge interface.
	VM_BRIDGE_IFACE_IP_ADDRESSES=`ifconfig ${VM_BRIDGE_NET_IFACE} | egrep "inet.*netmask" | awk '{print $2}' | sort`

	# Exit if the bridge network interface has no IP addresses.
	if [ "${VM_BRIDGE_IFACE_IP_ADDRESSES}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The bridge network interface '${ORNG}${VM_BRIDGE_NET_IFACE}${NRML}' does not have any IP addresses!\n       Aborting.\n"
		return 1
	fi

	# Get the IP address of the bridge network interface.
	for IP_ADDRESS in ${VM_BRIDGE_IFACE_IP_ADDRESSES}
	do
		# Let's ASSUME that the first and lowest (numerically) IP is the chosen one.
		VM_BRIDGE_IFACE_IP="${IP_ADDRESS}"
		break
	done

	# Get the VM description.
	VM_DESCRIPTION="null"
	while [ "${VM_DESCRIPTION}" = "null" ]
	do
		echo -e ""
		readee -p "${LCYN}Enter the description for the VM instance: ${NRML}" VM_DESCRIPTION_TEMP
		# Check that the VM description contains only valid characters.
		test_valid_alpha_numeric_string "${VM_DESCRIPTION_TEMP}" 0 150
		if [ "${VALID_ALPHA_NUMERIC_STRING}" = "yes" ] && [ "${VM_DESCRIPTION_TEMP}" != "null" ]
		then
			question_yes_no "\nYou have entered:\n'${NRML}${VM_DESCRIPTION_TEMP}${LCYN}'\nas the description of this VM instance.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VM_DESCRIPTION=${VM_DESCRIPTION_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The VM description is not valid."
			echo -e "       It must contain only letters, numbers and spaces of length between 0 and 150."
			echo -e "       It must not be 'null'.\n"
		fi
	done
	
	# Get the VM core count.
	VM_NUM_CORES=0
	while [ ${VM_NUM_CORES} -eq 0 ]
	do
		echo -e ""
		readee -p "${LCYN}Enter the number of cores for the VM instance: ${NRML}" VM_NUM_CORES_TEMP
		# Check that the VM core count contains only valid numbers.
		test_valid_integer "${VM_NUM_CORES_TEMP}" ${VM_MIN_CORES} ${VM_MAX_CORES}
		if [ "${VALID_INTEGER}" = "yes" ]
		then
			question_yes_no "\nYou have entered '${NRML}${VM_NUM_CORES_TEMP}${LCYN}' as the number of cores to give the VM.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VM_NUM_CORES=${VM_NUM_CORES_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The VM core count can not be '${ORNG}${VM_NUM_CORES}${NRML}'."
			echo -e "       It must contain only numbers of value between ${VM_MIN_CORES} and ${VM_MAX_CORES}.\n"
		fi
	done

	# Get the VM memory size in MegaBytes.
	VM_MEM_SIZE_MB=0
	while [ ${VM_MEM_SIZE_MB} -eq 0 ]
	do
		echo -e ""
		readee -p "${LCYN}Enter the memory size in MB of the VM instance: ${NRML}" VM_MEM_SIZE_MB_TEMP
		# Check that the VM memory size contains only valid numbers.
		test_valid_integer "${VM_MEM_SIZE_MB_TEMP}" ${VM_MIN_MEM_SIZE_MB} ${VM_MAX_MEM_SIZE_MB}
		if [ "${VALID_INTEGER}" = "yes" ]
		then
			question_yes_no "\nYou have entered '${NRML}${VM_MEM_SIZE_MB_TEMP}${LCYN}' MB as the VM memory size.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VM_MEM_SIZE_MB=${VM_MEM_SIZE_MB_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The VM memory size can not be '${ORNG}${VM_MEM_SIZE_MB_TEMP}${NRML}'."
			echo -e "       It must contain only numbers of value between ${VM_MIN_MEM_SIZE_MB} and ${VM_MAX_MEM_SIZE_MB}.\n"
		fi
	done

	# TODO: get VM_NIC_DRIVER (e1000|virtio-net).
	VM_NIC_DRIVER="${VM_DEFAULT_NIC_DRIVER}"

	# TODO: get VM_BOOT_LOADER (UEFI|grub).
	VM_BOOT_LOADER="${VM_DEFAULT_BOOT_LOADER}"

	# Get IP to use for VNC.
	VM_VNC_HOST_IP=""
	NUM_HOST_IP=`echo ${VM_BRIDGE_IFACE_IP_ADDRESSES} | wc -w`
	if [ ${NUM_HOST_IP} -lt 2 ]
	then
		VM_VNC_HOST_IP=${VM_BRIDGE_IFACE_IP_ADDRESSES}
	else
		while [ "${VM_VNC_HOST_IP}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select IP address for VNC access:" 12 60 10 ${VM_BRIDGE_IFACE_IP_ADDRESSES} 2> ${DIALOG_OUT_FILE}
			VM_VNC_HOST_IP_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${VM_VNC_HOST_IP_TEMP}${LCYN}' to use for the VNC session.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VM_VNC_HOST_IP="${VM_VNC_HOST_IP_TEMP}"
				break
			fi
			sleep 4
		done
	fi

	# Get next available VNC port.
	get_next_vnc_port_num
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the next available VNC port number!\n       Aborting."
		return 2
	fi
	VM_VNC_PORT=${VNC_PORT_NUM}

	# Get next available tap interface id.
	VM_TAP_ID=-1
	VM_TAP_ID_TEMP=0
	while [ ${VM_TAP_ID} -lt 0 ]
	do
		ifconfig "tap${VM_TAP_ID_TEMP}" > /dev/null 2>&1
		RESULT1=${?}
		sysrc "cloned_interfaces" | egrep -w "tap${VM_TAP_ID_TEMP}" > /dev/null 2>&1
		RESULT2=${?}
		if [ ${RESULT1} -eq 0 ] || [ ${RESULT2} -eq 0 ]
		then
			VM_TAP_ID_TEMP=$(( ${VM_TAP_ID_TEMP} + 1 ))
		else
			VM_TAP_ID=${VM_TAP_ID_TEMP}
		fi
	done

	# Get VNC screen size (resolution) to use for the VM.
	VM_VNC_SCREEN_SIZE=""
	while [ "${VM_VNC_SCREEN_SIZE}" = "" ]
	do
		dialog --no-items --no-cancel --menu "Select VNC screen size (if unsure, use 1024x768):" 18 60 16 ${VNC_SCREEN_SIZES} 2> ${DIALOG_OUT_FILE}
		VM_VNC_SCREEN_SIZE_TEMP=`cat ${DIALOG_OUT_FILE}`
		echo -e "\n"
		question_yes_no "\nYou have selected '${NRML}${VM_VNC_SCREEN_SIZE_TEMP}${LCYN}' as the VMs' VNC screen size.\nIs this correct?"
		if [ "${ANSWER}" = "yes" ]
		then
			VM_VNC_SCREEN_SIZE="${VM_VNC_SCREEN_SIZE_TEMP}"
			break
		fi
		sleep 4
	done

	# Get the VMs' VNC password.
	VM_VNC_PASSWORD="null"
	while [ "${VM_VNC_PASSWORD}" = "null" ]
	do
		echo -e ""
		readee -p "${LCYN}Enter the password for the VMs' VNC session: ${NRML}" VM_VNC_PASSWORD_TEMP
		# Check that the VMs' VNC password contains only valid characters.
		test_valid_alpha_numeric_string "${VM_VNC_PASSWORD_TEMP}" 3 20
		if [ "${VALID_ALPHA_NUMERIC_STRING}" = "yes" ] && [ "${VM_VNC_PASSWORD_TEMP}" != "null" ]
		then
			question_yes_no "\nYou have entered:\n'${NRML}${VM_VNC_PASSWORD_TEMP}${LCYN}'\nas the VNC password of this instance VM.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VM_VNC_PASSWORD=${VM_VNC_PASSWORD_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The VMs' VNC password is not valid."
			echo -e "       It must contain only letters, numbers and spaces of length between 3 and 20."
			echo -e "       It must not be 'null'.\n"
		fi
	done

	VM_VNC_SCREEN_WIDTH=`echo "${VM_VNC_SCREEN_SIZE}" | cut -dx -f1`
	VM_VNC_SCREEN_HEIGHT=`echo "${VM_VNC_SCREEN_SIZE}" | cut -dx -f2`
	VM_TAP_IFACE="tap${VM_TAP_ID}"
	VM_BRIDGE_IFACE="bridge${VM_BRIDGE_ID}"

	# DEBUG info.
	if [ ${DEBUG} = true ]
	then
		echo -e "\nDEBUG info:\n"
		echo -e "VM_NAME=${VM_NAME}"
		echo -e "VM_TEMPLATE_NAME=${VM_TEMPLATE_NAME}"
		echo -e "VM_DESCRIPTION=${VM_DESCRIPTION}"
		echo -e "VM_INDEX=${VM_INDEX}"
		echo -e "VM_TEMPLATE_INDEX=${VM_TEMPLATE_INDEX}"
		echo -e "VM_TAP_IFACE=${VM_TAP_IFACE}"
		echo -e "VM_BRIDGE_IFACE=${VM_BRIDGE_IFACE}"
		echo -e "VM_NUM_CORES=${VM_NUM_CORES}"
		echo -e "VM_MEM_SIZE_MB=${VM_MEM_SIZE_MB}"
		echo -e "VM_BRIDGE_IFACE_IP=${VM_BRIDGE_IFACE_IP}"
		echo -e "VM_VNC_HOST_IP=${VM_VNC_HOST_IP}"
		echo -e "VM_VNC_PORT=${VM_VNC_PORT}"
		echo -e "VM_VNC_SCREEN_WIDTH=${VM_VNC_SCREEN_WIDTH}"
		echo -e "VM_VNC_SCREEN_HEIGHT=${VM_VNC_SCREEN_HEIGHT}"
		echo -e "VM_VNC_PASSWORD=${VM_VNC_PASSWORD}"
	fi

	# Make sure the template VM is shutdown first.
	VM_TEMPLATE_RUN_STATE=`fdo-vms-list --concise --type=template | egrep "${VM_TEMPLATE_NAME}" | awk '{print $2}'`
	if [ "${VM_TEMPLATE_RUN_STATE}" != "stopped" ]
	then
		# Prompt to shutdown template VM gracefully.
		echo -e "\n${YELL}Please try to shutdown the template VM gracefully, if possible.${NRML}\n"
		question_yes "Proceed?"

		# Stop the template VM.
		VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-stop "${VM_TEMPLATE_NAME}" --force
	fi

	CREATE_VM_INSTANCE_MODIFIED=true

	echo -e "\n${YELL}Creating new instance VM...${NRML}\n"

	# Create new tap interface and add it to the VM bridge.
	ifconfig ${VM_TAP_IFACE} create > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	ifconfig ${VM_BRIDGE_IFACE} addm ${VM_TAP_IFACE} > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to configure the network for the instance VM!\n"
		undo_create_vm_instance
		return 2
	fi

	# Create instance VM filesystem by cloning from it's template VM.
	echo -e "\n${YELL}Creating ZFS filesystem for the instance VM OS image...${NRML}\n"
	zfs clone ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TEMPLATES_DIRNAME}/${VM_TEMPLATE_NAME}@latest ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME} 2> /dev/null
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	VM_FS_MOUNTPOINT_STRING=`zfs get -H mountpoint ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME} 2> /dev/null`
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Get the ZFS filesystem mountpoint, and see if it has the expected mountpoint.
	EXPECTED_VM_FS_MOUNTPOINT="${VMS_ROOT_PATH}/${VM_TYPE_DIRNAME}/${VM_NAME}"
	VM_FS_MOUNTPOINT=`echo ${VM_FS_MOUNTPOINT_STRING} | awk '{print $3}'`
	if [ "${VM_FS_MOUNTPOINT}" != "${EXPECTED_VM_FS_MOUNTPOINT}" ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The VM filesystem has an unexpected mountpoint!\n"
	fi

	# Add VM network configuration to '/etc/rc.conf'.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf cloned_interfaces+="${VM_TAP_IFACE}" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	sysrc -f configs/${HOST_NAME}/etc/rc.conf ifconfig_${VM_BRIDGE_IFACE}+="addm ${VM_TAP_IFACE}" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Add VM configuration to 'vms.conf'.
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} -t object .instances.${VM_INDEX} "{ name = \"${VM_NAME}\"; }"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.cores "${VM_NUM_CORES}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.memory_size "${VM_MEM_SIZE_MB}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.description "${VM_DESCRIPTION}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.path "${VM_FS_MOUNTPOINT}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.tap_interface "${VM_TAP_IFACE}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.nic_driver "${VM_NIC_DRIVER}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.boot_loader "${VM_BOOT_LOADER}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.vnc_enabled "enabled"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.vnc_ipv4_address "${VM_VNC_HOST_IP}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.vnc_port "${VM_VNC_PORT}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.vnc_width "${VM_VNC_SCREEN_WIDTH}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.vnc_height "${VM_VNC_SCREEN_HEIGHT}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.vnc_password "${VM_VNC_PASSWORD}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	EXISTING_IMAGES_UCL=`${UCL_CMD} get -u -f configs/${HOST_NAME}${VMS_CONF_PATH} .templates.${VM_TEMPLATE_INDEX}.images`
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} -t array .instances.${VM_INDEX}.images "${EXISTING_IMAGES_UCL}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))


	IMAGE_1_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.1.type`
	IMAGE_1_FILENAME=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.1.filename`
	IMAGE_2_TYPE=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.2.type`
	IMAGE_2_FILENAME=`${UCL_CMD} get -f configs/${HOST_NAME}${VMS_CONF_PATH} -q .${VM_TYPE}s.${VM_INDEX}.images.2.filename`

	if [ "${IMAGE_1_TYPE}" = "ahci-hd" ]
	then
		IMAGE_NAME=`echo ${IMAGE_1_FILENAME} | cut -d/ -f1`
		zfs clone ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TEMPLATES_DIRNAME}/${VM_TEMPLATE_NAME}/${IMAGE_NAME}@latest \
		${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME}/${IMAGE_NAME} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ "${IMAGE_2_TYPE}" = "ahci-hd" ]
	then
		IMAGE_NAME=`echo ${IMAGE_2_FILENAME} | cut -d/ -f1`
		zfs clone ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TEMPLATES_DIRNAME}/${VM_TEMPLATE_NAME}/${IMAGE_NAME}@latest \
		${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME}/${IMAGE_NAME} > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong during disk/ISO image preparation!\n"
		undo_create_vm_instance
		return 2
	fi

	# Start instance VM for the first time.
	echo -e "\n${YELL}Starting instance VM '${ORNG}${VM_NAME}${NRML}' for the first time...${NRML}\n"
	VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-start "${VM_NAME}" --wait

	# Inform user that next step is to login via VNC to the instance VM and perform configuration.
	echo -e "\n${YELL}The instance VM should now be running and ready to boot.${NRML}"
	echo -e "${YELL}You should now connect via VNC and configure the VM,${NRML}"
	echo -e "${YELL}then reboot it when finished.${NRML}\n"
	echo -e "${YELL}Connect to the instance VM using a VNC viewer ${NRML}"
	echo -e "${YELL}(e.g. TigerVNC or SSVNC) using the following:${NRML}\n"
	echo -e "${LGRN}VNC URI:      ${VM_VNC_HOST_IP}:${VM_VNC_PORT}${NRML}"
	echo -e "${LGRN}VNC Password: ${VM_VNC_PASSWORD}${NRML}\n"

	pause_prompt 16

	# Recursive ISO and disk image handler, for use in preparing the VM.
	create_vm_image_handler
	EXIT_CODE=${?}
	if [ ${EXIT_CODE} -ne 0 ]
	then
		undo_create_vm_instance
		return ${EXIT_CODE}
	fi

	# The instance VM preparation is finished, let's shutdown and save the instance for use.
	echo -e "${YELL}\nPlease try to shutdown the VM gracefully, if possible.${NRML}\n"
	question_yes "Proceed?"

	# Stop the instance VM.
	VMS_CONF_PATH="configs/${HOST_NAME}/${VMS_CONF_PATH}" fdo-vms-stop "${VM_NAME}" --force

	# Ask whether to disable VNC for production use.
	question_yes_no "Would you like to disable VNC on this VM for production use?"
	if [ "${ANSWER}" = "yes" ]
	then
		${UCL_CMD} set -f configs/${HOST_NAME}${VMS_CONF_PATH} .instances.${VM_INDEX}.vnc_enabled "disabled"
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Snapshot the instance VM for later maintenance.
	zfs snapshot -r ${VMS_POOL_NAME}/${VMS_ROOT_FS}/${VM_TYPE_DIRNAME}/${VM_NAME}@initial
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong trying to snapshot the instance VM filesystem!\n"
		undo_create_vm_instance
		return 2
	fi

	# Install host configs to the system.
	install_file_tree configs/${HOST_NAME} /

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'create-vm-instance ${VM_NAME}'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
		git_push origin master
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
			echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! The instance VM '${NRML}${VM_NAME}${LGRN}'${NRML}"
	echo -e "${LGRN}is ready to use.${NRML}\n"
	echo -e "${YELL}To start the new VM, use the command:${NRML}"
	echo -e "${LBLU}fdo-vms-start ${VM_NAME}${NRML}\n"

	return 0
}

undo_init_partimag ()
{

	ERROR_COUNT=0

	# Stop any previously stopped services.
	if [ ${INIT_PARTIMAG_NFSD_START} = true ]
	then
		service nfsd stop > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_PARTIMAG_MOUNTD_START} = true ]
	then
		service mountd stop > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_PARTIMAG_LOCKD_START} = true ]
	then
		service lockd stop > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	if [ ${INIT_PARTIMAG_RPCBIND_START} = true ]
	then
		service rpcbind stop > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Undo host system modifications.
	if [ ${INIT_PARTIMAG_MODIFIED} = true ]
	then
		# Roll back local repo to last good commit (!!!DANGEROUS!!!).
		if [ "${COMMIT_BEFORE_INIT_PARTIMAG}" != "" ]
		then
			git reset --hard ${COMMIT_BEFORE_INIT_PARTIMAG}
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi

		# Install back old host configs.
		install_file_tree configs/${HOST_NAME} /
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

		# Restore any backed up system files.
		if [ "${ETC_EXPORTS_BACKUP_FILE}" != "" ]
		then
			mv "${ETC_EXPORTS_BACKUP_FILE}" "/etc/exports"
			ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
		fi
	fi

	# Reload any previously reloaded services.
	if [ ${INIT_PARTIMAG_MOUNTD_RELOAD} = true ]
	then
		service mountd reload > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Destroy any created filesystems.
	if [ ${INIT_PARTIMAG_FILESYSTEMS_CREATED} = true ]
	then
		# Destroy the partimag filesystem.
		zfs destroy -rf ${PARTIMAG_POOL_NAME}/partimag > /dev/null 2>&1
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} There was at least one unexpected error undoing the init-partimag process!\n"
		return 2
	fi

	echo -e "\nAborting.\n"
	return 0
}

init_partimag ()
{

	INIT_PARTIMAG_MODIFIED=false
	INIT_PARTIMAG_FILESYSTEMS_CREATED=false
	INIT_PARTIMAG_RPCBIND_START=false
	INIT_PARTIMAG_LOCKD_START=false
	INIT_PARTIMAG_MOUNTD_START=false
	INIT_PARTIMAG_MOUNTD_RELOAD=false
	INIT_PARTIMAG_NFSD_START=false

	trap 'undo_init_partimag ; exit 3' HUP INT QUIT KILL TERM

	# Save git commit reference so we can roll back changes later.
	COMMIT_BEFORE_INIT_PARTIMAG=`git log --format=format:%H -1`

	ERROR_COUNT=0

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo!"
		echo -e "       Please use the '${LBLU}init-host${NRML}' subcommand first.\n       Aborting.\n"
		return 1
	fi

	# Check for unsaved registered host config files.
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent > /dev/null 2>&1
	if [ ${?} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the '${LBLU}check-configs${NRML}' subcommand to see what's out-of-date."
		echo -e "       Please use the '${LBLU}update-config${NRML}' subcommand to keep the repo up-to-date.\n       Aborting.\n"
		return 1
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Check that the host.conf file is accessible.
	TEST_CONTENTS=`${UCL_CMD} get -u -f ${HOST_CONF_PATH} .general 2>&1`
	if [ ${?} -ne 0 ] || [ "${TEST_CONTENTS}" = "null" ] || [ "${TEST_CONTENTS}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to access the config file '${HOST_CONF_PATH}'!\n       Aborting.\n"
		return 2
	fi

	# Check that the partimag subsystem is not already initialised.
	PARTIMAG_SUBSYS_COMPAT=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .subsystems.partimag_compat`
	if [ ${?} -eq 0 ] && [ "${PARTIMAG_SUBSYS_COMPAT}" != "null" ] && [ "${PARTIMAG_SUBSYS_COMPAT}" != "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the partimag subsystem is already initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} dismantle-partimag${NRML}\n       Aborting.\n"
		return 1
	fi

	# Get pool name to use for partimag filesystem.
	PARTIMAG_POOL_NAME=""
	POOLS_AVAILABLE=`zpool list -H -o name`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n       Aborting.\n"
		return 1
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		PARTIMAG_POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${PARTIMAG_POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool for the partimag filesystem:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			PARTIMAG_POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${PARTIMAG_POOL_NAME_TEMP}${LCYN}' to use for the partimag filesystem.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				PARTIMAG_POOL_NAME="${PARTIMAG_POOL_NAME_TEMP}"
				break
			fi
			sleep 4
		done
	fi

	# Get the LAN interface that the NFS share will run on.
	CONFIG_LAN_NET_IFACE=`${UCL_CMD} get -f ${HOST_CONF_PATH} -q .network.interface.lan.id`
	if [ ${?} -ne 0 ] || [ "${CONFIG_LAN_NET_IFACE}" = "null" ] || [ "${CONFIG_LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to get the LAN interface id from the host config file!\n       Aborting.\n"
		return 2
	fi
	LAN_NET_IFACE=""
	HOST_LAN_IP_ADDRESSES=""
	NET_IFACES=`ifconfig -l`
	for IFACE in ${NET_IFACES}
	do
		if [ "${IFACE}" = "${CONFIG_LAN_NET_IFACE}" ]
		then
			HOST_LAN_IP_ADDRESSES=`ifconfig ${IFACE} | egrep "inet.*netmask" | awk '{print $2}' | egrep "${SERVERS_LAN_SUBNET_C}." | sort`
			if [ "${HOST_LAN_IP_ADDRESSES}" != "" ]
			then
				LAN_NET_IFACE="${IFACE}"
			fi
		fi
	done

	# Exit if the LAN subnet interface was not found.
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The LAN interface '${ORNG}${CONFIG_LAN_NET_IFACE}${NRML}' does not provide a valid '${ORNG}${SERVERS_LAN_SUBNET_C}.*${NRML}' subnet!\n       Aborting.\n"
		return 1
	fi

	# Get the LAN IP address of the NFS host.
	for IP_ADDRESS in ${HOST_LAN_IP_ADDRESSES}
	do
		# Let's ASSUME that the first and lowest (numerically) IP is the primary LAN IP.
		HOST_LAN_IP="${IP_ADDRESS}"
		break
	done

	# Test for existing partimag filesystem and prompt how to proceed.
	PARTIMAG_FILESYSTEM_EXISTS="no"
	zfs list -H ${PARTIMAG_POOL_NAME}/${PARTIMAG_ROOT_FS} > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The ZFS filesystem '${ORNG}${PARTIMAG_POOL_NAME}/${PARTIMAG_ROOT_FS}${NRML}' already exists!\n"
		question_yes_no "\nIt seems as though '${NRML}init-partimag${LCYN}' has already been applied to this host.\nWould you like to proceed?"
		if [ "${ANSWER}" = "yes" ]
		then
			# Ask whether to purge, archive or reuse exsiting partimag filesystem.
			question_purge_archive_reuse "\nWould you like to purge, archive or reuse the existing partimag filesystem\nand all it's children filesystems? [CAUTION]"
			if [ "${ANSWER}" = "purge" ]
			then
				zfs destroy -Rf ${PARTIMAG_POOL_NAME}/${PARTIMAG_ROOT_FS}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			elif [ "${ANSWER}" = "archive" ]
			then
				NOW=`date "+%Y-%m-%d_%H-%M-%S"`
				zfs rename -f ${PARTIMAG_POOL_NAME}/${PARTIMAG_ROOT_FS} ${PARTIMAG_POOL_NAME}/${PARTIMAG_ROOT_FS}_renamed-by-init-partimag-${NOW}
				ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
			elif [ "${ANSWER}" = "reuse" ]
			then
				PARTIMAG_FILESYSTEM_EXISTS="yes"
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} Unable to proceed.\n       Aborting.\n"
			return 1
		fi
	fi

	INIT_PARTIMAG_MODIFIED=true

	# Set mountd service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "mountd_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set nfs_server service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "nfs_server_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set rpc_lockd service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "rpc_lockd_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set rpc_statd service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "rpc_statd_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Set rpcbind service to start on boot.
	sysrc -f configs/${HOST_NAME}/etc/rc.conf "rpcbind_enable=YES" > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Create or update the exports file in the local repo.
	touch /etc/exports > /dev/null 2>&1
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	backup_file /etc/exports init-partimag
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	ETC_EXPORTS_BACKUP_FILE="${BACKUP_FILE_PATH}"
	cp /etc/exports configs/${HOST_NAME}/etc/exports
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Add mountpoint to NFS exports file.
	cat configs/${HOST_NAME}/etc/exports | egrep "^${PARTIMAG_ROOT_MP} " > /dev/null 2>&1
	if  [ ${?} -eq 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} It seems that the partimag NFS share already exists in the '/etc/exports' file.\n"
	else
		echo "${PARTIMAG_ROOT_MP} -maproot=root -network ${FDO_LAN_SUBNET_B}.0.0 -mask ${FDO_LAN_SUBNET_MASK}" >> configs/${HOST_NAME}/etc/exports
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	# Add subsystems compat level and init marker to host config file.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .subsystems.partimag_compat ${LATEST_PARTIMAG_SUBSYS_COMPAT}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	# Install host configs to the system.
	install_file_tree configs/${HOST_NAME} /
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst preparing the system for the partimag NFS share!\n"
		undo_init_partimag
		return 2
	fi

	# Create the ZFS filesystem for the partimag share.
	if [ "${PARTIMAG_FILESYSTEM_EXISTS}" = "no" ]
	then
		INIT_PARTIMAG_FILESYSTEMS_CREATED=true
		echo -e "\n${YELL}Creating ZFS filesystems for partimag NFS share...${NRML}\n"
		zfs create -o mountpoint=${PARTIMAG_ROOT_MP} ${PARTIMAG_POOL_NAME}/${PARTIMAG_ROOT_FS}
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst creating the filesystem for the partimag NFS share!\n"
		undo_init_partimag
		return 2
	fi

	# Copy init-partimag template configs to this hosts' repo profile.
	install_file_tree config-templates/init-partimag configs/${HOST_NAME}/
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	echo -e ""

	# Store subsystem configuration details.
	${UCL_CMD} set -f configs/${HOST_NAME}${HOST_CONF_PATH} .storage.partimag_pool "${PARTIMAG_POOL_NAME}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${PARTIMAG_CONF_PATH} .general.root_filesystem "${PARTIMAG_ROOT_FS}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	${UCL_CMD} set -f configs/${HOST_NAME}${PARTIMAG_CONF_PATH} .general.root_mountpoint "${PARTIMAG_ROOT_MP}"
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst storing the partimag configuration!\n"
		undo_init_partimag
		return 2
	fi

	# Start / reload the NFS services.
	echo -e "\n${YELL}Starting NFS services...${NRML}\n"
	service rpcbind status > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_PARTIMAG_RPCBIND_START=true
		service rpcbind start
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	service lockd status > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_PARTIMAG_LOCKD_START=true
		service lockd start
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	service mountd status > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_PARTIMAG_MOUNTD_START=true
		service mountd start
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	else
		INIT_PARTIMAG_MOUNTD_RELOAD=true
		service mountd reload
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi
	service nfsd status > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		INIT_PARTIMAG_NFSD_START=true
		service nfsd start
		ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	fi

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst initialising the partimag NFS share!\n"
		undo_init_partimag
		return 2
	fi

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))
	git commit -m "Updating host after 'init-partimag'; ${HOST_NAME}."
	ERROR_COUNT=$(( ${ERROR_COUNT} + ${?} ))

	if [ ${ERROR_COUNT} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong whilst commiting changes to the configs repo!\n"
		undo_init_partimag
		return 2
	fi

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to the '${NRML}${REPO_NAME}${YELL}' remote repo...${NRML}\n"
		git_push origin master
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to the remote git repo."
			echo -e "       Please consider manually running '${LBLU}git push${NRML}' from within '${ORNG}/${REPO_NAME}${NRML}'.\n"
		fi
	fi

	# Cleanup backup files.
	rm "${ETC_EXPORTS_BACKUP_FILE}" > /dev/null 2>&1

	echo -e "\n${LGRN}Congratulations! We have now finished setting up an NFS share for partimag.\n${NRML}"
	echo -e "${YELL}partimag NFS version:      3${NRML}"
	echo -e "${YELL}partimag host address:     ${HOST_LAN_IP}${NRML}"
	echo -e "${YELL}partimag server directory: ${PARTIMAG_ROOT_MP}${NRML}\n"

	return 0
}

##### MAIN EXECUTION THREAD ####################################################

TERM=${TERM}

SUB_CMD="${1}"
SUB_ARG1="${2}"
SUB_ARG2="${3}"
SUB_ARG3="${4}"
SUB_ARG4="${5}"
NUM_SUB_ARGS=$(( ${#} - 1 ))
HOST_NAME=`hostname -s`
FQHN=`hostname -f`
DOMAIN_NAME=`echo ${FQHN} | sed "s/${HOST_NAME}\.//"`
FETCH_LATEST_SELF=${FETCH_LATEST_SELF:-"yes"}
CHECK_REPO_CONFIG="yes"

if [ "${SUB_CMD}" = "connect-internet" ]
then
	FETCH_LATEST_SELF="no"
	CHECK_REPO_CONFIG="no"
fi

if [ "${FETCH_LATEST_SELF}" = "yes" ]
then
	fetch_latest_self
fi

if [ "${CHECK_REPO_CONFIG}" = "yes" ]
then
	check_repo_config
fi

if [ ${#} -lt 1 ]
then
	usage
	exit 1
fi


case "${SUB_CMD}" in

	install-scripts)
		update_local_repo --no-check-scripts
		install_scripts_everywhere
		exit ${?}
		;;

	add-script)
		# Add new script to local and remote git repo.
		test_num_mandatory_sub_args 1
		update_local_repo
		add_script "${SUB_ARG1}"
		exit ${?}
		;;

	update-script)
		# Update a script to local and remote git repo.
		test_num_mandatory_sub_args 1
		update_local_repo
		update_script "${SUB_ARG1}"
		exit ${?}
		;;

	install-configs)
		update_local_repo
		install_configs_everywhere
		exit ${?}
		;;

	check-configs)
		update_local_repo
		check_all_configs
		exit ${?}
		;;

	add-config)
		# Add a config file from the system to local and remote git repo.
		test_num_mandatory_sub_args 1
		update_local_repo
		add_config "${SUB_ARG1}"
		exit ${?}
		;;

	update-config)
		# Update a config file from the system to local and remote git repo.
		test_num_mandatory_sub_args 1
		update_local_repo
		update_config "${SUB_ARG1}"
		exit ${?}
		;;

	remove-config)
		# Update a config file from the system to local and remote git repo.
		test_num_mandatory_sub_args 1
		update_local_repo
		remove_config "${SUB_ARG1}"
		exit ${?}
		;;

	connect-internet)
		# Create a non-persistent connection to the internet so that we can access FDo resources etc.
		connect_internet
		exit ${?}
		;;

	init-host)
		# Register a new host in the repo, install essential packages and initial configuration from templates.
		test_num_mandatory_sub_args 2
		init_host "${SUB_ARG1}" "${SUB_ARG2}"
		exit ${?}
		;;

	patch-host)
		# Use freebsd-update to update to latest patch level.
		patch_host
		exit ${?}
		;;

	setup-vnc-desktop)
		# Install minimal X desktop environment accessible via VNC using IceWM, Roxterm, Xfe, Firefox and TightVNC.
		update_local_repo
		setup_vnc_desktop
		exit ${?}
		;;

	init-hotdesk)
		# Initialise the NIS/NFS hostdesking subsystem.
		update_local_repo
		init_hotdesk
		exit ${?}
		;;

	init-partimag)
		# Initialise the NFS share for partimag.
		update_local_repo
		init_partimag
		exit ${?}
		;;

	merge-local-repo-to-remote)
		# Move and merge a local repo to a private remote repo.
		merge_local_repo_to_remote
		exit ${?}
		;;

	upgrade-repo-from-upstream)
		# Upgrade the private repo to include changes from the public upstream skeleton repo.
		update_local_repo
		upgrade_repo_from_upstream --push
		EXIT_CODE=${?}
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to upgrade from the public upstream skeleton git repo.\n"
			exit ${EXIT_CODE}
		fi
		;;

	init-jails)
		# Initialise the FDo jails subsystem.
		update_local_repo
		init_jails
		exit ${?}
		;;

	create-jail)
		# Create a vanilla jail.
		test_num_mandatory_sub_args 2
		update_local_repo
		create_jail "${SUB_ARG1}" "${SUB_ARG2}"
		exit ${?}
		;;

	create-jail-from-recipe)
		# Create a jail from a jail recipe.
		test_num_mandatory_sub_args 3
		update_local_repo
		create_jail_from_recipe "${SUB_ARG1}" "${SUB_ARG2}" "${SUB_ARG3}"
		exit ${?}
		;;

	revert-create-jail)
		# Revert back to before last jail creation (developers).
		test_num_mandatory_sub_args 1
		revert_create_jail "${SUB_ARG1}"
		exit ${?}
		;;

	init-vms)
		# Initialise the FDo Virtual Machine subsystem (currently based on bhyve).
		update_local_repo
		init_vms
		exit ${?}
		;;

	create-vm-template)
		# Create a template VM for a particular use case.
		test_num_mandatory_sub_args 1
		update_local_repo
		create_vm_template "${SUB_ARG1}"
		exit ${?}
		;;

	create-vm-instance)
		# Create a VM instance from a template (uses ZFS snapshots).
		test_num_mandatory_sub_args 2
		update_local_repo
		create_vm_instance "${SUB_ARG1}" "${SUB_ARG2}"
		exit ${?}
		;;

	init-sshfs-daemon)
		# Initiaze the sshfs (SFTP) daemon subsystem.
		update_local_repo
		init_sshfs_daemon
		exit ${?}
		;;

	*)
		echo ""
		echo -e "${LRED}ERROR:${NRML} Sub-command '${ORNG}${SUB_CMD}${NRML}' is unknown!\n       Aborting.\n"
		usage
		exit 1
		;;

esac

################################################################################
