#!/bin/sh

# Copyright (c) 2016 Euan Thoms <euan@potensol.com>.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


##### GLOBAL STATIC VARIABLE DECLARATIONS ##########

SCRIPT_NAME=`basename $0`
REPO_NAME="fdo-server"
FDO_CONFIG_ROOT="/usr/local/etc/fdo"
FDO_SERVER_SKELETON_REPO="https://github.com/freedominion-org/fdo-server.git"
REPO_URI=`cat "${FDO_CONFIG_ROOT}/fdo-server-repo.conf" 2> /dev/null`
FETCH_LATEST_SELF_URL="http://freedominion.org/"
ESSENTIAL_PACKAGES="apcupsd axel bash bash-completion bsdadminscripts cpdup curl dmidecode git p7zip py27-speedtest-cli rsync stress tmux tree unrar unzip zfs-stats-lite zip nmap vim-console"
ESSENTIAL_JAIL_PACKAGES="axel bash bash-completion bsdadminscripts cpdup curl portmaster rsync tree unrar unzip zip vim-console"
REMOTE_DESKTOP_PACKAGES="virtualbox-ose py27-daemon py27-psycopg2"
VNC_DESKTOP_PACKAGES="xorg icewm clearlooks-themes roxterm xfe tightvnc firefox"
DIALOG_OUT_FILE="/tmp/${SCRIPT_NAME}.dialog.answer"
NET_IFACES_IGNORED="^tun[0-9]|^vboxnet[0-9]|^lo[0-9]|^vlan[0-9]|^pflog[0-9]"
AUX_LOCAL_SERVER_IP_MIN=2
AUX_LOCAL_SERVER_IP_MAX=9
PKG_REPO_CONF_FILE="FDo-pkg.conf"
PKG_REPO_CERT_FILE="FDo-pkg.cert"

FDO_LAN_SUBNET_B=${FDO_LAN_SUBNET_B:-"10.0"}
FDO_LAN_SUBNET_MASK="255.255.0.0"
SERVERS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.10"
JAILS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.11"
WORKSTATIONS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.20"
HOTDESKS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.25"
MOBILES_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.30"
GUESTS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.40"
FDO_LAN_GATEWAY_IP="${SERVERS_LAN_SUBNET_C}.1"

TERM="xterm"
LRED="\033[1;31m"
LGRN="\033[1;32m"
LBLU="\033[1;34m"
LCYN="\033[1;36m"
CYAN="\033[0;36m"
YELL="\033[1;33m"
ORNG="\033[0;33m"
GREY="\033[0;37m"
DGRY="\033[1;30m"
NRML="\033[0;00m"

CARRIAGE_RETURN="
"


usage ()
{
	if [ "${NO_DISPLAY_USAGE}" = "yes" ]
	then
		return 1
	fi

	echo -e ""
	echo -e "${LCYN}    ---- HOST MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} connect-internet${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-host host_name domain_name${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} init-host beastie1 example.net${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} patch-host${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} setup-vnc-desktop${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-hotdesking${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-clonezilla-images${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} upgrade-repo-from-upstream${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} merge-local-repo-to-remote${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- SCRIPT MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} install-scripts${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} add-script script_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} add-script /usr/local/bin/findinfiles${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} update-script script_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} update-script /usr/local/bin/replaceinfiles${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- CONFIG FILE MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} add-config config_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} add-config /etc/ntp.conf${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} add-config /jls/dhcp/usr/local/etc/dhcpd.conf${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} update-config config_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} update-config /etc/ntp.conf${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} update-config /jls/dhcp/usr/local/etc/dhcpd.conf${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} install-configs${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} check-configs [--silent]${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- JAIL MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-jails${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-jail jail_name jail_hostname${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-jail foo foobar.example.net${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-jail-from-recipe jail_name jail_hostname recipe_name${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-jail-from-recipe dns_cache dns-cache dns_cache${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- REMOTE DESKTOP MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-remote-desktops${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-remote-desktop-template template_name${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-remote-desktop-template Windows7${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-remote-desktop-instance template_name vnc_port_offset vnc_password${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-remote-desktop-instance Windows7 01 opensesame${NRML}"
	echo -e ""
}

pause_prompt ()
{
	# $[1} is the pause duration in seconds (maximum is 25).
	PAUSE_DURATION=$(( ${1} * 10 ))
	if [ ${PAUSE_DURATION} -gt 250 ]
	then
		PAUSE_DURATION=250
	fi
	echo -e "\n${GREY}Press any key to continue...${NRML}\c"
	CURRENT_TTY_SETTINGS=$(stty -g)
	stty raw -echo min 0 time ${PAUSE_DURATION}
	printf '%s' $(dd bs=1 count=1 2>/dev/null) > /dev/null
	stty ${CURRENT_TTY_SETTINGS}
	echo -e "\n"
}

## Modern replacement for the 'read' shell inbuilt command.
## Similar to the bash inbuilt 'read -e'.
readee ()
{

	# Test for no arguments
	if [ ${#} -eq 0 ]
	then
		echo -e "readee: arg count"
		return 2
	fi

	# Parse arguments
	READEE_PROMPT_MODE="false"
	READEE_PROMPT_TEXT=""
	READEE_VARIABLE=""
	for ARG in "${@}"
	do
		case "${ARG}" in
			"-e")
				# For backwards compatibility only
				continue
				;;
			"-s")
				READEE_SILENT_MODE="true"
				;;
			"-p")
				READEE_PROMPT_MODE="next_arg"
				;;
			*)
				# If in prompt mode 'next_arg', capture the prompt.
				if [ "${READEE_PROMPT_MODE}" = "next_arg" ]
				then
					READEE_PROMPT_TEXT="${ARG}"
					READEE_PROMPT_MODE="true"
					continue
				fi

				# Test for illegal option flags
				if [ `echo "${ARG}" | cut -c1` = "-" ]
				then
					echo -e "readee: Illegal option "`echo "${ARG}" | cut -c1-2`
					return 2
				fi

				# Test for variable name validity (try best to copy sh inbuilt: read)
				IS_SYNTAX_OK=`echo "${ARG}" | sed -r "s/^[a-zA-Z\_]+[a-zA-Z0-9\_]*//" | wc -L`
				if [ ${IS_SYNTAX_OK}  -ne 0 ]
				then
					echo -e "readee: ${ARG}: bad variable name"
					return 2
				fi
				READEE_VARIABLE="${ARG}"
				break
				;;
		esac
	done

	# Test for missing prompt argument
	if [ "${READEE_PROMPT_MODE}" = "next_arg" ]
	then
		echo -e "readee: No arg for -p option"
		return 2
	fi

	# Test for missing variable argument
	if [ "${READEE_VARIABLE}" = "" ]
	then
		echo -e "readee: arg count"
		return 2
	fi

	# Variables (re)initialisation:
	CURS="\033[30;47m"
	NRML="\033[0;00m"
	HEX_CARRIAGE_RETURN="%0d"
	HEX_ESCAPE="%1b"
	HEX_CTRL_C="%03"
	HEX_BACKSPACE="%7f"		# ASCII DEL, but actually comes from Backspace Key
	HEX_DELETE="%33"		# Comes after escape character
	HEX_HOME="%48"			# Comes after escape character
	HEX_END="%46"			# Comes after escape character
	HEX_D="%44"				# LEFT ARROW, comes after escape character
	HEX_C="%43"				# RIGHT ARROW, comes after escape character
	TYPED_CHAR=""
	TYPED_CHAR_HEX=""
	PRE_CURS_TEXT=""
	CURS_TEXT=" "
	POST_CURS_TEXT=""
	CURSOR_AT_START="true"
	CURSOR_AT_END="true"
	READEE_ABORTED="false"
	CURRENT_TTY_SETTINGS=`stty -g`

	# Prepare the TTY for line editing (no echo, raw input, make cursor invisible)
	stty -echo raw
	tput vi

	# Display initial prompt and edit line
	echo -e "\r${NRML}${READEE_PROMPT_TEXT}${CURS}${CURS_TEXT}${NRML}\c"

	# Loop taking keystrokes until carriage return key is pressed
	while [ "${TYPED_CHAR_HEX}" != "${HEX_CARRIAGE_RETURN}" ]
	do

		# Get a 2-byte character from stdin on key press and convert to Hexidecimal value
		TYPED_CHAR=$(dd bs=2 count=1 2> /dev/null)
		TYPED_CHAR_HEX=`printf "%%%02x\n" "'${TYPED_CHAR}"`

		# Compare the hexidecimal value of the first character with known ASCII values
		case "${TYPED_CHAR_HEX}" in
			"${HEX_CTRL_C}")
				READEE_ABORTED="true"
				break
				;;
			"${HEX_CARRIAGE_RETURN}")
				continue
				;;
			"${HEX_BACKSPACE}")
				# Get the length of the text left of cursor
				PRE_CURS_TEXT_LENGTH=`echo ${#PRE_CURS_TEXT}`

				if [ "${CURSOR_AT_START}" = "true" ]
				then
					# If cursor is already at the beginning, do nothing and continue
					continue
				fi

				if [ ${PRE_CURS_TEXT_LENGTH} -lt 2 ]
				then
					# Cursor reached the first character.
					# Set new pre-cursor text to empty, since cursor is now at the beginning;
					NEW_PRE_CURS_TEXT=""
					NEW_CURSOR_AT_START="true"
				else
					# Cursor moves left erasing the right-most character left of cursor.
					# Truncate the pre-cursor text by one character from the right;
					NEW_PRE_CURS_TEXT=`echo "${PRE_CURS_TEXT}" | cut -c1-$((${PRE_CURS_TEXT_LENGTH} -1))`
					NEW_CURSOR_AT_START="false"
				fi

				# Set new values:
				PRE_CURS_TEXT="${NEW_PRE_CURS_TEXT}"
				CURSOR_AT_START="${NEW_CURSOR_AT_START}"
				;;
			"${HEX_ESCAPE}")

				# The first character was the escape character, so let's get a second character and hex value
				ESCAPED_CHAR=$(dd bs=2 count=1 2> /dev/null)
				ESCAPED_CHAR_HEX=`printf "%%%02x\n" "'${ESCAPED_CHAR}"`

				# Compare the hex value of second character with known ASCII values
				# in order to get the extended meaning of the key stroke
				case "${ESCAPED_CHAR_HEX}" in
					"${HEX_HOME}")
						if [ "${CURSOR_AT_START}" = "true" ]
						then
							# if cursor is already at the start, do nothing and continue
							continue
						fi

						if [ "${CURSOR_AT_END}" = "true" ]
						then
							NEW_TEXT="${PRE_CURS_TEXT}"
						else
							NEW_TEXT="${PRE_CURS_TEXT}${CURS_TEXT}${POST_CURS_TEXT}"
						fi
						NEW_TEXT_LENGTH=${#NEW_TEXT}
						NEW_CURS_TEXT=`echo "${NEW_TEXT}" | cut -c1`
						NEW_POST_CURS_TEXT=`echo "${NEW_TEXT}" | cut -c2-${NEW_TEXT_LENGTH}`

						# Set new values:
						PRE_CURS_TEXT=""
						CURS_TEXT="${NEW_CURS_TEXT}"
						POST_CURS_TEXT="${NEW_POST_CURS_TEXT}"
						CURSOR_AT_START="true"
						CURSOR_AT_END="false"
						;;
					"${HEX_END}")
						if [ "${CURSOR_AT_END}" = "true" ]
						then
							# if cursor is already at he end, do nothing and continue
							continue
						fi

						NEW_TEXT="${PRE_CURS_TEXT}${CURS_TEXT}${POST_CURS_TEXT}"

						# Set new values:
						PRE_CURS_TEXT="${NEW_TEXT}"
						CURS_TEXT=" "
						POST_CURS_TEXT=""
						CURSOR_AT_START="false"
						CURSOR_AT_END="true"
						;;
					"${HEX_DELETE}")
						# Get the length of the text right of cursor
						POST_CURS_TEXT_LENGTH=${#POST_CURS_TEXT}

						if [ "${CURSOR_AT_END}" = "true" ]
						then
							# If cursor is already at the end, do nothing and continue
							continue
						fi

						if [ ${POST_CURS_TEXT_LENGTH} -lt 1 ]
						then
							# Cursor reached the last character.
							# Set new cursor character to whitespace so we can still see it;
							NEW_CURS_TEXT=" "
							# Set new post-cursor text to empty, since we are at the end;
							NEW_POST_CURS_TEXT=""
							NEW_CURSOR_AT_END="true"
						else
							# Cursor erases it's character and becomes the left-most character right of cursor.
							# Set cursor text to the left-most character of post-cursor text;
							NEW_CURS_TEXT=`echo "${POST_CURS_TEXT}" | cut -c1`
							# Truncate the post-cursor text by one character from the left;
							NEW_POST_CURS_TEXT=`echo "${POST_CURS_TEXT}" | cut -c2-${POST_CURS_TEXT_LENGTH}`
							NEW_CURSOR_AT_END="false"
						fi

						# Set new values:
						CURS_TEXT="${NEW_CURS_TEXT}"
						POST_CURS_TEXT="${NEW_POST_CURS_TEXT}"
						CURSOR_AT_END="${NEW_CURSOR_AT_END}"
						;;
					"${HEX_D}")	# LEFT ARROW
						# Get the length of the text left of cursor
						PRE_CURS_TEXT_LENGTH=`echo ${#PRE_CURS_TEXT}`

						if [ "${CURSOR_AT_START}" = "true" ]
						then
							# If cursor is already at the beginning, do nothing and continue
							continue
						fi

						if [ ${PRE_CURS_TEXT_LENGTH} -lt 2 ]
						then
							# Cursor reached the first character.
							# Set new pre-cursor text to empty, since cursor is now at the beginning;
							NEW_PRE_CURS_TEXT=""
							NEW_CURSOR_AT_START="true"
							NEW_CURSOR_AT_END="false"
						else
							# Cursor is moving left.
							# Set new pre-cursor text to current pre-cursor text truncated by one character from the right;
							NEW_PRE_CURS_TEXT=`echo "${PRE_CURS_TEXT}" | cut -c1-$((${PRE_CURS_TEXT_LENGTH} -1))`
							NEW_CURSOR_AT_START="false"
							NEW_CURSOR_AT_END="false"
						fi

						# Set new cursor character to character left of current cursor;
						NEW_CURS_TEXT=`echo "${PRE_CURS_TEXT}" | cut -c${#PRE_CURS_TEXT}`
						if [ "${CURSOR_AT_END}" = "true" ]
						then
							# Cursor was at end, so new post-cursor text is same as before;
							NEW_POST_CURS_TEXT="${POST_CURS_TEXT}"
						else
							# Set new post-cursor text to current cursor character concatenated with current post-cursor text;
							NEW_POST_CURS_TEXT="${CURS_TEXT}${POST_CURS_TEXT}"
						fi

						# Set new values:
						PRE_CURS_TEXT="${NEW_PRE_CURS_TEXT}"
						CURS_TEXT="${NEW_CURS_TEXT}"
						POST_CURS_TEXT="${NEW_POST_CURS_TEXT}"
						CURSOR_AT_START="${NEW_CURSOR_AT_START}"
						CURSOR_AT_END="${NEW_CURSOR_AT_END}"
						;;
					"${HEX_C}")	# RIGHT ARROW
						# Get the length of the text right of cursor
						POST_CURS_TEXT_LENGTH=${#POST_CURS_TEXT}

						if [ "${CURSOR_AT_END}" = "true" ]
						then
							# If cursor is already at the end, do nothing and continue
							continue
						fi

						if [ ${POST_CURS_TEXT_LENGTH} -lt 1 ]
						then
							# Cursor reached past last character.
							# Set new cursor character to whitespace so we can still see it;
							NEW_CURS_TEXT=" "
							# Set new post-cursor text to empty, since we are at the end;
							NEW_POST_CURS_TEXT=""
							NEW_CURSOR_AT_START="false"
							NEW_CURSOR_AT_END="true"
						else
							# Cursor is moving right.
							# Set new cursor character to first character of current post-cursor text;
							NEW_CURS_TEXT=`echo "${POST_CURS_TEXT}" | cut -c1`
							# Set new post-cursor text to current post-cursor text truncated by one character from the left;
							NEW_POST_CURS_TEXT=`echo "${POST_CURS_TEXT}" | cut -c2-${POST_CURS_TEXT_LENGTH}`
							NEW_CURSOR_AT_START="false"
							NEW_CURSOR_AT_END="false"
						fi

						# Set new pre-cursor text to current pre-cursor text concatenated with current cursor character;
						NEW_PRE_CURS_TEXT="${PRE_CURS_TEXT}${CURS_TEXT}"

						# Set new values:
						PRE_CURS_TEXT="${NEW_PRE_CURS_TEXT}"
						CURS_TEXT="${NEW_CURS_TEXT}"
						POST_CURS_TEXT="${NEW_POST_CURS_TEXT}"
						CURSOR_AT_START="${NEW_CURSOR_AT_START}"
						CURSOR_AT_END="${NEW_CURSOR_AT_END}"
						;;
					*)
						# For any other character, do nothing
						continue
						;;

				esac
				;;

			*)
				# Character is actual input
				PRE_CURS_TEXT="${PRE_CURS_TEXT}${TYPED_CHAR}"
				CURSOR_AT_START="false"
				;;
		esac

		# If in silent mode, hide displayed text
		if [ "${READEE_SILENT_MODE}" = "true" ]
		then
			DISPLAY_LINE="${NRML}${READEE_PROMPT_TEXT}"`echo "${PRE_CURS_TEXT}" | sed "s/./\*/g"`
			DISPLAY_LINE="${DISPLAY_LINE}${CURS}"`echo "${CURS_TEXT}" | sed "s/[^ ]/\*/g"`
			DISPLAY_LINE="${DISPLAY_LINE}${NRML}"`echo "${POST_CURS_TEXT}" | sed "s/./\*/g"`
		else
			DISPLAY_LINE="${NRML}${READEE_PROMPT_TEXT}${PRE_CURS_TEXT}${CURS}${CURS_TEXT}${NRML}${POST_CURS_TEXT}"
		fi

		# Echo display text to screen
		echo -e "\r${DISPLAY_LINE} \c"

	done

	# Put tty text and cursor back to how they were before
	stty ${CURRENT_TTY_SETTINGS}
	tput ve

	# Compile the whole entered text line from component parts
	if [ "${CURSOR_AT_END}" = "true" ]
	then
		READEE_ENTERED_TEXT="${PRE_CURS_TEXT}${POST_CURS_TEXT}"
	else
		READEE_ENTERED_TEXT="${PRE_CURS_TEXT}${CURS_TEXT}${POST_CURS_TEXT}"
	fi

	# If in silent mode, hide final entered text once more
	if [ "${READEE_SILENT_MODE}" = "true" ]
	then
		DISPLAY_LINE="${READEE_PROMPT_TEXT}"`echo "${READEE_ENTERED_TEXT}" | sed "s/./\*/g"`
	else
		DISPLAY_LINE="${READEE_PROMPT_TEXT}${READEE_ENTERED_TEXT}"
	fi

	# Now output final text
	if [ "${READEE_ABORTED}" = "true" ]
	then
		echo -e "\r${DISPLAY_LINE}^C"
		return 130
	else
		echo -e "\r${DISPLAY_LINE} "
	fi

	# Lastly, set the input variable that was passed as an argument
	eval "${READEE_VARIABLE}=\"${READEE_ENTERED_TEXT}\""

} ## END: readee ()

question_yes_no ()
{
	while true
	do
		echo -e "${LCYN}${1}${NRML}"
		readee -p "${LCYN}(yes/no): ${NRML}" ANSWER
		if [ "${ANSWER}" = "yes" ] || [ "${ANSWER}" = "no" ]
		then
			break
		fi
		echo ""
	done
}

question_yes ()
{
	while true
	do
		echo -e "${LCYN}${1}${NRML}"
		readee -p "${LCYN}(yes): ${NRML}" ANSWER
		if [ "${ANSWER}" = "yes" ]
		then
			break
		fi
		echo ""
	done
}

get_class_b_subnet ()
{
	CLASS_B_SUBNET_IP="${1}"
	CLASS_B_SUBNET_FIRST=`echo "${CLASS_B_SUBNET_IP}" | cut -d. -f1`
	CLASS_B_SUBNET_SECOND=`echo "${CLASS_B_SUBNET_IP}" | cut -d. -f2`
	CLASS_B_SUBNET="${CLASS_B_SUBNET_FIRST}.${CLASS_B_SUBNET_SECOND}"
}

get_class_c_subnet ()
{
	CLASS_C_SUBNET_IP="${1}"
	CLASS_C_SUBNET_FIRST=`echo "${CLASS_C_SUBNET_IP}" | cut -d. -f1`
	CLASS_C_SUBNET_SECOND=`echo "${CLASS_C_SUBNET_IP}" | cut -d. -f2`
	CLASS_C_SUBNET_THIRD=`echo "${CLASS_C_SUBNET_IP}" | cut -d. -f3`
	CLASS_C_SUBNET="${CLASS_C_SUBNET_FIRST}.${CLASS_C_SUBNET_SECOND}.${CLASS_C_SUBNET_THIRD}"
}

get_enabled_nat_services ()
{

	IS_PF_NAT_ENABLED=`sysrc pf_enable | awk '{print $2}'`
	IS_PPP_NAT_ENABLED=`sysrc ppp_nat | awk '{print $2}'`

}

get_jail_id_from_name ()
{
	# ${1} is jail name

	JAIL_ID_FILE=`ls -1 /var/run/jail_${1}.id 2> /dev/null | head -1`
	if [ "${JAIL_ID_FILE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Could not identify jail id from jail name.\n"
		JAIL_ID=-1
		return 1
	fi
	JAIL_ID=`cat ${JAIL_ID_FILE}`

}

test_num_mandatory_sub_args ()
{
	NUM_MANDATORY_SUB_ARGS=${1}
	if [ ${NUM_SUB_ARGS} -lt ${NUM_MANDATORY_SUB_ARGS} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Invalid number of arguments for this sub-command!\n       Aborting.\n"
		usage
		exit 3
	fi

}

test_valid_person_name ()
{

	TEST_CASE="${1}"

	VALID_PERSON_NAME="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_PERSON_NAME="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^[a-zA-Z0-9]*[a-zA-Z0-9\ ]*[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_PERSON_NAME="no"
		return 2
	fi

}

test_valid_integer ()
{

	TEST_CASE="${1}"
	TEST_MIN_VALUE=${2}
	TEST_MAX_VALUE=${3}

	VALID_INTEGER="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_INTEGER="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^[0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_INTEGER="no"
		return 2
	fi

	if [ ${TEST_CASE} -lt ${TEST_MIN_VALUE} ]
	then
		VALID_INTEGER="no"
		return 3
	fi

	if [ ${TEST_CASE} -gt ${TEST_MAX_VALUE} ]
	then
		VALID_INTEGER="no"
		return 4
	fi

}

test_valid_email_address ()
{

	TEST_CASE="${1}"

	VALID_EMAIL_ADDRESS="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_EMAIL_ADDRESS="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^([a-zA-Z0-9]+([\.\_\-]?[a-zA-Z0-9]+)*)+([\+]([a-zA-Z0-9]+([\.\_\/\-]?[a-zA-Z0-9]+)*)+)?\@((([a-zA-Z0-9]+[\-])*[a-zA-Z0-9]+)+\.)+[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_EMAIL_ADDRESS="no"
		return 2
	fi

}

test_valid_inet_address ()
{

	TEST_CASE="${1}"

	VALID_INET_ADDRESS="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_INET_ADDRESS="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed "s/^[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}$//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_INET_ADDRESS="no"
		return 2
	fi

	NO_ZEROS_IN_FRONT=`echo "${TEST_CASE}" | sed "s/\.0[0-9]//" | sed "s/^0//"`
	if [ "${NO_ZEROS_IN_FRONT}" != "${TEST_CASE}" ]
	then
		VALID_INET_ADDRESS="no"
		return 3
	fi

	ONE=`echo "${TEST_CASE}" | cut -d. -f1`
	TWO=`echo "${TEST_CASE}" | cut -d. -f2`
	THREE=`echo "${TEST_CASE}" | cut -d. -f3`
	FOUR=`echo "${TEST_CASE}" | cut -d. -f4`

	if [ ${ONE} -gt 255 ] || [ ${TWO} -gt 255 ] || [ ${THREE} -gt 255 ] || [ ${FOUR} -gt 255 ]
	then
		VALID_INET_ADDRESS="no"
		return 4
	fi

}

test_valid_host_name ()
{

	TEST_CASE="${1}"

	VALID_HOST_NAME="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_HOST_NAME="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^([a-zA-Z0-9]+[\-])*[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_HOST_NAME="no"
		return 2
	fi

}

test_valid_fqhn ()
{

	TEST_CASE="${1}"

	VALID_FQHN="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_FQHN="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^((([a-zA-Z0-9]+[\-])*[a-zA-Z0-9]+)+\.)+[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_FQHN="no"
		return 2
	fi

}

test_ping_host ()
{

	TEST_CASE="${1}"

	VALID_HOST_PING="yes"

	ping -c 3 ${TEST_CASE} > /dev/null 2>&1

	if [ ${?} -ne 0 ]
	then
		VALID_HOST_PING="no"
		return 1
	fi
}

test_valid_simple_url ()
{

	TEST_CASE="${1}"

	VALID_URL="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_URL="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^http[s]?\:\/\/[a-zA-Z0-9]+([\-]*[a-zA-Z0-9]+)*(\.[a-zA-Z0-9]+([\_\-]*[a-zA-Z0-9]+)*)*(:[0-9]+)?(\/[a-zA-Z0-9]+([\_\-]*[a-zA-Z0-9]+)*(\.[a-zA-Z0-9]+([\_\-]*[a-zA-Z0-9]+)*)*)*[\/]*//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_URL="no"
		return 2
	fi

}

test_valid_ldap_dn ()
{

	TEST_CASE="${1}"

	VALID_LDAP_DN="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_LDAP_DN="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/([a-zA-Z0-9]+\=[a-zA-Z0-9_.+-]+)+(,[a-zA-Z0-9]+\=[a-zA-Z0-9_.+-]+)*//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_LDAP_DN="no"
		return 2
	fi

}

fetch_latest_self ()
{
	echo -e "\n${YELL}Fetching the latest version of this utility...${NRML}\n"
	cd /root
	fetch -d ${FETCH_LATEST_SELF_URL}${SCRIPT_NAME}
	if [ $? -ne 0 ]
	then
		question_yes_no "\nUnable to fetch the latest version of this utility.\nWould you like to continue anyway?"
		if [ "${ANSWER}" = "no" ]
		then
			exit 10
		fi
	else
		EXISTING_SHA256=`sha256 -q /usr/local/sbin/${SCRIPT_NAME}`
		FETCHED_SHA256=`sha256 -q ${SCRIPT_NAME}`
		if [ "${EXISTING_SHA256}" != "${FETCHED_SHA256}" ]
		then
			if [ ! -d /usr/local/sbin/ ]
			then
				mkdir -p /usr/local/sbin
			fi
			mv /root/${SCRIPT_NAME} /usr/local/sbin/
			chmod +x /usr/local/sbin/${SCRIPT_NAME}
			echo -e "\n${YELL}A newer version has now been installed.\nPlease rerun this utility.${NRML}\n"
			exit 11
		else
			echo -e "\n${YELL}The current version of this utility appears to be up to date.${NRML}\n"
			rm /root/${SCRIPT_NAME}
		fi
	fi

	cd -

}

git_pull ()
{
	REPOSITORY="${1}"
	BRANCH="${2}"
	while true
	do
		git pull ${REPOSITORY} ${BRANCH}
		if [ ${?} -ne 0 ]
		then
			question_yes_no "\nThe git pull operation failed! Would you like to try again?"
			if [ "${ANSWER}" = "yes" ]
			then
				echo -e ""
			else
				return 1
			fi
		else
			return 0
		fi
	done
}

git_push ()
{
	REPOSITORY="${1}"
	BRANCH="${2}"
	while true
	do
		git push ${REPOSITORY} ${BRANCH}
		if [ ${?} -ne 0 ]
		then
			question_yes_no "\nThe git push operation failed! Would you like to try again?"
			if [ "${ANSWER}" = "yes" ]
			then
				echo -e ""
			else
				return 1
			fi
		else
			return 0
		fi
	done
}

check_repo_config ()
{

	# If REPO_URI is already set, then no need to proceed
	if [ "${REPO_URI}" != "" ]
	then
		return 0
	fi

	# Get the type of repo and, if applicable, the remote repo URI
	while [ "${REPO_URI}" = "" ]
	do
		echo -e "\n\n${LGRN}It appears that this is the first time you have used ${SCRIPT_NAME}${NRML}"
		echo -e "${LGRN}on this host.${NRML}\n"
		echo -e "${YELL}If this is your first host and you don't have a private remote git repo running${NRML}"
		echo -e "${YELL}yet. Then enter 'local' at the next prompt.${NRML}\n"

		pause_prompt 25

		# Prompt for the type of repo to use, remote or local.
		REPO_TYPE=""
		while [ "${REPO_TYPE}" = "" ]
		do
			echo -e "\n${LCYN}Would you like to use an existing remote git repo (recommended, if available),${NRML}"
			echo -e "${LCYN}or start with a local repo (not backed up remotely, no central management)?${NRML}"
			readee -p "${LCYN}(remote/local): ${NRML}" REPO_TYPE_TEMP
			# Check input validation.
			if [ "${REPO_TYPE_TEMP}" = "remote" ] || [ "${REPO_TYPE_TEMP}" = "local" ]
			then
				REPO_TYPE="${REPO_TYPE_TEMP}"
			fi
		done

		# If it does not exist, create the root path for FDo config files
		if [ ! -f ${FDO_CONFIG_ROOT} ]
		then
			mkdir -p ${FDO_CONFIG_ROOT}
		fi

		if [ "${REPO_TYPE}" = "local" ]
		then
			REPO_URI="local"
		else
			# Get the URI of the remote git repo
			REMOTE_REPO_URI=""
			while [ "${REMOTE_REPO_URI}" = "" ]
			do
				echo -e "\n${LCYN}Enter the remote git repo URI:${NRML}"
				readee REMOTE_REPO_URI_TEMP
				# Allow use to change their mind about type of repo
				if [ "${REMOTE_REPO_URI_TEMP}" = "" ]
				then
					break
				fi
				# Test the input to see if it is a valid URI (URL)
				test_valid_simple_url "${REMOTE_REPO_URI_TEMP}"
				if [ "${VALID_URL}" = "yes" ]
				then
					question_yes_no "\nYou have entered '${NRML}${REMOTE_REPO_URI_TEMP}${LCYN}'\nas the remote git repo URI.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						REMOTE_REPO_URI=${REMOTE_REPO_URI_TEMP}
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} remote git repo URI is invalid!\n"
				fi
			done
			REPO_URI="${REMOTE_REPO_URI}"
		fi

	done

	# Store the repo URI in it's FDo config file
	echo "${REPO_URI}" > ${FDO_CONFIG_ROOT}/fdo-server-repo.conf

	echo -e "\n${YELL}The local repo will be stored in the path '/${REPO_NAME}'.${NRML}\n"
	NO_DISPLAY_USAGE="yes"

}

backup_file ()
{
	FILE_PATH=${1}
	CHANGE_AGENT=${2}
	NOW=`date "+%Y-%m-%d_%H-%M-%S"`
	if [ -f ${FILE_PATH} ]
	then
		cp ${FILE_PATH} ${FILE_PATH}.${CHANGE_AGENT}_backup_${NOW}
	fi
}

install_file_tree ()
{

	SOURCE_FILES_ROOT="${1}"
	DEST_FILES_ROOT="${2}"
	CHOWN_USER="${3}"
	CHOWN_GROUP="${4}"
	INSTALL_FILE_ERROR_COUNT=0

	for SOURCE_FILE_PATH in `find "${SOURCE_FILES_ROOT}" -print | tail -n +2 | sort`
	do

		RELATIVE_DEST_FILE_PATH=`echo ${SOURCE_FILE_PATH} | sed "s|${SOURCE_FILES_ROOT}/||"`
		DEST_FILE_PATH="${DEST_FILES_ROOT}${RELATIVE_DEST_FILE_PATH}"

		if [ -d "${SOURCE_FILE_PATH}" ]
		then
			if [ ! -d "${DEST_FILE_PATH}" ]
			then
				mkdir "${DEST_FILE_PATH}"
			fi
			FILE_UID=`ls -ldn "${SOURCE_FILE_PATH}" | awk '{print $3}'`
			FILE_GID=`ls -ldn "${SOURCE_FILE_PATH}" | awk '{print $4}'`
			chown ${FILE_UID}:${FILE_GID} "${DEST_FILE_PATH}"
		else
			cp "${SOURCE_FILE_PATH}" "${DEST_FILE_PATH}"
		fi
		if [ $? -ne 0 ]
		then
			INSTALL_FILE_ERROR_COUNT=$((INSTALL_FILE_ERROR_COUNT + 1))
		fi

		if [ "${CHOWN_USER}" != "" ]
		then
			chown ${CHOWN_USER} "${DEST_FILE_PATH}"
		fi
		if [ $? -ne 0 ]
		then
			INSTALL_FILE_ERROR_COUNT=$((INSTALL_FILE_ERROR_COUNT + 1))
		fi

		if [ "${CHOWN_GROUP}" != "" ]
		then
			chown :${CHOWN_GROUP} "${DEST_FILE_PATH}"
		fi
		if [ $? -ne 0 ]
		then
			INSTALL_FILE_ERROR_COUNT=$((INSTALL_FILE_ERROR_COUNT + 1))
		fi
	done

}

compare_file_tree ()
{

	SOURCE_FILES_ROOT=${1}
	DEST_FILES_ROOT=${2}
	SILENT_MODE="no"
	COMPARE_FILE_ERROR_COUNT=0

	if [ "${3}" = "--silent" ]
	then
		SILENT_MODE="yes"
	fi

	for SOURCE_FILE_PATH in `find ${SOURCE_FILES_ROOT} -print | tail -n +2 | sort`
	do

		RELATIVE_DEST_FILE_PATH=`echo ${SOURCE_FILE_PATH} | sed "s|${SOURCE_FILES_ROOT}/||"`
		DEST_FILE_PATH=${DEST_FILES_ROOT}${RELATIVE_DEST_FILE_PATH}

		if [ -d "${SOURCE_FILE_PATH}" ]
		then
			if [ ! -d ${DEST_FILE_PATH} ]
			then
				echo -e "${ORNG}WARNING:${NRML} The following directory ${LRED}DOES NOT EXIST${NRML}: ${DEST_FILE_PATH}"
				COMPARE_FILE_ERROR_COUNT=$((COMPARE_FILE_ERROR_COUNT + 1))
			fi
		else
			if [ ! -f ${DEST_FILE_PATH} ]
			then
				echo -e "${ORNG}WARNING:${NRML} The following file      ${LRED}DOES NOT EXIST${NRML}: ${DEST_FILE_PATH}"
				COMPARE_FILE_ERROR_COUNT=$((COMPARE_FILE_ERROR_COUNT + 1))
			else
				diff ${SOURCE_FILE_PATH} ${DEST_FILE_PATH} > /dev/null 2>&1
				if [ $? -eq 0 ]
				then
					echo -e "${LGRN}CHECKED${NRML}: The following file is ${LGRN}IN CHECK${NRML}:       ${DEST_FILE_PATH}"
				else
					echo -e "${ORNG}WARNING${NRML}: The following file is ${ORNG}OUT OF CHECK${NRML}:   ${DEST_FILE_PATH}"
					COMPARE_FILE_ERROR_COUNT=$((COMPARE_FILE_ERROR_COUNT + 1))
					if [ "${SILENT_MODE}" = "no" ]
					then
						echo -e ""
						question_yes_no "Would you like to see the diff for ${DEST_FILE_PATH} ?"
						if [ "${ANSWER}" = "yes" ]
						then
							echo -e ""
							diff -u ${SOURCE_FILE_PATH} ${DEST_FILE_PATH}
							echo -e ""
							question_yes "Continue?"
							echo -e ""
						fi
					fi
				fi
			fi
		fi
	done

}

init_git_config ()
{

	CWD=`pwd`
	cd /${REPO_NAME}

	echo -e "\n\n${YELL}Initialising git config...${NRML}\n"

	git config user.name > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		while [ "${GIT_USER_NAME}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter the git user name (e.g. John Doe): ${NRML}" GIT_USER_NAME_TEMP
			# Check that the git user name only contains letters numbers and spaces.
			test_valid_person_name "${GIT_USER_NAME_TEMP}"
			if [ "${VALID_PERSON_NAME}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${GIT_USER_NAME_TEMP}${LCYN}' as the git user name.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					GIT_USER_NAME=${GIT_USER_NAME_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The name can not be '${NRML}${GIT_USER_NAME}${LCYN}'."
				echo -e "       It must contain only letters, numbers and spaces.\n"
			fi
		done
		git config user.name "${GIT_USER_NAME}"
	fi

	git config user.email > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		while [ "${GIT_USER_EMAIL}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter the git user email address: ${NRML}" GIT_USER_EMAIL_TEMP
			# Check that the git user email only contains letters, numbers, periods, pluses, hyphens, underscores and one @.
			test_valid_email_address "${GIT_USER_EMAIL_TEMP}"
			if [ "${VALID_EMAIL_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${GIT_USER_EMAIL_TEMP}${LCYN}' as the git user email.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					GIT_USER_EMAIL=${GIT_USER_EMAIL_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The email address can not be '${GIT_USER_EMAIL_TEMP}'."
				echo -e "       It must be a valid email address.\n"
			fi
		done
		git config user.email "${GIT_USER_EMAIL}"
	fi

	git config push.default > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		git config push.default "simple"
	fi

	cd ${CWD}

}

upgrade_repo_from_upstream ()
{

	if [ "${1}" = "--push" ]
	then
		DO_GIT_PUSH="yes"
	else
		DO_GIT_PUSH="no"
	fi

	CWD=`pwd`

	# Move into local repo directory.
	cd "/${REPO_NAME}"
	if [ ${?} -ne 0 ]
	then
		return 1
	fi

	# Get the pre-upgrade git commit reference
	PRE_UPGRADE_COMMIT_REF=`git log --format=format:%H -1`

	# Add the public upstream skeleton repo as a remote called 'upstream'.
	git remote add upstream "${FDO_SERVER_SKELETON_REPO}"
	if [ ${?} -ne 0 ]
	then
		return 2
	fi

	# Fetch the upstream changes.
	git fetch upstream
	if [ ${?} -ne 0 ]
	then
		return 3
	fi

	# Merge the upstream changes to the local repo.
	git merge upstream/master --allow-unrelated-histories -m "Upgrading private repo from upstream skeleton repo on host '${HOST_NAME}'."
	if [ ${?} -ne 0 ]
	then
		return 4
	fi

	# Detach the upstream remote from the local repo
	git remote remove upstream
	if [ ${?} -ne 0 ]
	then
		return 5
	fi

	if [ "${REPO_URI}" != "local" ] && [ "${DO_GIT_PUSH}" = "yes" ]
	then
		echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
		git_push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			UPGRADE_REMOTE_REPO_SUCCESS="no"
		else
			UPGRADE_REMOTE_REPO_SUCCESS="yes"
		fi
	fi

	if [ "${DO_GIT_PUSH}" = "yes" ]
	then
		echo -e "\n${LGRN}OK, it seems we've successfully upgraded the local repo!${NRML}\n"
		if [ "${REPO_URI}" != "local" ] && [ "${UPGRADE_REMOTE_REPO_SUCCESS}" = "no" ]
		then
			echo -e "${ORNG}But we were unable to push changes to the private remote repo.${NRML}\n"
		fi
	fi

	# Get the post-upgrade git commit reference
	POST_UPGRADE_COMMIT_REF=`git log --format=format:%H -1`

	# Check if any scripts have been updated in this upgrade cycle
	echo -e "\n${YELL}Checking if any scripts have been updated in this upgrade...${NRML}\n"
	git diff-tree --no-commit-id --name-only -r ${PRE_UPGRADE_COMMIT_REF} ${POST_UPGRADE_COMMIT_REF} | grep "^scripts/"

	if [ ${?} -eq 0 ]
	then
		# Ask whether to perform an 'install-scripts'
		question_yes_no "\nIt seems that one or more scripts have been updated in this upgrade.\nWould you like to perform an 'install-scripts' now?"
		if [ "${ANSWER}" = "yes" ]
		then
			install_scripts_everywhere
		else
			echo -e "${YELL}You may perform an 'install-scripts' later by running the command:${NRML}\n${LBLU}${SCRIPT_NAME} install-scripts${NRML}"
		fi
		echo -e ""
	fi

	cd "${CWD}"

	return 0
}

init_local_repo ()
{

	CWD=`pwd`

	echo -e "\n\n${YELL}Initialising the local repo...${NRML}\n"

	# Move to '/' because this is where we keep the local repo
	cd /

	# Clone or update the git repository
	if [ -d "/${REPO_NAME}/.git" ]
	then

		# The local repo already exists.

		cd "/${REPO_NAME}"

		if [ "${REPO_URI}" = "local" ]
		then
			# Re-initialise a local only repo.
			echo -e "${YELL}The local git repo already exists.${NRML}"
			echo -e "${YELL}Updating from the upstream skeleton repo...${NRML}\n"
			# Temporarily reattach to public upstream skeleton repo, to pull latest changes.
			git remote add origin "${FDO_SERVER_SKELETON_REPO}"
			git fetch
			git branch --set-upstream-to=origin/master master
			git_pull
			# Detach from the remote repo
			git remote remove origin
		else
			# Re-initialise a local repo and attach it to its remote repo.
			echo -e "${YELL}The local git repo already exists.${NRML}"
			echo -e "${YELL}Updating from the private remote repo...${NRML}\n"
			# Attach the local repo to the private remote repo.
			git remote remove origin
			git remote add origin "${REPO_URI}"
			git fetch
			git branch --set-upstream-to=origin/master master
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} The remote repo is not valid!"
				echo -e "       Check that the remote repo URI is correct."
				echo -e "       Consider using the subcommand 'merge-local-repo-to-remote'."
				echo -e "       Aborting.\n"
				exit 170
			fi
			# Update (pull) the latest changes from the private remote repo.
			git_pull
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to update git repo.\n       Aborting.\n"
				exit 171
			fi
		fi

	else

		# The local repo does not exist yet.

		if [ "${REPO_URI}" = "local" ]
		then
			# Initialise a new local only repo.
			# Clone the upstream skeleton repo from github.
			echo -e "${YELL}Cloning the upstream skeleton git repo...${NRML}\n"
			git clone "${FDO_SERVER_SKELETON_REPO}" ${REPO_NAME}
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to clone upstream skeleton git repo.\n       Aborting.\n"
				exit 172
			fi
			# After we get the skeleton, detach from the upstream skeleton repo.
			cd "/${REPO_NAME}"
			git remote remove origin
		else
			# Initialise a new local repo and attach to its remote repo.
			# Clone our private remote git repo
			echo -e "${YELL}Cloning our private remote git repo...${NRML}\n"
			git clone ${REPO_URI} ${REPO_NAME}
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to clone private remote git repo.\n       Aborting.\n"
				exit 173
			fi
		fi

	fi

	echo -e "\n${LGRN}Finished initialising the local repo.${NRML}\n\n"

	cd ${CWD}

}

install_scripts ()
{

	INSTALL_PATH=${1}

	cd /${REPO_NAME}

	install_file_tree scripts ${INSTALL_PATH}

	if [ ${INSTALL_FILE_ERROR_COUNT} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to copy one or more scripts to target location:"
		echo -e "       ${ORNG}(${INSTALL_PATH})${NRML}\n"
	else
		echo -e "\n${LGRN}SUCCESS:${NRML} Installed all scripts successfully!"
		echo -e "         ${LGRN}(${INSTALL_PATH})${NRML}\n"
	fi

	cd -

}

install_scripts_everywhere ()
{
	# Install scripts to the host
	install_scripts /

	# Install scripts to the jails
	for JAIL_DIR in `ls -1 /jls 2> /dev/null`
	do
		install_scripts /jls/${JAIL_DIR}/
	done
}

add_script ()
{

	SCRIPT_PATH="${1}"

	cd /${REPO_NAME}
	if [ "${SCRIPT_PATH}" = "" ] || [ ! -f ${SCRIPT_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The referenced file '${SCRIPT_PATH}' does not exist.\n       Aborting.\n"
		exit 15
	elif [ -f "scripts${SCRIPT_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file 'scripts${SCRIPT_PATH}' already exists."
		echo -e "       Please consider using '${SCRIPT_NAME} update-script' instead.\n       Aborting.\n"
		exit 16
	else
		cp ${SCRIPT_PATH} scripts${SCRIPT_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${SCRIPT_PATH}' to local git repo.\n       Aborting.\n"
			exit 17
		fi
		git add scripts${SCRIPT_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to add '${SCRIPT_PATH}' to local git repo.\n       Aborting.\n"
			exit 18
		fi
		git commit -m "Added new script; '${SCRIPT_PATH}'."
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${SCRIPT_PATH}' to local git repo."
			echo -e "       Please consider manually running 'git reset --hard' to previous commit."
			echo -e "       Aborting.\n"
			exit 19
		fi
		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
			git_push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			fi
		fi
		echo -e "\n${LGRN}OK, it seems we've successfully added the new script!${NRML}\n"
	fi

	cd -

}

update_script ()
{

	SCRIPT_PATH="${1}"

	cd /${REPO_NAME}
	if [ "${SCRIPT_PATH}" = "" ] || [ ! -f "${SCRIPT_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The referenced file '${SCRIPT_PATH}' does not exist.\n       Aborting.\n"
		exit 20
	elif [ ! -f "scripts${SCRIPT_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file 'scripts${SCRIPT_PATH}' does not exist.\n       Aborting.\n"
		exit 21
	else
		echo -e ""
		readee -p "${LCYN}Enter a short explanation of the changes made: ${NRML}" CHANGE_MESSAGE
		cp ${SCRIPT_PATH} scripts${SCRIPT_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${SCRIPT_PATH}' to local git repo.\n       Aborting.\n"
			exit 22
		fi
		git add scripts${SCRIPT_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to update '${SCRIPT_PATH}' to local git repo.\n       Aborting.\n"
			exit 23
		fi
		git commit -m "Updated script; '${SCRIPT_PATH}': ${CHANGE_MESSAGE}."
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${SCRIPT_PATH}' to local git repo."
			echo -e "       Please consider manually running 'git reset --hard' to previous commit."
			echo -e "       Aborting.\n"
			exit 24
		fi
		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...\n"
			git_push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo.${NRML}"
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}."
				echo -e "       Aborting.\n"
			fi
		fi
		echo -e "\n${LGRN}OK, it seems we've successfully updated the script!${NRML}\n"
	fi

	cd -

}

install_configs ()
{

	CONFIG_REPO_ROOT=${1}
	INSTALL_PATH=${2}

	cd /${REPO_NAME}

	if [ ! -d ${CONFIG_REPO_ROOT} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the repo config directory ('${CONFIG_REPO_ROOT}') does not exist!\n       Aborting.\n"
		exit 26
	fi

	if [ ! -d ${INSTALL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the installation directory ('${INSTALL_PATH}') does not exist!\n       Aborting.\n"
		exit 27
	fi

	install_file_tree ${CONFIG_REPO_ROOT} ${INSTALL_PATH}

	if [ ${INSTALL_FILE_ERROR_COUNT} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to copy one or more config files to target location. (${CONFIG_REPO_ROOT})\n"
		cd -
		return 1
	else
		echo -e "\n${LGRN}Installed all config files successfully! (${CONFIG_REPO_ROOT})${NRML}\n"
		cd -
		return 0
	fi

}

check_configs ()
{

	CONFIG_REPO_ROOT=${1}
	INSTALL_PATH=${2}

	cd /${REPO_NAME}

	if [ ! -d ${CONFIG_REPO_ROOT} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the repo config directory ('${CONFIG_REPO_ROOT}') does not exist!\n"
		cd -
		return 1
	fi

	if [ ! -d ${INSTALL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the installation directory ('${INSTALL_PATH}') does not exist!\n"
		cd -
		return 2
	fi

	compare_file_tree ${CONFIG_REPO_ROOT} ${INSTALL_PATH} ${3}

	cd -

}

check_all_configs ()
{

	CHECK_ALL_CONFIGS_ERROR_COUNT=0

	# Check configs for the host.
	echo -e "\nChecking configs for the host...\n"
	check_configs configs/${HOST_NAME} / "${SUB_ARG1}"
	CHECK_ALL_CONFIGS_ERROR_COUNT=$((CHECK_ALL_CONFIGS_ERROR_COUNT + COMPARE_FILE_ERROR_COUNT ))

	# Check configs for the jails.
	cd /${REPO_NAME}
	for JAIL_NAME in `ls -1 configs | grep -e "@${HOST_NAME}" | cut -d@ -f1`
	do
		echo -e "\nChecking configs for the '${JAIL_NAME}' jail...\n"
		check_configs configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/ "${SUB_ARG1}"
		CHECK_ALL_CONFIGS_ERROR_COUNT=$((CHECK_ALL_CONFIGS_ERROR_COUNT + COMPARE_FILE_ERROR_COUNT ))
	done

	if [ ${CHECK_ALL_CONFIGS_ERROR_COUNT} -eq 0 ]
	then
		echo -e "\n${LGRN}It seems the configs tracked by the repo are all IN CHECK!${NRML}\n"
	else
		echo -e "\n${ORNG}It seems at least one config tracked by the repo is missing or OUT OF CHECK!${NRML}\n"
	fi

	cd -

}

add_config ()
{

	CONFIG_FULL_PATH="${1}"

	cd /${REPO_NAME}

	echo "${CONFIG_FULL_PATH}" | grep -e "/jls/" > /dev/null 2>&1
	if [ $? -eq 0 ]
	then
		# config file belongs to a jail
		JAIL_NAME=`echo ${CONFIG_FULL_PATH}  | cut -d/ -f3`
		CONFIG_REPO_ROOT=configs/${JAIL_NAME}@${HOST_NAME}
		CONFIG_RELATIVE_PATH=`echo ${CONFIG_FULL_PATH} | sed "s|/jls/${JAIL_NAME}||"`
	else
		# config file belongs to the host
		CONFIG_REPO_ROOT=configs/${HOST_NAME}
		CONFIG_RELATIVE_PATH=${CONFIG_FULL_PATH}
	fi

	CONFIG_REPO_DIR=`dirname "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}"`
	if [ ! -d ${CONFIG_REPO_DIR} ]
	then
		mkdir -p ${CONFIG_REPO_DIR}
	fi

	if [ "${CONFIG_FULL_PATH}" = "" ] || [ ! -f ${CONFIG_FULL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The file '${CONFIG_FULL_PATH}' does not exist.\n       Aborting.\n"
		exit 30
	elif [ -f "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file '${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}' already exists."
		echo -e "       Please consider using '${SCRIPT_NAME} update-config' instead."
		echo -e "       Aborting.\n"
		exit 31
	else
		cp ${CONFIG_FULL_PATH} ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${CONFIG_FULL_PATH}' to local git repo.\n       Aborting.\n"
			exit 32
		fi
		git add ${CONFIG_REPO_ROOT}${CONFIG_REALTIVE_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to add '${CONFIG_FULL_PATH}' to local git repo.\n       Aborting.\n"
			exit 33
		fi
		git commit -m "Added new config; '${CONFIG_FULL_PATH}' for ${HOST_NAME}."
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${CONFIG_FULL_PATH}' to local git repo."
			echo -e "       Please consider manually running 'git reset --hard' to previous commit."
			echo -e "       Aborting.\n"
			exit 34
		fi
		if [ "${REPO_URI}" != "local" ] && [ "${GIT_NO_PUSH}" != "yes" ]
		then
			echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
			git_push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			fi
		fi
		echo -e "\n${LGRN}OK, it seems we've successfully added the new config file!${NRML}\n"
	fi

	cd -

}

update_config ()
{

	CONFIG_FULL_PATH="${1}"

	cd /${REPO_NAME}

	echo "${CONFIG_FULL_PATH}" | grep -e "/jls/" > /dev/null 2>&1
	if [ $? -eq 0 ]
	then
		# config file belongs to a jail
		JAIL_NAME=`echo ${CONFIG_FULL_PATH} | cut -d/ -f3`
		CONFIG_REPO_ROOT=configs/${JAIL_NAME}@${HOST_NAME}
		CONFIG_RELATIVE_PATH=`echo ${CONFIG_FULL_PATH} | sed "s|/jls/${JAIL_NAME}||"`
	else
		# config file belongs to the host
		CONFIG_REPO_ROOT=configs/${HOST_NAME}
		CONFIG_RELATIVE_PATH=${CONFIG_FULL_PATH}
	fi

	CONFIG_REPO_DIR=`dirname "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}"`
	if [ ! -d ${CONFIG_REPO_DIR} ]
	then
		mkdir -p ${CONFIG_REPO_DIR}
	fi

	if [ "${CONFIG_FULL_PATH}" = "" ] || [ ! -f ${CONFIG_FULL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The file '${CONFIG_FULL_PATH}' does not exist.\n       Aborting.\n"
		exit 40
	elif [ ! -f "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file '${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}' does not exist.\n       Aborting.\n"
		exit 41
	else
		if [ ! -n "${CHANGE_MESSAGE}" ]
		then
			echo -e ""
			readee -p "${LCYN}Enter a short explanation of the changes made: ${NRML}" CHANGE_MESSAGE
		fi
		cp ${CONFIG_FULL_PATH} ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${CONFIG_FULL_PATH}' to local git repo.\n       Aborting.\n"
			exit 42
		fi
		git add ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to update '${CONFIG_FULL_PATH}' to local git repo.\n       Aborting.\n"
			exit 43
		fi
		git commit -m "Updated config; '${CONFIG_FULL_PATH}' for ${HOST_NAME}: ${CHANGE_MESSAGE}."
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${CONFIG_FULL_PATH}' to local git repo."
			echo -e "       Please consider manually running 'git reset --hard' to previous commit.\n       Aborting.\n"
			exit 44
		fi
		if [ "${REPO_URI}" != "local" ] && [ "${GIT_NO_PUSH}" != "yes" ]
		then
			echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
			git_push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			fi
		fi
		echo -e "\n${LGRN}OK, it seems we've successfully updated the config file!${NRML}\n"
	fi

	cd -

}

update_local_repo ()
{

	if [ "${1}" = "--no-check-scripts" ]
	then
		CHECK_SCRIPTS="no"
	else
		CHECK_SCRIPTS="yes"
	fi

	if [ ! -d "/${REPO_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the local git repo ('/${REPO_NAME}') does not exist!\n       Aborting.\n"
		exit 12
	fi

	if [ "${REPO_URI}" = "local" ]
	then
		echo -e "\n${YELL}No need to update local repo, there is no remote repo.${NRML}\n"
	else
		cd /${REPO_NAME}

		# Get the pre-update git commit reference
		PRE_UPDATE_COMMIT_REF=`git log --format=format:%H -1`

		echo -e "\n${YELL}First, let's update the local git repo...${NRML}\n"
		git_pull
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to update the local git repo."
			echo -e "       Please use 'git status' to find the cause.\n       Aborting.\n"
			exit 13
		fi
		# Get the post-update git commit reference
		POST_UPDATE_COMMIT_REF=`git log --format=format:%H -1`

		if [ "${CHECK_SCRIPTS}" = "yes" ]
		then
			# Check if any scripts have been updated in this update cycle
			echo -e "\n${YELL}Checking if any scripts have been updated in this update...${NRML}\n"
			git diff-tree --no-commit-id --name-only -r ${PRE_UPDATE_COMMIT_REF} ${POST_UPDATE_COMMIT_REF} | grep "^scripts/"

			if [ ${?} -eq 0 ]
			then
				# Ask whether to perform an 'install-scripts'
				question_yes_no "\nIt seems that one or more scripts have been updated.\nWould you like to perform an 'install-scripts' now?"
				if [ "${ANSWER}" = "yes" ]
				then
					install_scripts_everywhere
				else
					echo -e "${YELL}You may perform an 'install-scripts' later by running the command:${NRML}\n${LBLU}${SCRIPT_NAME} install-scripts${NRML}"
				fi
				echo -e ""
			fi
		fi

		cd -
	fi

}

connect_internet ()
{

	# Get available interfaces and the quantity thereof
	NET_IFACES=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "${NET_IFACES_IGNORED}" | cut -d: -f1`
	NUM_NET_IFACES=`echo ${NET_IFACES} | wc -w`
	if [ ${NUM_NET_IFACES} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No usable network interfaces found.       Aborting.\n"
		exit 150
	fi

	WAN_NET_IFACE=""
	USES_PPP=""
	USES_VLAN=""
	VLAN_ID=""
	PPP_AUTHNAME=""
	PPP_AUTHKEY=""
	IS_WAN_IFACE_DHCP=""
	WAN_IFACE_IP=""
	WAN_IFACE_NETMASK=""
	WAN_ROUTER_IP=""

	# Configure WAN interface.
	if [ ${NUM_NET_IFACES} -lt 2 ]
	then
		WAN_NET_IFACE=${NET_IFACES}
		echo -e "\n${YELL}Using ${WAN_NET_IFACE} as the WAN (internet facing) network interface,${NRML}"
		echo -e "${YELL}since it's all that's available.${NRML}\n"
	else
		SELECT_IFACE_PROMPT="Select the WAN network interface (internet facing):"
		while [ "${WAN_NET_IFACE}" = "" ]
		do
			dialog --no-items --no-cancel --menu "${SELECT_IFACE_PROMPT}" 12 40 10 ${NET_IFACES} 2> ${DIALOG_OUT_FILE}
			WAN_NET_IFACE_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${WAN_NET_IFACE_TEMP}${LCYN}' as the WAN interface for this host.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				WAN_NET_IFACE="${WAN_NET_IFACE_TEMP}"
			fi
		done
	fi

	# Optionally configure PPP
	question_yes_no "\nDo you want to use PPPoE for the WAN interface (internet facing)?"
	USES_PPP=${ANSWER}
	if [ "${USES_PPP}" = "yes" ]
	then
		question_yes_no "\nDoes your PPPoE connection require a VLAN tag?"
		USES_VLAN=${ANSWER}
		if [ "${USES_VLAN}" = "yes" ]
		then
			while [ "${VLAN_ID}" = "" ]
			do
				echo -e ""
				readee -p "${LCYN}Enter VLAN ID (tag): ${NRML}" VLAN_ID_TEMP
				# Check that the VLAN ID only contains numbers being a minimum of 1 and maximum of 4096.
				test_valid_integer "${VLAN_ID_TEMP}" 1 4096
				if [ "${VALID_INTEGER}" = "no" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} The VLAN ID can not be '${VLAN_ID}'."
					echo -e "       It must be a number between 1 and 4096.\n"
				else
					question_yes_no "\nYou have entered '${NRML}${VLAN_ID_TEMP}${LCYN}' as the VLAN ID.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						VLAN_ID=${VLAN_ID_TEMP}
					fi
				fi
			done
		fi

		# Get PPP authname
		while [ "${PPP_AUTHNAME}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter PPP authname (dialing username): ${NRML}" PPP_AUTHNAME_TEMP
			if [ "${PPP_AUTHNAME_TEMP}" = "" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Authname empty, try again!\n"
			else
				question_yes_no "\nYou have entered '${NRML}${PPP_AUTHNAME_TEMP}${LCYN}' as the PPP authname.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					PPP_AUTHNAME=${PPP_AUTHNAME_TEMP}
				fi
			fi
		done

		# Get PPP authkey
		while [ "${PPP_AUTHKEY}" = "" ]
		do
			echo -e ""
			readee -s -p "${LCYN}Enter PPP authkey (dialing password): ${NRML}" PPP_AUTHKEY_TEMP1
			readee -s -p "${LCYN}Re-enter PPP authkey                : ${NRML}" PPP_AUTHKEY_TEMP2
			
			if [ "${PPP_AUTHKEY_TEMP1}" != "${PPP_AUTHKEY_TEMP2}" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Authkey mismatch, try again!\n"
			elif [ "${PPP_AUTHKEY_TEMP1}" = "" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Authkey not entered, try again!\n"
			else
				PPP_AUTHKEY=${PPP_AUTHKEY_TEMP1}
			fi
		done

		echo -e ""
	fi
	# END: configure PPP


	# Configure WAN interface IP address and subnet mask
	question_yes_no "\nDo you want to use DHCP for the WAN interface?"
	IS_WAN_IFACE_DHCP=${ANSWER}
	if [ "${IS_WAN_IFACE_DHCP}" = "no" ]
	then
		# Set up static IP and netmask for WAN interface
		while [ "${WAN_IFACE_IP}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter static IP for WAN interface: ${NRML}" WAN_IFACE_IP_TEMP
			test_valid_inet_address "${WAN_IFACE_IP_TEMP}"
			if [ "${VALID_INET_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${WAN_IFACE_IP_TEMP}${LCYN}' as the WAN interface IP address.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_IFACE_IP=${WAN_IFACE_IP_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} IP address is invalid!\n"
			fi
		done

		while [ "${WAN_IFACE_NETMASK}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter netmask for WAN interface: ${NRML}" WAN_IFACE_NETMASK_TEMP
			test_valid_inet_address "${WAN_IFACE_NETMASK_TEMP}"
			if [ "${VALID_INET_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${WAN_IFACE_NETMASK_TEMP}${LCYN}' as the WAN interface netmask.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_IFACE_NETMASK=${WAN_IFACE_NETMASK_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} Subnet mask is invalid!\n"
			fi
		done

		# Set default router
		while [ "${WAN_ROUTER_IP}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter the default router IP address for this host: ${NRML}" WAN_ROUTER_IP_TEMP
			test_valid_inet_address "${WAN_ROUTER_IP_TEMP}"
			if [ "${VALID_INET_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${WAN_ROUTER_IP_TEMP}${LCYN}' as the default router.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_ROUTER_IP=${WAN_ROUTER_IP_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} Default router IP address is invalid!\n"
			fi
		done
	fi
	# END: if IS_WAN_IFACE_DHCP = no


	# Stop services that may interfere with a simple internet connection
	echo -e "\n${YELL}Stopping unwanted network services...${NRML}\n"
	service natd onestop > /dev/null 2>&1
	service pflog onestop > /dev/null 2>&1
	service pf onestop > /dev/null 2>&1
	service ipfw onestop > /dev/null 2>&1
	service ipfilter onestop > /dev/null 2>&1
	service ppp onestop > /dev/null 2>&1
	pkill ppp

	sleep 10

	# Destroy all existing interfaces
	echo -e "\n${YELL}Destroying existing interfaces...${NRML}\n"
	NET_IFACES_TO_DESTROY=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "^lo0" | cut -d: -f1`
	for IFACE_TO_DESTROY in ${NET_IFACES_TO_DESTROY}
	do
		ifconfig ${IFACE_TO_DESTROY} down delete > /dev/null 2>&1
		ifconfig ${IFACE_TO_DESTROY} destroy > /dev/null 2>&1
	done

	# Flush routing table
	echo -e "\n${YELL}Flushing routing table...${NRML}\n"
	route flush > /dev/null 2>&1

	# Backup and replace resolv.conf with a generic working copy
	backup_file /etc/resolv.conf connect-internet
	echo "nameserver 1.1.1.1" > /etc/resolv.conf
	echo "nameserver 8.8.8.8" >> /etc/resolv.conf

	# Setup interface and routing
	echo -e "\n${YELL}Setup WAN interface and routing...${NRML}\n"
	ifconfig ${WAN_NET_IFACE} up

	if [ "${USES_PPP}" = "yes" ]
	then
		backup_file /etc/ppp/ppp.conf connect-internet
		echo "default:" > /etc/ppp/ppp.conf
		echo " set log Phase Chat LCP IPCP CCP tun command" >> /etc/ppp/ppp.conf
		echo " ident user-ppp VERSION" >> /etc/ppp/ppp.conf
		echo " disable iface-alias" >> /etc/ppp/ppp.conf
		echo " iface clear" >> /etc/ppp/ppp.conf
		if [ "${USES_VLAN}" = "yes" ]
		then
			ifconfig ${WAN_NET_IFACE}.${VLAN_ID} create vlan ${VLAN_ID} vlandev ${WAN_NET_IFACE} up
			echo " set device PPPoE:${WAN_NET_IFACE}_${VLAN_ID}" >> /etc/ppp/ppp.conf
		else
			echo " set device PPPoE:${WAN_NET_IFACE}" >> /etc/ppp/ppp.conf
		fi
		echo " set authname ${PPP_AUTHNAME}" >> /etc/ppp/ppp.conf
		echo " set authkey ${PPP_AUTHKEY}" >> /etc/ppp/ppp.conf
		echo " set dial" >> /etc/ppp/ppp.conf
		echo " set login" >> /etc/ppp/ppp.conf
		echo " set redial 30 0" >> /etc/ppp/ppp.conf
		echo " set reconnect 5 0" >> /etc/ppp/ppp.conf
		echo " set timeout 0" >> /etc/ppp/ppp.conf
		echo " enable lqr echo" >> /etc/ppp/ppp.conf
		echo " set lqrperiod 45" >> /etc/ppp/ppp.conf
		if [ "${IS_WAN_IFACE_DHCP}" = "yes"  ]
		then
			echo " set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255 0.0.0.0" >> /etc/ppp/ppp.conf
		else
			echo " set ifaddr ${WAN_IFACE_IP} ${WAN_ROUTER_IP} ${WAN_IFACE_NETMASK} 0.0.0.0" >> /etc/ppp/ppp.conf
		fi
		echo " add default HISADDR" >> /etc/ppp/ppp.conf
		ppp -ddial
	else
		if [ "${IS_WAN_IFACE_DHCP}" = "yes" ]
		then
			pkill dhclient > /dev/null 2>&1
			backup_file /etc/resolv.conf connect-internet
			dhclient ${WAN_NET_IFACE}
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} DHCP failed on ${WAN_NET_IFACE}!\n       Aborting.\n"
				exit 152
			fi
		else
			ifconfig ${WAN_NET_IFACE} inet ${WAN_IFACE_IP} netmask ${WAN_IFACE_NETMASK} up
			route add default ${WAN_ROUTER_IP} > /dev/null 2>&1
		fi
	fi

	IS_IP_WORKING="no"
	WAIT_CYCLES=0

	while [ "${IS_IP_WORKING}" = "no" ] && [ ${WAIT_CYCLES} -lt 10 ]
	do
		# Sleep for 10 seconds for connection to establish
		echo -e "\n${YELL}Waiting for 10 seconds for connection to establish...${NRML}\n"
		sleep 10

		# Test internet connection
		test_ping_host 8.8.8.8
		if [ "${VALID_HOST_PING}" = "yes" ]
		then
			IS_IP_WORKING="yes"
		fi

		WAIT_CYCLES=$(( ${WAIT_CYCLES} + 1 ))
	done

	if [ "${IS_IP_WORKING}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} IP connection failed! Unable to ping 8.8.8.8.\n       Aborting.\n"
		exit 153
	fi

	IS_DNS_WORKING="no"
	WAIT_CYCLES=0

	while [ "${IS_DNS_WORKING}" = "no" ] && [ ${WAIT_CYCLES} -lt 3 ]
	do

		if [ ${WAIT_CYCLES} -ne 0 ]
		then
			# Sleep for 10 seconds for DNS to establish
			echo -e "\n${YELL}Waiting for 10 seconds for DNS to establish...${NRML}\n"
			sleep 10
		fi

		# Test DNS
		host google.com > /dev/null 2>&1
		if [ ${?} -eq 0 ]
		then
			IS_DNS_WORKING="yes"
		fi
		
		WAIT_CYCLES=$(( ${WAIT_CYCLES} + 1 ))
	done
			
	if [ "${IS_DNS_WORKING}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} internet DNS failed! Unable to lookup google.com.\n       Aborting.\n"
		exit 154
	fi

	echo -e "\n${LGRN}Successfully connected to the internet!${NRML}\n"

	# END: configure WAN interface

}

init_host_cleanup ()
{
	rm -rf configs/${HOST_NAME}
	exit 50
}

init_host ()
{

	trap 'init_host_cleanup' HUP INT QUIT KILL TERM

	# NOTE: we have to assume we only have base userland at this point. No local repo either.

	HOST_NAME=${1}
	DOMAIN_NAME=${2}

	# Check that the host name is valid.
	test_valid_host_name "${HOST_NAME}"
	if [ "${VALID_HOST_NAME}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The hostname can not be '${HOST_NAME}'."
		echo -e "       It must only contain letters, numbers and hyphens."
		echo -e "       It must not begin or end with a hyphen."
		echo -e "       Aborting.\n"
		exit 51
	fi

	# Check that the domain name is valid.
	test_valid_fqhn  "${DOMAIN_NAME}"
	if [ "${VALID_FQHN}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The domain name can not be '${DOMAIN_NAME}'."
		echo -e "       It must only contain letters, numbers, periods and hyphens."
		echo -e "       It must not begin or end with a hyphen or a period."
		echo -e "       Aborting.\n"
		exit 52
	fi

	# Update pkgng repositories
	echo -e "\n${YELL}First we need to update pkg (pkgng) repositories...${NRML}\n"
	pkg update
	if [ $? -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to update pkg (pkgng) repositories.\n       Aborting.\n"
		exit 53
	fi

	# Install essential packages
	echo -e "\n${YELL}Next we need to install some essential packages...${NRML}\n"
	pause_prompt 8
	pkg update -f
	pkg install -y ${ESSENTIAL_PACKAGES}
	if [ $? -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to install essential packages.\n       Aborting.\n"
		exit 54
	fi

	# Initialise the local private repo
	init_local_repo

	# Initialise the git config, so we can commit and push without warnings.
	init_git_config

	# Check that the local repo is not empty, otherwise pull a fresh skeleton.
	if [ ! -d "/${REPO_NAME}/configs" ]
	then
		# Get a skeleton from the public upstream skeleton repo.
		echo -e "\n${ORNG}WARNING:${NRML} Repo is invalid! It is missing the configs directory."
	    echo -e "         we will attempt to fetch the upstream skeleton git repo...${NRML}\n"
		pause_prompt 8
		upgrade_repo_from_upstream
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to get a skeleton from the public upstream skeleton git repo.\n       Aborting.\n"
			exit 55
		fi
	fi

	cd /${REPO_NAME}

	# Check that the hostname is not already taken.
	if [ -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The hostname can not be '${HOST_NAME}'!"
		echo -e "       It is already registered as a host in the repo."
		echo -e "       Aborting.\n"
		exit 56
	fi

	# Copy init-host template configs to the repo
	mkdir configs/${HOST_NAME}
	install_file_tree config-templates/init-host configs/${HOST_NAME}/

	# Get available interfaces and the quantity thereof
	NET_IFACES=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "${NET_IFACES_IGNORED}" | cut -d: -f1`
	NUM_NET_IFACES=`echo ${NET_IFACES} | wc -w`
	if [ ${NUM_NET_IFACES} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No usable network interfaces found!\n       Aborting.\n"
		init_host_cleanup
		exit 57
	fi

	SERVER_TYPE=""
	while [ "${SERVER_TYPE}" = "" ]
	do
		dialog --no-cancel --menu "Select the type of server:" 12 80 10 \
					 "remote" "Remote Server (Datacenter/Cloud)" \
					 "primary_local" "Primary Local Server (Internet & LAN Gateway/NAT Router)" \
					 "auxiliary_local" "Auxiliary Local Server (LAN)" \
					 2> ${DIALOG_OUT_FILE}
		SERVER_TYPE_TEMP=`cat ${DIALOG_OUT_FILE}`
		echo -e "\n"
		question_yes_no "\nYou have selected '${NRML}${SERVER_TYPE_TEMP}${LCYN}' as the server type for this host.\nIs this correct?"
		if [ "${ANSWER}" = "yes" ]
		then
			SERVER_TYPE="${SERVER_TYPE_TEMP}"
		fi
	done

	WAN_NET_IFACE=""
	LAN_NET_IFACE=""
	USES_PPP=""
	USES_VLAN=""
	VLAN_ID=""
	PPP_AUTHNAME=""
	PPP_AUTHKEY=""
	IS_WAN_IFACE_DHCP=""
	IS_LAN_IFACE_DHCP=""
	WAN_IFACE_IP=""
	LAN_IFACE_IP=""
	WAN_IFACE_NETMASK=""
	LAN_IFACE_NETMASK=""
	WAN_ROUTER_IP=""

	case ${SERVER_TYPE} in
		remote)
			LAN_NET_IFACE="lo1"
			;;
		primary_local)
			if [ ${NUM_NET_IFACES} -lt 2 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Not enough network interfaces found (2 required)!\n       Aborting.\n"
				init_host_cleanup
				exit 58
			fi
			;;
		auxiliary_local)
			WAN_NET_IFACE="NULL"
			;;
	esac

	# Configure WAN interface (if required).
	if [ "${WAN_NET_IFACE}" != "NULL" ]
	then
		if [ ${NUM_NET_IFACES} -lt 2 ]
		then
			WAN_NET_IFACE=${NET_IFACES}
			echo -e "\n${YELL}Using ${WAN_NET_IFACE} as the WAN (internet facing) network interface,${NRML}"
			echo -e "${YELL}since it's all that's available.${NRML}\n"
		else
			SELECT_IFACE_PROMPT="Select the WAN network interface (internet facing):"
			while [ "${WAN_NET_IFACE}" = "" ]
			do
				dialog --no-items --no-cancel --menu "${SELECT_IFACE_PROMPT}" 12 40 10 ${NET_IFACES} 2> ${DIALOG_OUT_FILE}
				WAN_NET_IFACE_TEMP=`cat ${DIALOG_OUT_FILE}`
				echo -e "\n"
				question_yes_no "\nYou have selected '${NRML}${WAN_NET_IFACE_TEMP}${LCYN}' as the WAN interface for this host.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_NET_IFACE="${WAN_NET_IFACE_TEMP}"
				fi
			done
		fi

		sed -i "" "s/WAN_NET_IFACE/${WAN_NET_IFACE}/g" configs/${HOST_NAME}/etc/rc.conf

		# Optionally configure PPP
		question_yes_no "\nDo you want to use PPPoE for the WAN interface (internet facing)?"
		USES_PPP=${ANSWER}
		if [ "${USES_PPP}" = "yes" ]
		then
			question_yes_no "\nDoes your PPPoE connection require a VLAN tag?"
			USES_VLAN=${ANSWER}
			if [ "${USES_VLAN}" = "yes" ]
			then
				while [ "${VLAN_ID}" = "" ]
				do
					echo -e ""
					readee -p "${LCYN}Enter VLAN ID (tag): ${NRML}" VLAN_ID_TEMP
					# Check that the VLAN ID only contains numbers being a minimum of 1 and maximum of 4096.
					test_valid_integer "${VLAN_ID_TEMP}" 1 4096
					if [ "${VALID_INTEGER}" = "no" ]
					then
						echo -e "\n${LRED}ERROR:${NRML} The VLAN ID can not be '${VLAN_ID}'."
						echo -e "       It must be a number between 1 and 4096.\n"
					else
						question_yes_no "\nYou have entered '${NRML}${VLAN_ID_TEMP}${LCYN}' as the VLAN ID.\nIs this correct?"
						if [ "${ANSWER}" = "yes" ]
						then
							VLAN_ID=${VLAN_ID_TEMP}
						fi
					fi
				done
				sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"up\"\\${CARRIAGE_RETURN}ifconfig_${WAN_NET_IFACE}_${VLAN_ID}=\"up\"/" configs/${HOST_NAME}/etc/rc.conf
				sed -i "" "s/^#vlans_${WAN_NET_IFACE}=\"\"/vlans_${WAN_NET_IFACE}=\"${VLAN_ID}\"/" configs/${HOST_NAME}/etc/rc.conf
				sed -i "" "s/PPP_IFACE/${WAN_NET_IFACE}_${VLAN_ID}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			else
				sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"up\"/" configs/${HOST_NAME}/etc/rc.conf
				sed -i "" "s/PPP_IFACE/${WAN_NET_IFACE}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			fi
	
			# Get PPP authname
			while [ "${PPP_AUTHNAME}" = "" ]
			do
				echo -e ""
				readee -p "${LCYN}Enter PPP authname (dialing username): ${NRML}" PPP_AUTHNAME_TEMP
				
				if [ "${PPP_AUTHNAME_TEMP}" = "" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Authname empty, try again!\n"
				else
					question_yes_no "\nYou have entered '${NRML}${PPP_AUTHNAME_TEMP}${LCYN}' as the PPP authname.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						PPP_AUTHNAME=${PPP_AUTHNAME_TEMP}
					fi
				fi
			done

			# Get PPP authkey
			while [ "${PPP_AUTHKEY}" = "" ]
			do
				echo -e ""
				readee -s -p "${LCYN}Enter PPP authkey (dialing password): ${NRML}" PPP_AUTHKEY_TEMP1
				readee -s -p "${LCYN}Re-enter PPP authkey                : ${NRML}" PPP_AUTHKEY_TEMP2

				if [ "${PPP_AUTHKEY_TEMP1}" != "${PPP_AUTHKEY_TEMP2}" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Authkey mismatch, try again!\n"
				elif [ "${PPP_AUTHKEY_TEMP1}" = "" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Authkey not entered, try again!\n"
				else
					PPP_AUTHKEY=${PPP_AUTHKEY_TEMP1}
				fi
			done

			echo -e ""

			sed -i "" "s/isp_username/${PPP_AUTHNAME}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			sed -i "" "s/isp_password/${PPP_AUTHKEY}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			sed -i "" "s/ppp_enable=\"NO\"/ppp_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
			sed -i "" "s/ppp_nat=\"NO\"/ppp_nat=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
			echo "tun0" > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/net_iface_wan.conf
		else
			echo "${WAN_NET_IFACE}" > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/net_iface_wan.conf
		fi
		# END: configure PPP


		# Configure WAN interface IP address and subnet mask
		question_yes_no "\nDo you want to use DHCP for the WAN interface?"
		IS_WAN_IFACE_DHCP=${ANSWER}
		if [ "${IS_WAN_IFACE_DHCP}" = "no" ]
		then
			# Set up static IP and netmask for WAN interface
			while [ "${WAN_IFACE_IP}" = "" ]
			do
				echo -e ""
				readee -p "${LCYN}Enter static IP for WAN interface: ${NRML}" WAN_IFACE_IP_TEMP
				test_valid_inet_address "${WAN_IFACE_IP_TEMP}"
				if [ "${VALID_INET_ADDRESS}" = "yes" ]
				then
					get_class_c_subnet ${WAN_IFACE_IP_TEMP}
					get_class_b_subnet ${WAN_IFACE_IP_TEMP}
					WAN_SUBNET_C="${CLASS_C_SUBNET}"
					WAN_SUBNET_B="${CLASS_B_SUBNET}"
					if [ "${WAN_SUBNET_B}" = "${FDO_LAN_SUBNET_B}" ]
					then
						echo -e "\n${LRED}ERROR:${NRML} In a gateway configuration the WAN interface IP address must not be in"
						echo -e "       the '${FDO_LAN_SUBNET_B}.*.*' subnet!\n"
					else
						question_yes_no "\nYou have entered '${NRML}${WAN_IFACE_IP_TEMP}${LCYN}' as the WAN interface IP address.\nIs this correct?"
						if [ "${ANSWER}" = "yes" ]
						then
							WAN_IFACE_IP=${WAN_IFACE_IP_TEMP}
						fi
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} IP address is invalid!\n"
				fi
			done

			while [ "${WAN_IFACE_NETMASK}" = "" ]
			do
				echo -e ""
				readee -p "${LCYN}Enter netmask for WAN interface: ${NRML}" WAN_IFACE_NETMASK_TEMP
				test_valid_inet_address "${WAN_IFACE_NETMASK_TEMP}"
				if [ "${VALID_INET_ADDRESS}" = "yes" ]
				then
					question_yes_no "\nYou have entered '${NRML}${WAN_IFACE_NETMASK_TEMP}${LCYN}' as the WAN interface netmask.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						WAN_IFACE_NETMASK=${WAN_IFACE_NETMASK_TEMP}
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} Subnet mask is invalid!\n"
				fi
			done

			# Set default router
			while [ "${WAN_ROUTER_IP}" = "" ]
			do
				echo -e ""
				readee -p "${LCYN}Enter the default router IP address for this host: ${NRML}" WAN_ROUTER_IP_TEMP
				test_valid_inet_address "${WAN_ROUTER_IP_TEMP}"
				if [ "${VALID_INET_ADDRESS}" = "yes" ]
				then
					question_yes_no "\nYou have entered '${NRML}${WAN_ROUTER_IP_TEMP}${LCYN}' as the default router.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						WAN_ROUTER_IP=${WAN_ROUTER_IP_TEMP}
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} Default router IP address is invalid!\n"
				fi
			done
	
			if [ "${USES_PPP}" = "yes" ]
			then
				sed -i "" "s|^ set ifaddr .*| set ifaddr ${WAN_IFACE_IP} ${WAN_ROUTER_IP} ${WAN_IFACE_NETMASK} 0.0.0.0|" configs/${HOST_NAME}/etc/ppp/ppp.conf
			else
				sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"inet ${WAN_IFACE_IP} netmask ${WAN_IFACE_NETMASK}\"/" configs/${HOST_NAME}/etc/rc.conf
				sed -i "" "s/^#defaultrouter=\"\"/defaultrouter=\"${WAN_ROUTER_IP}\"/" configs/${HOST_NAME}/etc/rc.conf
			fi
		elif [ "${USES_PPP}" = "yes" ]
		then
			# WAN PPP connection uses Dynamic IP
		else
			# WAN IP interface uses DHCP
			sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"DHCP\"/" configs/${HOST_NAME}/etc/rc.conf
		fi
		# END: if IS_WAN_IFACE_DHCP = no

		sed -i "" "s/^gateway_enable\=.*/gateway_enable\=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf

	fi
	# END: configure WAN interface


	# Configure LAN interface
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		REMAINING_NET_IFACES=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "${NET_IFACES_IGNORED}|^${WAN_NET_IFACE}" | cut -d: -f1`
		NUM_REMAINING_NET_IFACES=`echo ${REMAINING_NET_IFACES} | wc -w`
		if [ ${NUM_REMAINING_NET_IFACES} -lt 2 ]
		then
			LAN_NET_IFACE=${REMAINING_NET_IFACES}
			echo -e "\n\n${YELL}Using ${LAN_NET_IFACE} as the LAN network interface,${NRML}"
			echo -e "${YELL}since it's all that's available.${NRML}\n"
		else
			SELECT_IFACE_PROMPT="Select the LAN network interface:"
			while [ "${LAN_NET_IFACE}" = "" ]
			do
				dialog --no-items --no-cancel --menu "${SELECT_IFACE_PROMPT}" 12 40 10 ${REMAINING_NET_IFACES} 2> ${DIALOG_OUT_FILE}
				LAN_NET_IFACE_TEMP=`cat ${DIALOG_OUT_FILE}`
				echo -e "\n"
				question_yes_no "\nYou have selected '${NRML}${LAN_NET_IFACE_TEMP}${LCYN}' as the LAN interface for this host.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					LAN_NET_IFACE="${LAN_NET_IFACE_TEMP}"
				fi
			done
		fi
	fi

	if [ "${SERVER_TYPE}" = "remote" ]
	then
		sed -i "" "s/^#cloned_interfaces=\"\"/cloned_interfaces=\"${LAN_NET_IFACE}\"/" configs/${HOST_NAME}/etc/rc.conf
	fi
	echo "${LAN_NET_IFACE}" > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/net_iface_lan.conf
	sed -i "" "s/LAN_NET_IFACE/${LAN_NET_IFACE}/g" configs/${HOST_NAME}/etc/rc.conf

	LAN_SUBNET_C="${SERVERS_LAN_SUBNET_C}"
	LAN_IFACE_NETMASK="${FDO_LAN_SUBNET_MASK}"

	if [ "${WAN_NET_IFACE}" != "NULL" ]
	then
		# ASSUME this host is a remote or primary_local type server
		LAN_IFACE_IP="${FDO_LAN_GATEWAY_IP}"
		sed -i "" "s/^#ifconfig_${LAN_NET_IFACE}=\"\"/ifconfig_${LAN_NET_IFACE}=\"inet ${LAN_IFACE_IP} netmask ${LAN_IFACE_NETMASK}\"/" configs/${HOST_NAME}/etc/rc.conf
		if [ "${USES_PPP}" = "yes" ]
		then
			sed -i "" "s/^ #nat/ nat/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			sed -i "" "s/LAN_SUBNET_C/${LAN_SUBNET_C}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
		fi
	else
		# ASSUME this host is an aux_local type server
		question_yes_no "\nDo you want to use DHCP for the LAN interface?"
		IS_LAN_IFACE_DHCP=${ANSWER}
		if [ "${IS_LAN_IFACE_DHCP}" = "no" ]
		then
			# Set up static IP and netmask for LAN interface
			SELECT_IP_LIST=""
			CURRENT_IP=${AUX_LOCAL_SERVER_IP_MIN}
			while [ ${CURRENT_IP} -le ${AUX_LOCAL_SERVER_IP_MAX} ]
			do
				SELECT_IP_LIST="${SELECT_IP_LIST} ${CURRENT_IP} ${LAN_SUBNET_C}.${CURRENT_IP}"
				CURRENT_IP=$(( ${CURRENT_IP} + 1 ))
			done

			while [ "${LAN_IFACE_IP}" = "" ]
			do
				dialog --no-cancel --menu "Select LAN interface IP:" 18 40 16 ${SELECT_IP_LIST} 2> ${DIALOG_OUT_FILE}
				IP_LAST_DIGIT=`cat ${DIALOG_OUT_FILE}`
				LAN_IFACE_IP_TEMP="${LAN_SUBNET_C}.${IP_LAST_DIGIT}"
				if [ "${LAN_IFACE_IP_TEMP}" = "" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} No IP address selected! Try again.\n"
					pause_prompt 5
				else
					echo -e "\n"
					question_yes_no "\nYou have selected '${NRML}${LAN_IFACE_IP_TEMP}${LCYN}' as the LAN interface IP address.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						LAN_IFACE_IP=${LAN_IFACE_IP_TEMP}
					fi
				fi
			done
			sed -i "" "s/^#ifconfig_${LAN_NET_IFACE}=\"\"/ifconfig_${LAN_NET_IFACE}=\"inet ${LAN_IFACE_IP} netmask ${LAN_IFACE_NETMASK}\"/" configs/${HOST_NAME}/etc/rc.conf
		else
			sed -i "" "s/^#ifconfig_${LAN_NET_IFACE}=\"\"/ifconfig_${LAN_NET_IFACE}=\"DHCP\"/" configs/${HOST_NAME}/etc/rc.conf
		fi
		# END: if IS_LAN_IFACE_DHCP = no
	fi
	# END: if WAN_NET_IFACE != NULL

	sed -i "" "s|LAN_SUBNET_C|${LAN_SUBNET_C}|g" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s|LAN_SUBNET_C|${LAN_SUBNET_C}|g" configs/${HOST_NAME}/etc/jail.conf
	sed -i "" "s|LAN_NET_IFACE|${LAN_NET_IFACE}|g" configs/${HOST_NAME}/etc/jail.conf

	# Update hostname
	sed -i "" "s/^hostname\=.*/hostname\=${HOST_NAME}\.${DOMAIN_NAME}/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/FDO_LAN_IP/${LAN_IFACE_IP}/g" configs/${HOST_NAME}/etc/hosts
	sed -i "" "s/FDO_HOST_NAME/${HOST_NAME}/g" configs/${HOST_NAME}/etc/hosts
	sed -i "" "s/FDO_DOMAIN_NAME/${DOMAIN_NAME}/g" configs/${HOST_NAME}/etc/hosts
	hostname ${HOST_NAME}.${DOMAIN_NAME}

	# END: configure LAN interface

	# Configure firewall / NAT router
	if [ "${WAN_NET_IFACE}" != "NULL" ] && [ "${USES_PPP}" = "no" ]
	then
		sed -i "" "s|WAN_NET_IFACE|${WAN_NET_IFACE}|g" configs/${HOST_NAME}/etc/pf.conf
		sed -i "" "s|LAN_NET_IFACE|${LAN_NET_IFACE}|g" configs/${HOST_NAME}/etc/pf.conf
		sed -i "" "s|LAN_SUBNET_C|${LAN_SUBNET_C}|g" configs/${HOST_NAME}/etc/pf.conf
		sed -i "" "s|^pf_enable=.*|pf_enable\=\"YES\"|" configs/${HOST_NAME}/etc/rc.conf
		sed -i "" "s|^pflog_enable=.*|pflog_enable\=\"YES\"|" configs/${HOST_NAME}/etc/rc.conf
	fi

	# Additional network configuration
	sed -i "" "s|LAN_SUBNET_C|${LAN_SUBNET_C}|" configs/${HOST_NAME}/etc/resolv.conf.static
	sed -i "" "s|DOMAIN_NAME|${DOMAIN_NAME}|" configs/${HOST_NAME}/etc/resolv.conf.static

	# Ask if we want to continue past point of no return
	question_yes_no "\nWe will now make permanent changes to the new host system,\nwould you like to continue?"
	if [ "${ANSWER}" = "no" ]
	then
		init_host_cleanup
	fi

	#### POINT OF NO RETURN ####

	# Backup existing core system conf files
	backup_file /etc/rc.conf init-host
	backup_file /etc/sysctl.conf init-host
	backup_file /boot/loader.conf init-host

	# Install init-host configs to the system so that FDO user has a useful profile
	install_file_tree configs/${HOST_NAME} /

	# Set password for toor user
	echo -e "\n${LCYN}Next we need to set a password for the toor user (interactive root shell${NRML}"
	echo -e "${LCYN}account). This can be the same as the root user password.${NRML}\n"
	passwd toor

	# Set login shell for toor user
	chsh -s bash toor

	# Add arbitrary ssh login user
	echo -e "\n\n${LCYN}Next we will add an arbitrary user so that we can login via SSH.${NRML}"
	echo -e "${LCYN}It's recommended NOT to use an easy to guess username like admin or your own${NRML}"
	echo -e "${LCYN}name.${NRML}"

	# Get valid login name
	FDO_USERNAME=""
	while [ "${FDO_USERNAME}" = "" ]
	do
		echo -e ""
		readee -p "${LCYN}Enter login account username: ${NRML}" FDO_USERNAME_TEMP
		# Check that the username only contains letters, numbers, periods, underscores and hyphens with a minimum of 3 characters.
		TEST=`echo "${FDO_USERNAME_TEMP}" | sed -r "s/^[a-z0-9][a-z0-9\.\_\-]+[a-z0-9]//" | wc -L`
		if [ ${TEST} -ne 0 ] || [ "${FDO_USERNAME_TEMP}" = "" ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The username can not be '${FDO_USERNAME_TEMP}'."
			echo -e "       It must be at least three characters and only contain lower case"
			echo -e "       letters, numbers, periods, underscores and hyphens.\n"
		else
			question_yes_no "\nYou have entered '${NRML}${FDO_USERNAME_TEMP}${LCYN}' as the login account username.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				FDO_USERNAME=${FDO_USERNAME_TEMP}
			fi
		fi
	done

	pw useradd ${FDO_USERNAME} -m -s /usr/local/bin/bash -c "FDo login user" -G "operator wheel"
	echo -e "\n${LCYN}And now give this user account a password.${NRML}\n"
	passwd ${FDO_USERNAME}

	echo -e "\n${LGRN}You should now be able to switch user from ${FDO_USERNAME}${NRML}"
	echo -e "${LGRN}to toor using the command:${NRML}"
	echo -e "${LBLU}root${NRML}\n"

	# Store FDO_USERNAME in it's config file
	echo ${FDO_USERNAME} > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/fdo_username.conf

	# Timezone setup
	echo -e ""
	readee -p "${LCYN}Let's perform the hosts timezone setup. Press enter to proceed... ${NRML}" ENTER_PRESSED
	tzsetup
	TZ_AVAILABLE=`cat /usr/share/zoneinfo/zone.tab | egrep -v "^#" | awk '{print $3}' | sort`
	TZ=""
	while [ "${TZ}" = "" ]
	do
		dialog --no-cancel --no-items --menu "Select timezone for the hosts TZ environment variable:" 30 60 26 ${TZ_AVAILABLE} 2> ${DIALOG_OUT_FILE}
		TZ_TEMP=`cat ${DIALOG_OUT_FILE}`
		echo -e "\n"
		question_yes_no "\nYou have selected '${NRML}${TZ_TEMP}${LCYN}' for the TZ for this host.\nIs this correct?"
		if [ "${ANSWER}" = "yes" ]
		then
			TZ="${TZ_TEMP}"
		fi
	done
	sed -i "" "s|HOST_TIMEZONE|${TZ}|" configs/${HOST_NAME}/etc/profile

	# Set correct time/date from ntp.org
	echo -e "\n${YELL}Setting correct time and date from ntp.org...${NRML}\n"
	service ntpd stop
	ntpdate pool.ntp.org
	service ntpd start

	# Locale setup
	echo -e "\n"
	question_yes_no "\nWould you like to configure the locale for this host?"
	if [ "${ANSWER}" = "yes" ]
	then
		LOCALE_AVAILABLE=`ls -1 /usr/share/locale/ | egrep -v "^UTF-8" | sort`
		LOCALE=""
		while [ "${LOCALE}" = "" ]
		do
			dialog --no-cancel --no-items --menu "Select the locale for the host:" 30 60 26 ${LOCALE_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			LOCALE_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${LOCALE_TEMP}${LCYN}' for the locale for this host.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				LOCALE="${LOCALE_TEMP}"
			fi
		done
		sed -i "" "s|HOST_LOCALE|${LOCALE}|" configs/${HOST_NAME}/etc/profile
	fi

	#### CONFIG PROFILE FINISHED ####

	# Install scripts to the system
	install_scripts /

	# Install final init-host configs to the system
	install_file_tree configs/${HOST_NAME} /

	# Create ssl certs directory
	mkdir -p /usr/local/etc/ssl/certs

	# If not using DHCP, symlink resolv.conf.static to resolv.conf
	if [ "${IS_PRIMARY_IFACE_DHCP}" = "no" ] || [ "${USES_PPP}" = "yes" ]
	then
		backup_file /etc/resolv.conf init-host
		rm /etc/resolv.conf
		ln -s /etc/resolv.conf.static /etc/resolv.conf
	fi

	# Remove the .gitignore from the local repo configs directory (if it exists)
	git rm configs/.gitignore 2> /dev/null

	# Commit this hosts config to the local repo
	echo -e "\n${YELL}Committing this hosts config to the local repo...${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Adding new host; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to the private remote repo...${NRML}\n"
		git_push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished setting up the new host:${NRML}"
	echo -e "${LGRN}'${HOST_NAME}'.${NRML}\n\n"
	question_yes_no "Would you like to reboot now for new settings to take full effect?\n[RECOMMENDED]"
	echo -e "\n"
	if [ "${ANSWER}" = "yes" ]
	then
		reboot
	fi

	cd -

} ## END: init_host ()

patch_host()
{

	PATCH_HOST_NEEDS_REBOOT="no"

	echo -e "\n${YELL}We are now going to perform a 'freebsd-update fetch' operation.${NRML}"
	echo -e "${YELL}It may take a while...${NRML}\n"

	NOW=`date "+%Y-%m-%d_%H-%M-%S"`
	PAGER=cat freebsd-update fetch > /tmp/fdo-freebsd-update-output.host.fetch.${NOW}
	if [ ${?} -ne 0 ]
	then
		tail -4 /tmp/fdo-freebsd-update-output.host.fetch.${NOW} | egrep "WARNING: FreeBSD .*-RELEASE HAS PASSED ITS END-OF-LIFE DATE" > /dev/null
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The 'freebsd-update fetch' operation failed!"
			echo -e "       Check for network related issues.\n       Aborting.\n"
			return 1
		else
			question_yes_no "It seems you are on an unsupported version of FreeBSD.\nWould you like to continue?"
			if [ "${ANSWER}" = "no" ]
			then
				return 1
			fi
		fi
	fi

	cat /tmp/fdo-freebsd-update-output.host.fetch.${NOW} | tail -1 | grep "^No updates needed" > /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LGRN}This host does not need patches installed, it's already fully patched.${NRML}\n"
		return 0
	fi

	echo -e "\n${YELL}And now let's perform a 'freebsd-update install' operation...${NRML}\n"

	PAGER=cat freebsd-update install > /tmp/fdo-freebsd-update-output.host.install.${NOW}
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The 'freebsd-update install' operation failed!"
		echo -e "       Check FDo documentation for help.\n       Aborting.\n"
		return 2
	fi

	echo -e "\n${LGRN}This host has been successfully patched!${NRML}\n"

	FREEBSD_INSTALLED_KERNEL_VERSION=`freebsd-version -k`
	FREEBSD_RUNNING_KERNEL_VERSION=`uname -v`
	if [ "${FREEBSD_RUNNING_KERNEL_VERSION}" != "${FREEBSD_INSTALLED_KERNEL_VERSION}" ]
	then
		PATCH_HOST_NEEDS_REBOOT="yes"
		echo -e "\n${ORNG}ATTENTION: Please reboot when appropriate to pick up changes in patched kernel.${NRML}\n"
	fi

	return 0

}

setup_vnc_desktop()
{

	cd /${REPO_NAME}

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo!"
		echo -e "       Please use the 'init-host' subcommand first.\n       Aborting.\n"
		exit 70
	fi

	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use 'update-config' to keep the repo up-to-date.\n       Aborting.\n"
		exit 71
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Update pkgng repositories
	echo -e "\n${YELL}Next we need to update pkg (pkgng) repositories...${NRML}\n"
	pkg update
	if [ $? -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to update pkg (pkgng) repositories.\n       Aborting.\n"
		exit 72
	fi

	# Install desktop / vnc packages
	echo -e "\n${YELL}Next we need to install some required packages...${NRML}\n"
	pause_prompt 8
	pkg update -f
	pkg install -y ${VNC_DESKTOP_PACKAGES}
	if [ $? -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to install required packages.\n       Aborting.\n"
		exit 73
	fi

	FDO_USERNAME=`cat configs/${HOST_NAME}${FDO_CONFIG_ROOT}/fdo_username.conf`

	# Copy setup-vnc-desktop template configs to this hosts' repo profile
	install_file_tree config-templates/setup-vnc-desktop configs/${HOST_NAME}/ ${FDO_USERNAME} ${FDO_USERNAME}

	# Rename FDO_USERNAME home folder in host config profile
	if [ -d configs/${HOST_NAME}/home/${FDO_USERNAME} ]
	then
		mv configs/${HOST_NAME}/home/FDO_USERNAME/* configs/${HOST_NAME}/home/FDO_USERNAME/.[!.]* configs/${HOST_NAME}/home/${FDO_USERNAME}/
	else
		mv configs/${HOST_NAME}/home/FDO_USERNAME configs/${HOST_NAME}/home/${FDO_USERNAME}
	fi

	# Enable DBUS in rc.conf
	sed -i "" "s/dbus_enable=\"NO\"/dbus_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf

	# Substitute FDo username in rc.local and rc.shutdown.local
	sed -i "" "s|FDO_USERNAME|${FDO_USERNAME}|" configs/${HOST_NAME}/etc/rc.local
	sed -i "" "s|FDO_USERNAME|${FDO_USERNAME}|" configs/${HOST_NAME}/etc/rc.shutdown.local

	# Uncomment VNC related lines in rc.local and rc.shutdown.local
	sed -i "" "s/^#FDO_VNC_DESKTOP#//" configs/${HOST_NAME}/etc/rc.local
	sed -i "" "s/^#FDO_VNC_DESKTOP#//" configs/${HOST_NAME}/etc/rc.shutdown.local

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	# Start dbus
	service dbus start

	echo -e "\n${YELL}The next prompt will ask for the VNC session password...${NRML}\n"
	pause_prompt 8

	# Run vncserver for the first time, will prompt for vnc passwords
	sh /etc/rc.local

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	pause_prompt 8
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'setup-vnc-desktop'; ${HOST_NAME}."

	pause_prompt 8

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
		git_push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	# Get the LAN interface for this host
	CONFIG_LAN_NET_IFACE=`cat ${FDO_CONFIG_ROOT}/net_iface_lan.conf`
	LAN_NET_IFACE=""
	HOST_LAN_IP_ADDRESSES=""
	NET_IFACES=`ifconfig -l`
	for IFACE in ${NET_IFACES}
	do
		if [ "${IFACE}" = "${CONFIG_LAN_NET_IFACE}" ]
		then
			HOST_LAN_IP_ADDRESSES=`ifconfig ${IFACE} | egrep "inet.*netmask" | awk '{print $2}' | egrep "${SERVERS_LAN_SUBNET_C}." | sort`
			if [ "${HOST_LAN_IP_ADDRESSES}" != "" ]
			then
				LAN_NET_IFACE="${IFACE}"
			fi
		fi
	done

	# Get the LAN IP address of this host
	for IP_ADDRESS in ${HOST_LAN_IP_ADDRESSES}
	do
		# Let's ASSUME that the first and lowest (numerically) IP is the primary LAN IP
		HOST_LAN_IP="${IP_ADDRESS}"
		break
	done

	# Get the default route IP for accessing this host from outside the LAN
	DEFAULT_ROUTE_IP=`route -nv get 1 | tail -1 | awk '{print $5}'`

	# Get the default route IP for accessing this host from outside the LAN
	FULL_HOST_NAME=`hostname -f`

	echo -e "\n${LGRN}Congratulations! We have now finished setting up a VNC accessible desktop.${NRML}"
	echo -e "\n${YELL}To access the VNC session use SSVNC Viewer with SSH enabled ${NRML}"
	echo -e "${YELL}and one of the following URIs:${NRML}"
	echo -e "Remotely:"
	echo -e "${LGRN}${FDO_USERNAME}@${FULL_HOST_NAME}:10${NRML}"
	echo -e "${LGRN}${FDO_USERNAME}@${DEFAULT_ROUTE_IP}:10${NRML}"
	echo -e "Locally:"
	echo -e "${LGRN}${FDO_USERNAME}@${HOST_NAME}:10${NRML}"
	echo -e "${LGRN}${FDO_USERNAME}@${HOST_LAN_IP}:10${NRML}\n\n"

	cd -

}

init_hotdesking ()
{

	cd /${REPO_NAME}

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'init-host' subcommand first.\n       Aborting.\n"
		exit 80
	fi

	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use 'update-config' to keep the repo up-to-date.\n       Aborting.\n"
		exit 81
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Get pool name to use for hotdesk users' home folders.
	POOL_NAME=""
	POOLS_AVAILABLE=`zpool list | tail -n +2 | awk '{print $1}'`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n       Aborting.\n"
		exit 82
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool for hotdesk user home folders:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${POOL_NAME_TEMP}${LCYN}' to store the hotdesk users home folders.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				POOL_NAME="${POOL_NAME_TEMP}"
			fi
		done
	fi

	# Warn if hotdesk user home base dataset already exists.
	zfs list ${POOL_NAME}/fdo-hotdesk-home 2> /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The ZFS dataset '${POOL_NAME}/fdo-hotdesk-home' already exists!\n"
	fi

	# Get the NIS domainname.
	NIS_DOMAIN_NAME=""
	while [ "${NIS_DOMAIN_NAME}" = "" ]
	do
		echo -e ""
		readee -p "${LCYN}Enter NIS domain name (need not be the same as the host): ${NRML}" NIS_DOMAIN_NAME_TEMP
		# Check that the nisdomainname is a valid domain name.
		test_valid_fqhn "${NIS_DOMAIN_NAME_TEMP}"
		if [ "${VALID_FQHN}" = "yes" ]
		then
			question_yes_no "\nYou have entered '${NRML}${NIS_DOMAIN_NAME_TEMP}${LCYN}' as the NIS domain name.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				NIS_DOMAIN_NAME=${NIS_DOMAIN_NAME_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The NIS domain name can not be '${NIS_DOMAIN_NAME_TEMP}'."
			echo -e "       It must only contain letters, numbers, periods and hyphens."
			echo -e "       It must not begin or end with a hyphen or a period.\n"
		fi
	done

	# Get the LAN interface of this host
	CONFIG_LAN_NET_IFACE=`cat ${FDO_CONFIG_ROOT}/net_iface_lan.conf`
	LAN_NET_IFACE=""
	HOST_LAN_IP_ADDRESSES=""
	NET_IFACES=`ifconfig -l`
	for IFACE in ${NET_IFACES}
	do
		if [ "${IFACE}" = "${CONFIG_LAN_NET_IFACE}" ]
		then
			HOST_LAN_IP_ADDRESSES=`ifconfig ${IFACE} | egrep "inet.*netmask" | awk '{print $2}' | egrep "${SERVERS_LAN_SUBNET_C}." | sort`
			if [ "${HOST_LAN_IP_ADDRESSES}" != "" ]
			then
				LAN_NET_IFACE="${IFACE}"
			fi
		fi
	done

	# Exit if the LAN subnet interface was not found
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The LAN interface '${CONFIG_LAN_NET_IFACE}' does not provide a valid '${SERVERS_LAN_SUBNET_C}.*' subnet!\n       Aborting.\n"
		exit 83
	fi

	# Get IP to use for NIS service.
	NIS_HOST_IP=""
	NUM_HOST_LAN_IP=`echo ${HOST_LAN_IP_ADDRESSES} | wc -w`
	if [ ${NUM_HOST_LAN_IP} -lt 2 ]
	then
		NIS_HOST_IP=${HOST_LAN_IP_ADDRESSES}
	else
		while [ "${NIS_HOST_IP}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select IP address to use for NIS server:" 12 60 10 ${HOST_LAN_IP_ADDRESSES} 2> ${DIALOG_OUT_FILE}
			NIS_HOST_IP_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${NIS_HOST_IP_TEMP}${LCYN}' to use for the NIS server.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				NIS_HOST_IP="${NIS_HOST_IP_TEMP}"
			fi
		done
	fi

	sed -i "" "s/mountd_enable=\"NO\"/mountd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/nfs_server_enable=\"NO\"/nfs_server_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/nis_client_enable=\"NO\"/nis_client_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/nis_server_enable=\"NO\"/nis_server_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/nis_yppasswdd_enable=\"NO\"/nis_yppasswdd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpc_lockd_enable=\"NO\"/rpc_lockd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpc_statd_enable=\"NO\"/rpc_statd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpcbind_enable=\"NO\"/rpcbind_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/POOL_NAME/${POOL_NAME}/" configs/${HOST_NAME}${FDO_CONFIG_ROOT}/hotdesk-home-zfs-name.conf
	sed -i "" "s/NIS_DOMAIN_NAME/${NIS_DOMAIN_NAME}/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/NIS_HOST_IP/${NIS_HOST_IP}/" configs/${HOST_NAME}/etc/rc.conf

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	question_yes "\nNow we need to restart the network to register the NIS domain name.\nCan we proceed?"

	/etc/netstart

	question_yes_no "\n\nWould you like to allow non-FreeBSD NIS clients to connect to this server?"
	if [ "${ANSWER}" = "yes" ]
	then
		 sed -i "" "s/^#UNSECURE/UNSECURE/" /var/yp/Makefile
	fi

	touch /etc/exports
	touch /var/yp/master.passwd
	chmod 600 /var/yp/master.passwd

	# Start rpcbind required by ypinit
	service rpcbind start

	echo -e "\n${YELL}Now we will initialise the NIS maps. Follow the steps below:${NRML}\n"
	echo -e "${YELL}1.) Enter 'y' when prompted to '... quit on non fatal errors'.${NRML}"
	echo -e "${YELL}2.) Enter 'y' if prompted to '... destroy the existing${NRML}"
	echo -e "${YELL}    /var/yp/${NIS_DOMAIN_NAME}'.${NRML}"
	echo -e "${YELL}3.) Press 'Ctrl' and 'D' keys together when prompted for 'next host to add'.${NRML}"
	echo -e "${YELL}4.) Enter 'y' when prompted to confirm NIS server list is correct.${NRML}\n"

	ypinit -m ${NIS_DOMAIN_NAME}

	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The NIS maps failed to initialise."
		echo -e "       Consult FDo documentation for help.\n       Aborting.\n"
		exit 84
	fi

	# Start the NIS/NFS services
	service ypserv start
	service ypbind start
	service lockd start
	service nfsd start

	# Let's add a group called users to support a Slackware based workstation / client
	pw group add users -g 100 > /dev/null 2>&1

	# Create the ZFS dataset for the root of hotdesk users home folders
	zfs create -o mountpoint=/fdo-hotdesk-home ${POOL_NAME}/fdo-hotdesk-home

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'init-hotdesking'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
		git_push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished setting up NIS/NFS hotdesking.${NRML}"
	echo -e "\n${LGRN}To register hotdesk users on this server; use the command:${NRML}"
	echo -e "${LBLU}fdo-hotdesk-add-user${NRML}\n"

	echo -e "${YELL}Hotdesk user home folder pool name:${NRML} ${POOL_NAME}"
	echo -e "${YELL}Hotdesk user home folder dataset:${NRML} ${POOL_NAME}/fdo-hotdesk-home"
	echo -e "${YELL}NIS domain name:${NRML} ${NIS_DOMAIN_NAME}"
	echo -e "${YELL}NIS server IP address:${NRML} ${NIS_HOST_IP}\n"

	cd -

}

init_jails ()
{
	cd /${REPO_NAME}
 
	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'init-host' subcommand first.\n       Aborting.\n"
		exit 90
	fi
 
	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the subcommand 'update-config' to keep the repo up-to-date."
		echo -e "       Aborting.\n"
		exit 91
	fi
 
	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"
 
	# Get the LAN interface that the jails will run on
	CONFIG_LAN_NET_IFACE=`cat ${FDO_CONFIG_ROOT}/net_iface_lan.conf`
	LAN_NET_IFACE=""
	HOST_LAN_IP_ADDRESSES=""
	NET_IFACES=`ifconfig -l`
	for IFACE in ${NET_IFACES}
	do
		if [ "${IFACE}" = "${CONFIG_LAN_NET_IFACE}" ]
		then
			HOST_LAN_IP_ADDRESSES=`ifconfig ${IFACE} | egrep "inet.*netmask" | awk '{print $2}' | egrep "${SERVERS_LAN_SUBNET_C}." | sort`
			if [ "${HOST_LAN_IP_ADDRESSES}" != "" ]
			then
				LAN_NET_IFACE="${IFACE}"
			fi
		fi
	done

	# Exit if the LAN subnet interface was not found
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The LAN interface '${CONFIG_LAN_NET_IFACE}' does not provide a valid '${SERVERS_LAN_SUBNET_C}.*' subnet!\n       Aborting.\n"
		exit 92
	fi

	# Get pool name to use for base of jails.
	POOL_NAME=""
	POOLS_AVAILABLE=`zpool list | tail -n +2 | awk '{print $1}'`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n       Aborting.\n"
		exit 93
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool to use for jails datasets:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${POOL_NAME_TEMP}${LCYN}' to store the service jails.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				POOL_NAME="${POOL_NAME_TEMP}"
			fi
		done
	fi
 
	# Warn if jail base dataset already exists.
	zfs list ${POOL_NAME}/jails 2> /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The ZFS dataset '${POOL_NAME}/jails' already exists!\n"
		JAILS_FILESYSTEM_EXISTS="yes"
	else
		JAILS_FILESYSTEM_EXISTS="no"
	fi

	pause_prompt 8

	# Test for existing template jail and prompt how to proceed
	zfs list ${POOL_NAME}/jails/template 2> /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The ZFS dataset '${POOL_NAME}/jails/template' already exists!\n"
		question_yes_no "\nIt seems as though 'init-jails' has already been applied to this host.\nWould you like to proceed?"
		if [ "${ANSWER}" = "yes" ]
		then
			# Ask whether to rename exsiting filesystem or delete
			question_yes_no "\nWould you like to delete the existing jail template filesystem \nand all dependent clones?\nAnswer 'no' to rename the existing filesystem.\n[CAUTION]"
			if [ "${ANSWER}" = "yes" ]
			then
				zfs destroy -Rf ${POOL_NAME}/jails/template
			else
				NOW=`date "+%Y-%m-%d_%H-%M-%S"`
				zfs rename -f ${POOL_NAME}/jails/template ${POOL_NAME}/jails/template_renamed-by-init-jails-${NOW}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} Unable to proceed.\n       Aborting.\n"
			exit 94
		fi
	fi

	patch_host
	PATCH_HOST_RETURN_CODE=${?}
	if [ ${PATCH_HOST_RETURN_CODE} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Updating of host to latest patch level failed.\n       Aborting.\n"
		exit 95
	fi

	# Get version strings
	FREEBSD_VERSION_STRING=`freebsd-version`
	FREEBSD_VERSION=`freebsd-version | cut -d- -f1`
	FREEBSD_MAJOR_VERSION=`echo ${FREEBSD_VERSION} | cut -d. -f1`
	FREEBSD_CADENCE=`freebsd-version | cut -d- -f2`
	FREEBSD_PATCH_LEVEL=`freebsd-version | cut -d- -f3`

	SUM_EXIT_CODE=0

	# Download relevant base system tarballs
	echo -e "\n${YELL}Downloading FreeBSD base system tarballs...${NRML}\n"
	fetch -o /tmp/jail-base.txz ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/${FREEBSD_VERSION}-${FREEBSD_CADENCE}/base.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	fetch -o /tmp/jail-lib32.txz ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/${FREEBSD_VERSION}-${FREEBSD_CADENCE}/lib32.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	fetch -o /tmp/jail-src.txz ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/${FREEBSD_VERSION}-${FREEBSD_CADENCE}/src.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	if [ ${SUM_EXIT_CODE} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to download the base system tarballs.\n       Aborting.\n"
		exit 96
	fi

	# Create ZFS datasets for service jail template
	echo -e "\n${YELL}Creating ZFS datasets for template jail...${NRML}\n"
	if [ "${JAILS_FILESYSTEM_EXISTS}" = "no" ]
	then
		zfs create -o mountpoint=/jls ${POOL_NAME}/jails
		SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	fi
	zfs create ${POOL_NAME}/jails/template
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	# Mount the datasets if they are not already
	zfs mount | grep "${POOL_NAME}/jails "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${POOL_NAME}/jails
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	zfs mount | grep "${POOL_NAME}/jails/template "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${POOL_NAME}/jails/template
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	# Install base system tarballs into the template jail directory
	echo -e "\n${YELL}Extracting FreeBSD base system tarballs into template jail...${NRML}\n"
	tar -JxC /jls/template/ -f /tmp/jail-base.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	tar -JxC /jls/template/ -f /tmp/jail-lib32.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	tar -JxC /jls/template/ -f /tmp/jail-src.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	if [ ${SUM_EXIT_CODE} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong in preparing the template jail.\n       Aborting.\n"
		exit 97
	fi

	echo "${POOL_NAME}" > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/jails_pool.conf
	sed -i "" "s/jail_enable=\"NO\"/jail_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/^#template/template/" configs/${HOST_NAME}/etc/jail.conf

	# Only run sshd on LAN host (not jail) IPs
	for IP_ADDRESS in ${HOST_LAN_IP_ADDRESSES}
	do
		# Add port forwarding rules to pf and ppp config
		IS_REPO_CONF="yes" PF_CONF_PATH="/${REPO_NAME}/configs/${HOST_NAME}/etc/pf.conf" fdo-pf-add-port-forward-rule host_sshd ${IP_ADDRESS} 22 none --non-interactive
		IS_REPO_CONF="yes" PPP_CONF_PATH="/${REPO_NAME}/configs/${HOST_NAME}/etc/ppp/ppp.conf" fdo-ppp-add-port-forward-rule host_sshd ${IP_ADDRESS} 22 none --non-interactive

		# Set this hosts sshd to only run on the primary LAN IP
		sed -i "" "s/#ListenAddress .*/ListenAddress ${IP_ADDRESS}/" configs/${HOST_NAME}/etc/ssh/sshd_config

		# Let's ASSUME that the first and lowest (numerically) IP is the primary LAN IP
		break
	done

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	# Install init-jails configs to the template jail
	install_file_tree config-templates/init-jails /jls/template/

	# Create nullfs mountpoint for hosts ssl certs
	mkdir -p /jls/template/usr/local/etc/ssl/certs

	# Copy certain host specific config files to the template jail
	HOST_CONFIG_FILES=`find config-templates/init-jails -type f | sed "s|^config-templates/init-jails/||"`
	for CONFIG_FILE in ${HOST_CONFIG_FILES}
	do
		FILE_CONTENTS=`cat config-templates/init-jails/${CONFIG_FILE}`
		if [ "${FILE_CONTENTS}" = "COPY_FROM_HOST" ]
		then
			cp /${CONFIG_FILE} /jls/template/${CONFIG_FILE}
		elif [ "${FILE_CONTENTS}" = "COPY_STATIC_FROM_HOST" ]
		then
			STATIC_CONFIG_FILE="${CONFIG_FILE}.static"
			cp /${STATIC_CONFIG_FILE} /jls/template/${CONFIG_FILE}
		fi
	done

	# Run tzsetup for the jail
	tzsetup -s -C /jls/template `cat /var/db/zoneinfo`

	service pf reload
	service sshd reload
	service jail start template

	echo -e "\n${YELL}Updating template jail to latest patch release...${NRML}\n"
	PAGER=cat freebsd-update -b /jls/template fetch > /tmp/fdo-freebsd-update.output
	PAGER=cat freebsd-update -b /jls/template install > /tmp/fdo-freebsd-update.output

	service jail restart template

	# Install essential package into the template jail
	echo -e "\n${YELL}Next we need to install some essential packages into the template jail.${NRML}\n"
	pause_prompt 8
	pkg -j template update -f
	pkg -j template install -y ${ESSENTIAL_JAIL_PACKAGES}

	# Stop the template jail now that we're done making the template
	service jail stop template

	# Disable template jail from running again
	sed -i "" "s/^template/#template/" configs/${HOST_NAME}/etc/jail.conf

	# Install updated host configs to the system (after disabling template jail)
	install_file_tree configs/${HOST_NAME} /

	# Take snapshot of the template for use in create-jail*
	zfs snapshot ${POOL_NAME}/jails/template@${FREEBSD_VERSION_STRING}

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'init-jails'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
		git_push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished initialising the jails subsystem.${NRML}"
	echo -e "\n${LGRN}To create jails, use the command:${NRML}"
	echo -e "${LBLU}${SCRIPT_NAME} create-jail${NRML}\n"

	cd -

}

init_remote_desktops ()
{

	cd /${REPO_NAME}
 
	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'init-host' subcommand first."
		echo -e "       Aborting.\n"
		exit 100
	fi
 
	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use 'update-config' to keep the repo up-to-date."
		echo -e "       Aborting.\n"
		exit 101
	fi
 
	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"
 
	SUM_EXIT_CODE=0

	echo -e "\n${YELL}First we need to install some required packages...${NRML}\n"
	pause_prompt 8
	pkg update -f
	pkg install -y ${REMOTE_DESKTOP_PACKAGES}

	kldstat | grep vboxdrv.ko > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		kldload vboxdrv 2> /dev/null
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	kldstat | grep vboxnetflt.ko > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		kldload vboxnetflt 2> /dev/null
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	kldstat | grep vboxnetadp.ko > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		kldload vboxnetadp 2> /dev/null
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	if [ ${SUM_EXIT_CODE} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} A problem was encountered when loading the VirtualBox kernel modules.\n       Aborting.\n"
		exit 102
	fi

	# Get pool name to use for base of remote desktops datasets.
	POOL_NAME=""
	POOLS_AVAILABLE=`zpool list | tail -n +2 | awk '{print $1}'`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n       Aborting.\n"
		exit 103
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool to use for remote desktop datasets:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${POOL_NAME_TEMP}${LCYN}' to store the remote desktops.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				POOL_NAME="${POOL_NAME_TEMP}"
			fi
		done
	fi
 
	# Create ZFS datasets for remote desktop template
	echo -e "\n${YELL}Creating ZFS datasets for the template ...${NRML}\n"
	zfs list ${POOL_NAME}/vboxguests > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		zfs create -o mountpoint=/vboxguests ${POOL_NAME}/vboxguests
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	zfs list ${POOL_NAME}/vboxguests/RemoteDesktop > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		zfs create ${POOL_NAME}/vboxguests/RemoteDesktop
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	# Mount the datasets if they are not already
	zfs mount | grep "${POOL_NAME}/vboxguests "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${POOL_NAME}/vboxguests
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	zfs mount | grep "${POOL_NAME}/vboxguests/RemoteDesktop "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${POOL_NAME}/vboxguests/RemoteDesktop
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	if [ ${SUM_EXIT_CODE} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} A problem was encountered when creating the ZFS datasets for the remote"
		echo -e "       desktops.\n       Aborting.\n"
		exit 104
	fi

	sed -i "" "s/vboxnet_enable=\"NO\"/vboxnet_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	DEV_PATHS="uhid\* ugen\* usb\/\*"
	for DEV_PATH in ${DEV_PATHS}
	do
		NEW_DEVFS_RULE="add path '${DEV_PATH}' mode 0660 group vboxusers"
		cat configs/${HOST_NAME}/etc/devfs.rules | grep "${NEW_DEVFS_RULE}" > /dev/null 2>&1
		if [ ${?} -ne 0 ]
		then
			sed -i "" "s/^\(\[host_ruleset=1\].*\)/\1\\${CARRIAGE_RETURN}${NEW_DEVFS_RULE}/" configs/${HOST_NAME}/etc/devfs.rules
		fi
	done
	echo "${POOL_NAME}" > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/remote_desktops_pool.conf

	# Copy init-remote-desktops template configs to this hosts' repo profile
	install_file_tree config-templates/init-remote-desktops configs/${HOST_NAME}/

	# Ask if the auto-screen-resize feature is wanted.
	question_yes_no "\nWould you like to enable the auto-screen-size service for this\nremote-desktops host?"
	if [ "${ANSWER}" = "yes" ]
	then

		USES_AUTO_SCREEN_SIZE="yes"

		# Get dB hostname
		RD_DB_HOST_NAME=""
		while [ "${RD_DB_HOST_NAME}" = "" ]
		do
			echo -e "\n${LCYN}Enter the hostname of the auto-screen-resize database for this${NRML}"
			readee -p "${LCYN}remote-desktops host: ${NRML}" RD_DB_HOST_NAME_TEMP
			# Check that the db hostname is a valid fully qualified host name.
			test_valid_fqhn "${RD_DB_HOST_NAME_TEMP}"
			if [ "${VALID_FQHN}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${RD_DB_HOST_NAME_TEMP}${LCYN}' as the auto-screen-resize db hostname.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					RD_DB_HOST_NAME=${RD_DB_HOST_NAME_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The auto-screen-resize db hostname can not be"
				echo -e "       '${RD_DB_HOST_NAME_TEMP}'."
				echo -e "       It must only contain lower case letters, numbers, periods and hyphens."
				echo -e "       It must not begin or end with a hyphen or a period.\n"
			fi
		done

		# Get dB name (schema)
		RD_DB_NAME=""
		while [ "${RD_DB_NAME}" = "" ]
		do
			echo -e "\n${LCYN}Enter the dB name of the auto-screen-resize database for this${NRML}"
			readee -p "${LCYN}remote-desktops host: ${NRML}" RD_DB_NAME_TEMP
			# Check that the db name is valid.
			TEST=`echo "${RD_DB_NAME_TEMP}" | sed -r "s/^[a-z0-9][a-z0-9\.\_\-]+[a-z0-9]//" | wc -L`
			if [ ${TEST} -eq 0 ] && [ "${RD_DB_NAME_TEMP}" != "" ]
			then
				question_yes_no "\nYou have entered '${NRML}${RD_DB_NAME_TEMP}${LCYN}' as the auto-screen-resize dB name.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					RD_DB_NAME=${RD_DB_NAME_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The auto-screen-resize dB name can not be"
				echo -e "       '${RD_DB_NAME_TEMP}'."
				echo -e "       It must only contain lower case letters, numbers, periods, underscores"
				echo -e "       and hyphens."
				echo -e "       It must not begin or end with a hyphen or a period.\n"
			fi
		done

		# Get dB username
		RD_DB_USERNAME=""
		while [ "${RD_DB_USERNAME}" = "" ]
		do
			echo -e "\n${LCYN}Enter the username of the auto-screen-resize database for this${NRML}"
			readee -p "${LCYN}remote-desktops host: ${NRML}" RD_DB_USERNAME_TEMP
			# Check that the db username is valid.
			TEST=`echo "${RD_DB_USERNAME_TEMP}" | sed -r "s/^[a-z0-9][a-z0-9\.\_\-]+[a-z0-9]//" | wc -L`
			if [ ${TEST} -eq 0 ] && [ "${RD_DB_USERNAME_TEMP}" != "" ]
			then
				question_yes_no "\nYou have entered '${NRML}${RD_DB_USERNAME_TEMP}${LCYN}' as the auto-screen-resize db username.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					RD_DB_USERNAME=${RD_DB_USERNAME_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The auto-screen-resize db username can not be"
				echo -e "       '${RD_DB_USERNAME_TEMP}'."
				echo -e "       It must only contain lower case letters, numbers, periods, underscores"
				echo -e "       and hyphens."
				echo -e "       It must not begin or end with a hyphen, underscore or a period.\n"
			fi
		done

		# Get dB user password
		RD_DB_USER_PASSWORD=""
		while [ "${RD_DB_USER_PASSWORD}" = "" ]
		do
			echo -e ""
			readee -s -p "${LCYN}Enter dB user password:    ${NRML}" RD_DB_USER_PASSWORD_TEMP1
			readee -s -p "${LCYN}Re-enter dB user password: ${NRML}" RD_DB_USER_PASSWORD_TEMP2

			if [ "${RD_DB_USER_PASSWORD_TEMP1}" != "${RD_DB_USER_PASSWORD_TEMP2}" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Password mismatch, try again!\n"
			elif [ "${RD_DB_USER_PASSWORD_TEMP1}" = "" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Password not entered, try again!\n"
			else
				RD_DB_USER_PASSWORD=${RD_DB_USER_PASSWORD_TEMP1}
			fi
		done

		# Get remote-desktops hostname
		RD_HOST_NAME=""
		while [ "${RD_HOST_NAME}" = "" ]
		do
			echo -e "\n${LCYN}Enter the remote-desktops hostname for this host${NRML}"
			readee -p "(may differ from the server hostname): ${NRML}" RD_HOST_NAME_TEMP
			# Check that the remote-desktops hostname is a valid fully qualified host name.
			test_valid_fqhn "${RD_HOST_NAME_TEMP}"
			if [ "${VALID_FQHN}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${RD_HOST_NAME_TEMP}${LCYN}' as the remote-desktops hostname.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					RD_HOST_NAME=${RD_HOST_NAME_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The remote-desktops hostname can not be"
				echo -e "       '${RD_HOST_NAME_TEMP}'."
				echo -e "       It must only contain lower case letters, numbers, periods and hyphens."
				echo -e "       It must not begin or end with a hyphen or a period.\n"
			fi
		done

		# Substitute config variables.
		sed -i "" "s/DB_HOST/${RD_DB_HOST_NAME}/" configs/${HOST_NAME}${FDO_CONFIG_ROOT}/remote-desktops-rdscreensized-db.conf
		sed -i "" "s/DB_NAME/${RD_DB_NAME}/" configs/${HOST_NAME}${FDO_CONFIG_ROOT}/remote-desktops-rdscreensized-db.conf
		sed -i "" "s/DB_USER_NAME/${RD_DB_USERNAME}/" configs/${HOST_NAME}${FDO_CONFIG_ROOT}/remote-desktops-rdscreensized-db.conf
		sed -i "" "s/DB_USER_PASSWORD/${RD_DB_USER_PASSWORD}/" configs/${HOST_NAME}${FDO_CONFIG_ROOT}/remote-desktops-rdscreensized-db.conf
		sed -i "" "s/RD_HOST/${RD_HOST_NAME}/" configs/${HOST_NAME}${FDO_CONFIG_ROOT}/remote-desktops-rdscreensized-db.conf

		# Enable auto-screen-size service.
		sed -i "" "s/rdscreensized_enable=\"NO\"/rdscreensized_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf

	else
		USES_AUTO_SCREEN_SIZE="no"
	fi

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	echo -e "\n"

	if [ "${USES_AUTO_SCREEN_SIZE}" = "yes" ]
	then
		# Start auto-screen-size service for the first time.
		service rdscreensized onestart
	fi

	echo -e "\n"

	# Add remote desktop template user
	pw useradd RemoteDesktop -m -s /usr/local/bin/bash -c "Remote Desktop Template User" -d /vboxguests/RemoteDesktop -G "operator vboxusers"

	# Change ownership of the template VM base directory to the template user
	chown -R RemoteDesktop:RemoteDesktop /vboxguests/RemoteDesktop

	# Restart devfs
	service devfs restart

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'init-remote-desktops'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
		git_push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished initialising the remote desktop subsystem.${NRML}"
	echo -e "\n${LGRN}To create a remote desktop template, use the command:${NRML}"
	echo -e "${LBLU}${SCRIPT_NAME} create-remote-desktop-template${NRML}\n"

	cd -

}

create_remote_desktop_template ()
{

	RD_TEMPLATE_NAME=${1}

	# Source the recipe
	if [ "${RD_TEMPLATE_NAME}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No template name provided.\n       Aborting.\n"
		exit 110
	fi

	cd /${REPO_NAME}

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'init-host' subcommand first.\n       Aborting.\n"
		exit 111
	fi

	POOL_NAME=`cat ${FDO_CONFIG_ROOT}/remote_desktops_pool.conf 2> /dev/null`
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the remote desktops subsytem is not initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} init-remote-desktops${NRML}\n       Aborting.\n"
		exit 112
	fi

	zfs list ${POOL_NAME}/vboxguests/RemoteDesktop@${RD_TEMPLATE_NAME} > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The template '${RD_TEMPLATE_NAME}' already exists.\n"
		echo -e "       To delete it, use the command:"
		echo -e "       ${LBLU}zfs destroy ${POOL_NAME}/vboxguests/RemoteDesktop@${RD_TEMPLATE_NAME}${NRML}\n"
		echo -e "       Aborting.\n"
		exit 113
	fi

	# Get the LAN interface for this host
	CONFIG_LAN_NET_IFACE=`cat ${FDO_CONFIG_ROOT}/net_iface_lan.conf`
	LAN_NET_IFACE=""
	HOST_LAN_IP_ADDRESSES=""
	NET_IFACES=`ifconfig -l`
	for IFACE in ${NET_IFACES}
	do
		if [ "${IFACE}" = "${CONFIG_LAN_NET_IFACE}" ]
		then
			HOST_LAN_IP_ADDRESSES=`ifconfig ${IFACE} | egrep "inet.*netmask" | awk '{print $2}' | egrep "${SERVERS_LAN_SUBNET_C}." | sort`
			if [ "${HOST_LAN_IP_ADDRESSES}" != "" ]
			then
				LAN_NET_IFACE="${IFACE}"
			fi
		fi
	done

	# Exit if the LAN subnet interface was not found
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The LAN interface '${CONFIG_LAN_NET_IFACE}' does not provide a valid '${SERVERS_LAN_SUBNET_C}.*' subnet!\n       Aborting.\n"
		exit 114
	fi

	# Get the LAN IP address of this host
	for IP_ADDRESS in ${HOST_LAN_IP_ADDRESSES}
	do
		# Let's ASSUME that the first and lowest (numerically) IP is the primary LAN IP
		HOST_LAN_IP="${IP_ADDRESS}"
		break
	done

	# Get IP to use for VNC.
	VNC_HOST_IP=""
	NUM_HOST_LAN_IP=`echo ${HOST_LAN_IP_ADDRESSES} | wc -w`
	if [ ${NUM_HOST_LAN_IP} -lt 2 ]
	then
		VNC_HOST_IP=${HOST_LAN_IP_ADDRESSES}
	else
		while [ "${VNC_HOST_IP}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select IP address for VNC access:" 12 60 10 ${HOST_LAN_IP_ADDRESSES} 2> ${DIALOG_OUT_FILE}
			VNC_HOST_IP_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${VNC_HOST_IP_TEMP}${LCYN}' to use for the VNC session.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VNC_HOST_IP="${VNC_HOST_IP_TEMP}"
			fi
		done
	fi

	question_yes_no "\nIs this template for a 64bit OS?"
	IS_GUEST_OS_64BIT="${ANSWER}"

	question_yes_no "\nIs this a Windows XP (or older) guest OS?"
	if [ "${ANSWER}" = "yes" ]
	then
		IS_GUEST_OS_WINXP_OR_OLDER="yes"
		STORAGE_CTL_NAME="IDE"
		STORAGE_CTL_TYPE="ide"
		STORAGE_CTL_CHIPSET="PIIX4"
		STORAGE_CTL_HOST_IOCACHE="on"
		VBOX_NIC_TYPE="Am79C973"
	else
		IS_GUEST_OS_WINXP_OR_OLDER="no"
		STORAGE_CTL_NAME="SATA"
		STORAGE_CTL_TYPE="sata"
		STORAGE_CTL_CHIPSET="IntelAHCI"
		STORAGE_CTL_HOST_IOCACHE="off"
		VBOX_NIC_TYPE="82540EM"
	fi

	VM_MEM_SIZE_MB=""
	while [ "${VM_MEM_SIZE_MB}" = "" ]
	do
		echo -e ""
		readee -p "${LCYN}Enter the memory size in MB of the VM template: ${NRML}" VM_MEM_SIZE_MB_TEMP
		# Check that the VM memory size contains only numbers.
		test_valid_integer "${VM_MEM_SIZE_MB_TEMP}" 100 1000000
		if [ "${VALID_INTEGER}" = "yes" ]
		then
			question_yes_no "\nYou have entered '${NRML}${VM_MEM_SIZE_MB_TEMP}${LCYN}' as the VM memory size.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VM_MEM_SIZE_MB=${VM_MEM_SIZE_MB_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The VM memory size can not be '${VM_MEM_SIZE_MB}'."
			echo -e "       It must contain only numbers, greater than 100 and less than 1000000.\n"
		fi
	done

	# Prompt for the method; install or copy from existing VDI image.
	INSTALL_OR_COPY_VDI=""
	while [ "${INSTALL_OR_COPY_VDI}" = "" ]
	do
		echo -e "\n${LCYN}Do you want to install an OS or copy from an existing VDI image?${NRML}"
		readee -p "${LCYN}(install|copy): ${NRML}" INSTALL_OR_COPY_VDI_TEMP
		# Check input validation.
		if [ "${INSTALL_OR_COPY_VDI_TEMP}" = "install" ] || [ "${INSTALL_OR_COPY_VDI_TEMP}" = "copy" ]
		then
			INSTALL_OR_COPY_VDI="${INSTALL_OR_COPY_VDI_TEMP}"
		fi
	done

	echo -e ""

	if [ "${INSTALL_OR_COPY_VDI}" = "install" ]
	then
		# Get the VMs' HDD size (in MB).
		VM_HDD_SIZE_MB=""
		while [ "${VM_HDD_SIZE_MB}" = "" ]
		do
			echo -e ""
			readee -p "${LCYN}Enter the maximum size in MB of the VDI (VBox HDD): ${NRML}" VM_HDD_SIZE_MB_TEMP
			# Check that the VM HDD size contains only numbers.
			test_valid_integer "${VM_HDD_SIZE_MB_TEMP}" 100 1000000
			if [ "${VALID_INTEGER}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${NRML}${VM_HDD_SIZE_MB_TEMP}${LCYN}' as the max VDI size.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					VM_HDD_SIZE_MB=${VM_HDD_SIZE_MB_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The max VDI size can not be '${VM_HDD_SIZE_MB}'."
				echo -e "       It must contain only numbers, greater than 100 and less than 1000000.\n"
			fi
		done

		# Get the installer ISO path
		OS_INSTALLER_ISO=""
		while [ "${OS_INSTALLER_ISO}" = "" ]
		do
			# Ask for installer ISO file
			dialog --title "Select OS installer ISO" --no-cancel --fselect / 20 80 2> ${DIALOG_OUT_FILE}
			OS_INSTALLER_ISO_TEMP=`cat ${DIALOG_OUT_FILE}`
			if [ -f "${OS_INSTALLER_ISO_TEMP}" ]
			then
				file "${OS_INSTALLER_ISO_TEMP}" | grep "ISO 9660" > /dev/null
				if [ ${?} -eq 0 ]
				then
					echo -e "\n"
					question_yes_no "\nYou have selected '${NRML}${OS_INSTALLER_ISO_TEMP}${LCYN}' as the OS installer ISO.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						OS_INSTALLER_ISO="${OS_INSTALLER_ISO_TEMP}"
					fi
				else
					echo -e "\n\n${ORNG}WARNING:${NRML} File selected is not an ISO!\n"
					pause_prompt 5
				fi
			else
				echo -e "\n\n${ORNG}WARNING:${NRML} No file selected!\n"
				pause_prompt 5
			fi
		done
	fi

	if [ "${INSTALL_OR_COPY_VDI}" = "copy" ]
	then
		# Get the existing VDI file path
		EXISTING_VDI_PATH=""
		while [ "${EXISTING_VDI_PATH}" = "" ]
		do
			# Ask for existing VDI image path
			dialog --title "Select existing VDI image" --no-cancel --fselect / 20 80 2> ${DIALOG_OUT_FILE}
			EXISTING_VDI_PATH_TEMP=`cat ${DIALOG_OUT_FILE}`
			if [ -f "${EXISTING_VDI_PATH_TEMP}" ]
			then
				file "${EXISTING_VDI_PATH_TEMP}" | grep "VirtualBox Disk Image" > /dev/null
				if [ ${?} -eq 0 ]
				then
					echo -e "\n"
					question_yes_no "\nYou have selected '${NRML}${EXISTING_VDI_PATH_TEMP}${LCYN}' as the existing VDI file.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						EXISTING_VDI_PATH="${EXISTING_VDI_PATH_TEMP}"
					fi
				else
					echo -e "\n\n${ORNG}WARNING:${NRML} File selected is not a VDI image!\n"
					pause_prompt 5
				fi
			else
				echo -e "\n\n${ORNG}WARNING:${NRML} No file selected!\n"
				pause_prompt 5
			fi
		done
	fi

	echo -e "\n"

	# Stop and unregister any existing template VM.
	su - RemoteDesktop -c "VBoxManage list vms" | grep RemoteDesktop > /dev/null
	if [ ${?} -eq 0 ]
	then
		su - RemoteDesktop -c "VBoxManage list runningvms" | awk '{print $1}' | egrep "RemoteDesktop" > /dev/null
		if [ ${?} -eq 0 ]
		then
			service RemoteDesktop onestop
		fi
		echo -e "\n${YELL}Destroying existing template VM...${NRML}\n"
		su - RemoteDesktop -c "VBoxManage unregistervm RemoteDesktop --delete"
		if [ ${?} -ne 0 ]
		then
			sleep 3
			su - RemoteDesktop -c "VBoxManage startvm RemoteDesktop --type emergencystop"
			sleep 15
			echo -e "\n${YELL}Forcibly destroying existing template VM...${NRML}\n"
			su - RemoteDesktop -c "VBoxManage unregistervm RemoteDesktop --delete"
		fi
	fi

	# Create the VM.
	echo -e "\n${YELL}Creating new template VM...${NRML}\n"
	su - RemoteDesktop -c "VBoxManage createvm --name 'RemoteDesktop' --register"
	su - RemoteDesktop -c "VBoxManage modifyvm RemoteDesktop --memory ${VM_MEM_SIZE_MB} --acpi on --ioapic on --boot1 dvd --vram 64 --accelerate2dvideo on"
	su - RemoteDesktop -c "VBoxManage modifyvm RemoteDesktop --nic1 bridged --bridgeadapter1 ${LAN_NET_IFACE} --nictype1 ${VBOX_NIC_TYPE} --cableconnected1 on"
	su - RemoteDesktop -c "VBoxManage modifyvm 'RemoteDesktop' --vrde on --vrdeport 6000 --vrdeaddress ${VNC_HOST_IP} --vrdeproperty VNCPassword=vncpassword"
	su - RemoteDesktop -c "VBoxManage sharedfolder add RemoteDesktop --name SharedTemp --hostpath /remote-desktops/RemoteDesktop"

	if [ "${INSTALL_OR_COPY_VDI}" = "install" ]
	then
		# Create the VMs' HDD.
		su - RemoteDesktop -c "VBoxManage createhd --filename /vboxguests/RemoteDesktop/VirtualBox\ VMs/RemoteDesktop/RemoteDesktop.vdi --size ${VM_HDD_SIZE_MB}"
	fi

	if [ "${INSTALL_OR_COPY_VDI}" = "copy" ]
	then
		# Copy the existing VDI to the correct path and chown (change UID/GID ownership).
		echo -e "\n${YELL}Copying existing VDI to template VM path...${NRML}\n"
		cp "${EXISTING_VDI_PATH}" /vboxguests/RemoteDesktop/VirtualBox\ VMs/RemoteDesktop/RemoteDesktop.vdi
		chown RemoteDesktop:RemoteDesktop /vboxguests/RemoteDesktop/VirtualBox\ VMs/RemoteDesktop/RemoteDesktop.vdi
	fi

	su - RemoteDesktop -c "VBoxManage storagectl 'RemoteDesktop' --name '${STORAGE_CTL_NAME} Controller' --add ${STORAGE_CTL_TYPE} --controller ${STORAGE_CTL_CHIPSET} --hostiocache ${STORAGE_CTL_HOST_IOCACHE} --portcount 2"
	su - RemoteDesktop -c "VBoxManage storageattach 'RemoteDesktop' --storagectl '${STORAGE_CTL_NAME} Controller' --port 0 --device 0 --type hdd --medium /vboxguests/RemoteDesktop/VirtualBox\ VMs/RemoteDesktop/RemoteDesktop.vdi"

	if [ "${INSTALL_OR_COPY_VDI}" = "install" ]
	then
		su - RemoteDesktop -c "VBoxManage storageattach 'RemoteDesktop' --storagectl '${STORAGE_CTL_NAME} Controller' --port 1 --device 0 --type dvddrive --medium '${OS_INSTALLER_ISO}'"
	else
		su - RemoteDesktop -c "VBoxManage storageattach 'RemoteDesktop' --storagectl '${STORAGE_CTL_NAME} Controller' --port 1 --device 0 --type dvddrive --medium emptydrive"
	fi

	if [ "${IS_GUEST_OS_64BIT}" = "yes" ]
	then
		su - RemoteDesktop -c "VBoxManage modifyvm 'RemoteDesktop' --longmode on"
	else
		su - RemoteDesktop -c "VBoxManage modifyvm 'RemoteDesktop' --longmode off"
	fi

	if [ "${IS_GUEST_OS_WINXP_OR_OLDER}" = "yes" ]
	then
		# Do nothing yet.
	else
		su - RemoteDesktop -c "VBoxManage modifyvm 'RemoteDesktop' --audiocontroller hda"
	fi

	# Start template for first time.
	touch /var/log/RemoteDesktop.log
	chown RemoteDesktop:RemoteDesktop /var/log/RemoteDesktop.log
	service RemoteDesktop onestart

	# Inform user that next step is to login via VNC to the template and perfrom the installation / configuration.
	echo -e "\n${YELL}The remote desktop template VM should now be running.${NRML}"
	if [ "${INSTALL_OR_COPY_VDI}" = "install" ]
	then
		echo -e "${YELL}The OS installer ISO should also be attached and booted into ${NRML}"
		echo -e "${YELL}the installation environment.${NRML}"
		echo -e "${YELL}You should now install the guest OS and reboot it when finished.${NRML}\n"
	fi
	echo -e "${YELL}Connect to the remote desktop template using a VNC viewer ${NRML}"
	echo -e "${YELL}(e.g. SSVNC) using the following:${NRML}\n"
	echo -e "${LGRN}VNC URI:      ${VNC_HOST_IP}:6000${NRML}"
	echo -e "${LGRN}VNC Password: vncpassword\n\n"
	
	# Pause for user to finish configuring template.
	if [ "${INSTALL_OR_COPY_VDI}" = "install" ]
	then
		question_yes "\nAre you finished installing the guest OS for this remote desktop template?"
	fi

	if [ "${INSTALL_OR_COPY_VDI}" = "copy" ]
	then
		question_yes "\nAre you finished setting up the guest OS for this remote desktop template?"
		question_yes "\nHave you considered uninstalling any previous VirtualBox guest additions\nfrom this guest before proceeding?"
	fi

	# Optionally install guest additions.
	question_yes_no "\nWould you like to install guest additions into the remote desktop template? [RECOMMENDED]"
	if [ "${ANSWER}" = "yes" ]
	then
		VBOX_VERSION=`pkg info virtualbox-ose | head -1 | cut -d_ -f 1 | cut -d- -f3`
		GUEST_ADDITIONS_ISO="VBoxGuestAdditions_${VBOX_VERSION}.iso"

		echo -e "\n${YELL}Downloading guest additions DVD ISO...${NRML}\n"
		fetch -o /vboxguests/${GUEST_ADDITIONS_ISO} http://download.virtualbox.org/virtualbox/${VBOX_VERSION}/${GUEST_ADDITIONS_ISO}

		su - RemoteDesktop -c "VBoxManage storageattach 'RemoteDesktop' --storagectl '${STORAGE_CTL_NAME} Controller' --port 1 --device 0 --type dvddrive --medium /vboxguests/${GUEST_ADDITIONS_ISO}"

		echo -e "\n${YELL}The guest additions DVD ISO should now be available in the guest OS.${NRML}"
		echo -e "${YELL}Please install the guest additions and reboot the guest OS.${NRML}\n\n"
		question_yes "Finished installing guest additions and rebooted the guest OS?"
		su - RemoteDesktop -c "VBoxManage controlvm 'RemoteDesktop' setvideomodehint 1272 700 32"
	fi

	echo -e "\n${YELL}Now you may configure and install software as necessary into the ${NRML}"
	echo -e "${YELL}remote desktop template. Reboot when done...${NRML}\n"

	STILL_CONFIGURING="yes"
	while [ "${STILL_CONFIGURING}" = "yes" ]
	do
		while true
			do
			echo -e "${LCYN}Would you like to insert a DVD ISO into the remote desktop template ${NRML}"
			readee -p "${LCYN}or have you finished setting up the template (insert/finish): ${NRML}" ANSWER
			if [ "${ANSWER}" = "insert" ] || [ "${ANSWER}" = "finish" ]
			then
				break
			fi
			echo -e ""
		done
	
		if [ "${ANSWER}" = "finish" ]
		then
			STILL_CONFIGURING="no"
		else
			# Ask for DVD ISO file to insert
			dialog --fselect / 20 80 2> ${DIALOG_OUT_FILE}
			SELECTED_FILE=`cat ${DIALOG_OUT_FILE}`
			if [ -f "${SELECTED_FILE}" ]
			then
				file ${SELECTED_FILE} | grep "ISO 9660" > /dev/null
				if [ ${?} -eq 0 ]
				then
					su - RemoteDesktop -c "VBoxManage storageattach 'RemoteDesktop' --storagectl 'IDE Controller' --port 1 --device 0 --type dvddrive --medium ${SELECTED_FILE}"
					echo -e "\n\n${YELL}The selected ISO should now be inserted and available in the guest OS.${NRML}\n"
				else
					echo -e "\n\n${ORNG}WARNING:${NRML} File selected is not an ISO!\n"
					pause_prompt 5
				fi
			else
				echo -e "\n\n${ORNG}WARNING:${NRML} No file selected!\n"
				pause_prompt 5
			fi
		fi
	done

	service RemoteDesktop onestop
	zfs snapshot ${POOL_NAME}/vboxguests/RemoteDesktop@${RD_TEMPLATE_NAME}

	echo -e "\n${LGRN}Congratulations! The remote desktop template '${RD_TEMPLATE_NAME}'${NRML}"
	echo -e "${LGRN}is ready to use.${NRML}\n"
	echo -e "${LGRN}To setup a new remote desktop, use the command:${NRML}"
	echo -e "${LBLU}${SCRIPT_NAME} create-remote-desktop-instance${NRML}\n"

	cd -

}

create_remote_desktop_instance ()
{

	RD_TEMPLATE_NAME=$1
	VNC_OFFSET=$2
	VNC_PASSWORD=$3
	RD_NAME=${RD_TEMPLATE_NAME}${VNC_OFFSET}

	cd /${REPO_NAME}

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'init-host' subcommand first."
		echo -e "       Aborting.\n"
		exit 120
	fi

	# Check that the remote desktops subsystem is initialised and therefore we know the pool name.
	POOL_NAME=`cat ${FDO_CONFIG_ROOT}/remote_desktops_pool.conf 2> /dev/null`
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the remote desktops subsystem is not initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} init-remote-desktops${NRML}\n       Aborting.\n"
		exit 121
	fi

	# Check that the template exists
	zfs list ${POOL_NAME}/vboxguests/RemoteDesktop@${RD_TEMPLATE_NAME} > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The remote desktop template '${RD_TEMPLATE_NAME}' does not exist!"
		echo -e "       Please use the 'create-remote-desktop-template' subcommand first."
		echo -e "       Aborting.\n"
		exit 122
	fi

	# Check that the VNC offset is not already in use
	PREVIOUS_IFS=${IFS}
	IFS=${CARRIAGE_RETURN}
	VBOX_CONFIGS=`ls /vboxguests/*/VirtualBox\ VMs/*/*.vbox`
	PORT_USED_COUNT=0
	for VBOX_CONFIG in ${VBOX_CONFIGS} ; do egrep "name=\"TCP\/Ports\" value=\"60${VNC_OFFSET}\"" "${VBOX_CONFIG}" > /dev/null ; if [ ${?} -eq 0 ] ; then PORT_USED_COUNT=$(( ${PORT_USED_COUNT} + 1 )) ; fi ;done
	if [ ${PORT_USED_COUNT} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The VNC port offset is already in use!\n       Aborting.\n"
		exit 123
	fi
	IFS=${PREVIOUS_IFS}

	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the 'update-config' subcommand to keep the repo up-to-date."
		echo -e "       Aborting.\n"
		exit 124
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	zfs clone ${POOL_NAME}/vboxguests/RemoteDesktop@${RD_TEMPLATE_NAME} ${POOL_NAME}/vboxguests/${RD_NAME}

	mv "/vboxguests/${RD_NAME}/VirtualBox VMs/RemoteDesktop" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}"
	mv "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/RemoteDesktop.vbox" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/${RD_NAME}.vbox"
	mv "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/RemoteDesktop.vbox-prev" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/${RD_NAME}.vbox-prev"
	mv "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/RemoteDesktop.vdi" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/${RD_NAME}.vdi"

	sed -i "" "s/RemoteDesktop/${RD_NAME}/g" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/${RD_NAME}.vbox"
	sed -i "" "s/RemoteDesktop/${RD_NAME}/g" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/${RD_NAME}.vbox-prev"

	find /vboxguests/${RD_NAME}/.kde -exec sed -i "" "s/RemoteDesktop/${RD_NAME}/g" {} \; 2> /dev/null
	find /vboxguests/${RD_NAME}/.kde4 -exec sed -i "" "s/RemoteDesktop/${RD_NAME}/g" {} \; 2> /dev/null
	find /vboxguests/${RD_NAME}/.config -exec sed -i "" "s/RemoteDesktop/${RD_NAME}/g" {} \; 2> /dev/null
	find /vboxguests/${RD_NAME}/.VirtualBox -exec sed -i "" "s/RemoteDesktop/${RD_NAME}/g" {} \; 2> /dev/null

	cpdup /usr/local/etc/rc.d/RemoteDesktop /usr/local/etc/rc.d/${RD_NAME}
	sed -i "" "s/RemoteDesktop/${RD_NAME}/g" /usr/local/etc/rc.d/${RD_NAME}

	pw useradd -n ${RD_NAME} -c "Remote Desktop ${VNC_OFFSET}" -d /vboxguests/${RD_NAME} -G vboxusers -s /usr/local/bin/bash
	chown -R ${RD_NAME}:${RD_NAME} /vboxguests/${RD_NAME}

	su - ${RD_NAME} -c "/usr/local/bin/VBoxManage setproperty vrdeextpack VNC"
	su - ${RD_NAME} -c "/usr/local/bin/VBoxManage modifyvm ${RD_NAME} --vrdeport 60${VNC_OFFSET}"
	su - ${RD_NAME} -c "/usr/local/bin/VBoxManage modifyvm ${RD_NAME} --vrdeproperty VNCPassword=${VNC_PASSWORD}"
	su - ${RD_NAME} -c "/usr/local/bin/VBoxManage modifyvm ${RD_NAME} --macaddress1 auto"

	cat configs/${HOST_NAME}/etc/rc.conf | grep ${RD_NAME}
	if [ $? != 0 ]
	then
		echo "${RD_NAME}_enable=\"YES\"" >> configs/${HOST_NAME}/etc/rc.conf
	fi

	touch /var/log/${RD_NAME}.log
	chown ${RD_NAME}:${RD_NAME} /var/log/${RD_NAME}.log

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'create-remote-desktop-instance' for '${RD_NAME}'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
		git_push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished creating the remote desktop '${RD_NAME}'.${NRML}"
	echo -e "\n${LGRN}To start the remote desktop, use the command:${NRML}"
	echo -e "${LBLU}service ${RD_NAME} start${NRML}\n"

	cd -

}

start_jail_service ()
{
	# ${1} is jail name
	# ${2} is service name
	# ${3} may be --allow-restart

	get_jail_id_from_name ${1}

	echo -e "\n${YELL}Starting the service '${2}' in the jail '${1}'...${NRML}\n"

	jexec ${JAIL_ID} service ${2} start > /dev/null 2>&1

	if [ ${?} -ne 0 ] && [ "${3}" = "--allow-restart" ]
	then
		jexec ${JAIL_ID} service ${2} restart > /dev/null 2>&1
	fi

	if [ ${?} -ne 0 ]
	then
		echo -e "${ORNG}WARNING:${NRML} Failed to start service '${2}' in jail '${1}'!\n"
	else
		echo -e "${YELL}INFO:${NRML} Successfully started service '${2}' in jail '${1}'!\n"
	fi

}

find_jails_from_recipe_name ()
{
	FIND_RECIPE_NAME="${1}"
	FOUND_RECIPE_JAILS=""
	for TEST_JAIL_NAME in `ls -1 /jls | cut -d/ -f1`
	do
		if [ -f "/jls/${TEST_JAIL_NAME}/.fdo-jail-recipe.inf" ]
		then
			TEST_RECIPE_NAME=`cat /jls/${TEST_JAIL_NAME}/.fdo-jail-recipe.inf`
			if [ "${TEST_RECIPE_NAME}" = "${FIND_RECIPE_NAME}" ]
			then
				if [ "${FOUND_RECIPE_JAILS}" = "" ]
				then
					FOUND_RECIPE_JAILS="${TEST_JAIL_NAME}"
				else
					FOUND_RECIPE_JAILS="${FOUND_RECIPE_JAILS} ${TEST_JAIL_NAME}"
				fi
			fi
		fi
	done

}

create_jail ()
{

	if [ "${3}" = "--non-interactive" ]
	then
		IS_INTERACTIVE="no"
	else
		IS_INTERACTIVE="yes"
	fi

	JAIL_NAME=${1}
	JAIL_HOST_NAME=${2}

	cd /${REPO_NAME}

	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use 'update-config' to keep the repo up-to-date.\n       Aborting.\n"
		exit 130
	fi

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'init-host' subcommand first.\n       Aborting.\n"
		exit 131
	fi

	# Check that the jails subsystem is initialised and therefore we know the pool name.
	POOL_NAME=`cat ${FDO_CONFIG_ROOT}/jails_pool.conf 2> /dev/null`
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the jails subsystem is not initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} init-jails${NRML}\n       Aborting.\n"
		exit 132
	fi

	# Check that the jail_name has not already been used.
	cat /etc/jail.conf | egrep "^${JAIL_NAME} {" > /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The jail_name '${JAIL_NAME}' is already in use.\n       Aborting.\n"
		exit 133
	fi

	# Check that, if specified, the jail IP address is not already in use.
	if [ "${JAIL_IP}" != "" ]
	then
		test_ping_host ${JAIL_IP}
		if [ "${VALID_HOST_PING}" = "yes" ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The jail IP address '${JAIL_IP}' is already in use.\n       Aborting.\n"
			exit 134
		fi
	fi

	# Get version strings
	FREEBSD_VERSION_STRING=`freebsd-version`
	FREEBSD_VERSION=`freebsd-version | cut -d- -f1`
	FREEBSD_MAJOR_VERSION=`echo ${FREEBSD_VERSION} | cut -d. -f1`
	FREEBSD_MINOR_VERSION=`echo ${FREEBSD_VERSION} | cut -d. -f2`
	FREEBSD_CADENCE=`freebsd-version | cut -d- -f2`
	FREEBSD_PATCH_LEVEL=`freebsd-version | cut -d- -f3`
	FREEBSD_ARCH=`uname -m`

	TEMPLATE_SNAPSHOT=`zfs list -t all -r ${POOL_NAME}/jails/template | awk '{print $1}' | cut -d@ -f2| egrep "^${FREEBSD_VERSION}-RELEASE" | sort | tail -1`

	LAN_NET_IFACE=`cat ${FDO_CONFIG_ROOT}/net_iface_lan.conf`

	if [ "${JAIL_IP}" = "" ]
	then
		FIRST_AVAILABLE_IP=51
		while true
		do
			ifconfig ${LAN_NET_IFACE} | egrep "inet.*netmask 0xffffffff" | egrep "${JAILS_LAN_SUBNET_C}.${FIRST_AVAILABLE_IP}" > /dev/null 2>&1
			if [ ${?} -ne 0 ]
			then
				break
			else
				FIRST_AVAILABLE_IP=$(( ${FIRST_AVAILABLE_IP} +1 ))
			fi
		done
		JAIL_IP="${JAILS_LAN_SUBNET_C}.${FIRST_AVAILABLE_IP}"
	fi

	# Create new jail fileststem by cloning from the template jail
	zfs clone ${POOL_NAME}/jails/template@${TEMPLATE_SNAPSHOT} ${POOL_NAME}/jails/${JAIL_NAME}

	# Install template jails' configs to new jails' config repo directory
	# NOTE: this has the side effect of giving the new jail the latest template configs regardless of snapshot state
	mkdir configs/${JAIL_NAME}@${HOST_NAME}
	JAIL_CONFIG_FILES=`find config-templates/init-jails -type f | sed "s|^config-templates/init-jails/||"`
	for CONFIG_FILE in ${JAIL_CONFIG_FILES}
	do
		if [ -f "/jls/template/${CONFIG_FILE}" ]
		then
			# If the config file is etc/resolv.conf, then copy it directly to the new jail, otherwise add to the registered config files.
			if [ "${CONFIG_FILE}" = "etc/resolv.conf" ]
			then
				cp /jls/template/${CONFIG_FILE} /jls/${JAIL_NAME}/${CONFIG_FILE}
			else
				CONFIG_FILE_DIR=`dirname ${CONFIG_FILE}`
				if [ ! -d ${CONFIG_FILE_DIR} ]
				then
					mkdir -p configs/${JAIL_NAME}@${HOST_NAME}/${CONFIG_FILE_DIR}
				fi
				cp /jls/template/${CONFIG_FILE} configs/${JAIL_NAME}@${HOST_NAME}/${CONFIG_FILE}
			fi
		fi
	done

	# Save the previous git commit reference to file, for later use in reverting operations
	git log --format=format:%H -1 > /jls/${JAIL_NAME}/.fdo-pre-create-jail.commit.inf

	# Create entry in configs/${HOST_NAME}/etc/jail.conf
	echo "" >> configs/${HOST_NAME}/etc/jail.conf
	echo "${JAIL_NAME} {" >> configs/${HOST_NAME}/etc/jail.conf
	echo "        exec.prestart += \"/sbin/ifconfig ${LAN_NET_IFACE} inet ${JAIL_IP} netmask 255.255.255.255 alias\";" >> configs/${HOST_NAME}/etc/jail.conf
	echo "        exec.poststop += \"/sbin/ifconfig ${LAN_NET_IFACE} inet ${JAIL_IP} netmask 255.255.255.255 -alias\";" >> configs/${HOST_NAME}/etc/jail.conf
	echo "        host.hostname = \"${JAIL_HOST_NAME}\";" >> configs/${HOST_NAME}/etc/jail.conf
	echo "        ip4.addr = ${JAIL_IP};" >> configs/${HOST_NAME}/etc/jail.conf
	echo "}" >> configs/${HOST_NAME}/etc/jail.conf

	# Prepare the jail fstab
	cp configs/${HOST_NAME}/etc/fstab.template configs/${HOST_NAME}/etc/fstab.${JAIL_NAME}
	sed -i "" "s|/jls/template/|/jls/${JAIL_NAME}/|" configs/${HOST_NAME}/etc/fstab.${JAIL_NAME}

	# Add jail to jail_list in /etc/rc.conf
	egrep "jail_list.*${JAIL_NAME}" configs/${HOST_NAME}/etc/rc.conf > /dev/null
	if [ $? -ne 0 ]
	then
		sed -i "" "s|jail_list=\"\(.*\)\"|jail_list=\"\1 ${JAIL_NAME}\"|" configs/${HOST_NAME}/etc/rc.conf
	else
		echo -e "\n${ORNG}WARNING:${NRML} The jail name '${JAIL_NAME}' already exists in jail_list (/etc/rc.conf)!\n"
	fi

	# Install latest scripts to the jail
	install_scripts /jls/${JAIL_NAME}/

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	# Install initial config templates to the new jail
	install_file_tree configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/

	if [ "${IS_INTERACTIVE}" = "yes" ]
	then
		# Add changes to the local config repo
		git add configs/${HOST_NAME}
		git add configs/${JAIL_NAME}@${HOST_NAME}

		echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
		git commit -m "Updating host after 'create-jail ${JAIL_NAME} ${JAIL_HOST_NAME}'; ${HOST_NAME}."

		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
			git_push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			fi
		fi

		# Save this git commit reference to file, for later use in reverting operations
		git log --format=format:%H -1 > /jls/${JAIL_NAME}/.fdo-post-create-jail.commit.inf

		echo -e "\n${LGRN}Congratulations! We have now finished creating the jail '${JAIL_NAME}'.${NRML}"
		echo -e "\n${LGRN}To login to the jail, use the command:${NRML}"
		echo -e "${LBLU}jlogin ${JAIL_NAME}${NRML}\n"
	
		question_yes_no "Would you like to start the jail '${JAIL_NAME}' now?"
		if [ "${ANSWER}" = "yes" ]
		then
			service jail start ${JAIL_NAME}
		fi
	else
		service jail start ${JAIL_NAME}
	fi

	echo -e ""

	cd -

}

# WARNING: Only for use by developers on a 'local' only repo.
# Only to be used on last created jail directly afterwards.
# It does a hard reset of the git repo.
revert_create_jail ()
{
	JAIL_TO_REVERT=${1}

	# Sanity tests
	egrep "^${JAIL_TO_REVERT} {" /etc/jail.conf > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The jail '${JAIL_TO_REVERT}' does not seem to exist!\n       Aborting.\n"
		exit 138
	fi

	# NOTE: commit after create jail is not much use, since we can't remove a previous range
	#       of commits using 'git revert' with creating conflicts that need manual intervention.
	COMMIT_BEFORE_CREATE_JAIL=`cat /jls/${JAIL_TO_REVERT}/.fdo-pre-create-jail.commit.inf`
	COMMIT_AFTER_CREATE_JAIL=`cat /jls/${JAIL_TO_REVERT}/.fdo-post-create-jail.commit.inf`

	if [ -f /jls/${JAIL_TO_REVERT}/.fdo-affected-recipe-jails.inf ]
	then
		AFFECTED_JAIL_RECIPES=`cat /jls/${JAIL_TO_REVERT}/.fdo-affected-recipe-jails.inf`
	else
		AFFECTED_JAIL_RECIPES=""
	fi

	echo -e "\n${YELL}Reverting create jail for ${JAIL_TO_REVERT}...${NRML}\n"

	cd /${REPO_NAME}

	# Stop the jail
	service jail stop ${JAIL_TO_REVERT}
	sleep 10
	jls | tail -n +2 | awk '{print $3}' | egrep "${JAIL_TO_REVERT}" > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		JAIL_ID_FILE=`ls -1 /var/run/jail_${JAIL_TO_REVERT}.id | head -1`
		JAIL_ID=`cat ${JAIL_ID_FILE}`
		jail -r ${JAIL_ID}
		umount -f /jls/${JAIL_TO_REVERT}/usr/local/etc/ssl/certs
	fi

	echo -e "\n"

	# Destroy additional jail recipe datasets in reverse order
	REV_RECIPE_ZFS_DATASETS=`echo ${RECIPE_ZFS_DATASETS} | rev`
	for REV_RECIPE_ZFS_DATASET in ${REV_RECIPE_ZFS_DATASETS}
	do
		RECIPE_ZFS_DATASET=`echo ${REV_RECIPE_ZFS_DATASET} | rev`
		zfs destroy -f ${RECIPE_ZFS_DATASET}
	done

	# Destroy the jail filesystem
	POOL_NAME=`cat ${FDO_CONFIG_ROOT}/jails_pool.conf 2> /dev/null`
	zfs destroy -rf ${POOL_NAME}/jails/${JAIL_TO_REVERT}

	# Delete jail config directory from local repo
	rm -rf configs/${JAIL_TO_REVERT}@${HOST_NAME}

	# Roll back local repo to last good commit (!!!DANGEROUS!!!)
	git reset --hard ${COMMIT_BEFORE_CREATE_JAIL}

	# Remove untracked files from local repo
	rm configs/${HOST_NAME}/etc/fstab.${JAIL_TO_REVERT} > /dev/null 2>&1

	# Remove untracked config files from host and config repo
	rm /etc/fstab.${JAIL_TO_REVERT} > /dev/null 2>&1

	# Install back old host configs
	install_file_tree configs/${HOST_NAME} /

	# Install back affected jail configs
	for AFFECTED_JAIL_RECIPE in ${AFFECTED_JAIL_RECIPES}
	do
		echo -e "\n${YELL}Reverting configs for jails affected by recipe '${AFFECTED_JAIL_RECIPE}':${NRML}"
		find_jails_from_recipe_name ${AFFECTED_JAIL_RECIPE}
		for AFFECTED_JAIL in ${FOUND_RECIPE_JAILS}
		do
			# Use install_config to reinstate configs for jail found to be affected
			echo -e "${YELL}${AFFECTED_JAIL}...${NRML}"
			install_configs configs/${AFFECTED_JAIL}@${HOST_NAME} /jls/${AFFECTED_JAIL}/
		done
	done

	echo -e "\n${YELL}Finished reverting jail creation! Exiting.${NRML}\n"
	exit 139

}

edit_recipe_configs ()
{

	echo -e "\n"

	for CONFIG_FILE in ${RECIPE_CONFIG_FILES}
	do
		# Skip directories and certain unintersting files
		FILE_PATH=`echo ${CONFIG_FILE} | sed "s|[^/]*\/[^/]*\/||"`
		FILE_NAME=`basename ${CONFIG_FILE}`
		if [ -d ${CONFIG_FILE} ] || [ "${FILE_NAME}" = "${PKG_REPO_CONF_FILE}" ] || [ "${FILE_NAME}" = "${PKG_REPO_CERT_FILE}" ] \
			|| [ "${FILE_PATH}" = "usr/local/etc/pkg/repos/freebsd.conf" ] || [ "${FILE_NAME}" = ".empty" ]
		then
			continue
		fi

		# Skip files modified prior to recipe (e.g. from create_jail)
		CONFIG_FILE_MODIFIED_TIMESTAMP=`stat -f "%Sm" -t "%s" ${CONFIG_FILE}`
		if [ ${PRE_RECIPE_TIMESTAMP} -gt ${CONFIG_FILE_MODIFIED_TIMESTAMP} ]
		then
			continue
		fi

		# Prompt user and if yes, display the config file in EDITOR
		question_yes_no "Would you like to edit the recipe config '${CONFIG_FILE}'?"
		if [ "${ANSWER}" = "yes" ]
		then
			if [ "${EDITOR}" = "" ]
			then
				EDITOR=ee
			fi
			echo ""
			${EDITOR} ${CONFIG_FILE}
			echo ""
		fi
	done

}

create_jail_from_recipe ()
{

	JAIL_NAME="${1}"
	JAIL_HOST_NAME="${2}"
	JAIL_RECIPE_NAME="${3}"

	get_enabled_nat_services

	# Source the recipe
	if [ -f "/${REPO_NAME}/jail-recipes/${JAIL_RECIPE_NAME}/${JAIL_RECIPE_NAME}" ]
	then
		. "/${REPO_NAME}/jail-recipes/${JAIL_RECIPE_NAME}/${JAIL_RECIPE_NAME}"
	else
		echo -e "\n${LRED}ERROR:${NRML} Unable to find the referenced recipe!"
		echo -e "       Check that the recipe '${JAIL_RECIPE_NAME}' exists.\n       Aborting.\n"
		exit 140
	fi

	echo -e "\n\n${YELL}Creating a blank jail with the IP address '${JAIL_IP}'...${NRML}\n"

	# Create a blank jail (non-interactively)
	create_jail ${JAIL_NAME} ${JAIL_HOST_NAME} --non-interactive
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Creation of blank jail failed!\n       Aborting.\n"
		revert_create_jail ${JAIL_NAME}
	fi

	# Source the recipe again to pick up any updated variables
	. /${REPO_NAME}/jail-recipes/${JAIL_RECIPE_NAME}/${JAIL_RECIPE_NAME}

	echo -e "\n\n${YELL}Creating any additional jail recipe datasets...${NRML}\n"

	sleep 1
	PRE_RECIPE_TIMESTAMP=`date "+%s"`

	# Create additional jail recipe datasets
	COUNT_DATASETS=0
	for RECIPE_ZFS_DATASET in ${RECIPE_ZFS_DATASETS}
	do
		COUNT_DATASETS=$(( ${COUNT_DATASETS} + 1 ))
		RECIPE_ZFS_MOUNTPOINT=`echo ${RECIPE_ZFS_MOUNTPOINTS} | awk -v column="${COUNT_DATASETS}" '{print $column}'`
		zfs create -o mountpoint=${RECIPE_ZFS_MOUNTPOINT} ${RECIPE_ZFS_DATASET}
	done

	cd /${REPO_NAME}

	# Install recipe config templates to new jails' config repo directory
	install_file_tree jail-recipes/${JAIL_RECIPE_NAME}/config-templates configs/${JAIL_NAME}@${HOST_NAME}/

	# Set the correct jail ABI in the jails' pkg repo conf file
	sed -i "" "s|FDO_JAIL_ABI|${FREEBSD_MAJOR_VERSION}_${FREEBSD_MINOR_VERSION}${FREEBSD_ARCH}|" configs/${JAIL_NAME}@${HOST_NAME}/usr/local/etc/pkg/repos/FDo-pkg.conf

	# Install initial config templates to the new jail
	install_file_tree configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/

	echo -e "\n\n${YELL}Cooking '${JAIL_RECIPE_NAME}' recipe for '${JAIL_NAME}'...${NRML}\n"

	# Cook the sourced recipe
	cook_recipe

	# Add any port forwarding rules
	if [ ${RECIPE_TCP_PORTS} ] && [ ${RECIPE_UDP_PORTS} ]
	then
		IS_REPO_CONF="yes" PF_CONF_PATH="configs/${HOST_NAME}/etc/pf.conf" fdo-pf-add-port-forward-rule "jail_${JAIL_NAME}" ${JAIL_IP} ${RECIPE_TCP_PORTS} ${RECIPE_UDP_PORTS} --non-interactive
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} failed to add port forwarding rules to pf!\n"
			RECIPE_SUCCESS="no"
		fi
		IS_REPO_CONF="yes" PPP_CONF_PATH="configs/${HOST_NAME}/etc/ppp/ppp.conf" fdo-ppp-add-port-forward-rule "jail_${JAIL_NAME}" ${JAIL_IP} ${RECIPE_TCP_PORTS} ${RECIPE_UDP_PORTS} --non-interactive
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} failed to add port forwarding rules to ppp nat!\n"
			RECIPE_SUCCESS="no"
		fi
	fi

	if [ "${RECIPE_SUCCESS}" = "yes" ] || [ "${RECIPE_SUCCESS}" = "devel" ]
	then
		# Interactively edit the configs touched by the recipe
		RECIPE_CONFIG_FILES=`find configs/${JAIL_NAME}@${HOST_NAME} -print`
		edit_recipe_configs

		# Save recipe name to information file
		echo "${JAIL_RECIPE_NAME}" > configs/${JAIL_NAME}@${HOST_NAME}/.fdo-jail-recipe.inf
		chmod a-w configs/${JAIL_NAME}@${HOST_NAME}/.fdo-jail-recipe.inf

		# Install any new or modfied configs
		install_file_tree configs/${HOST_NAME} /
		install_file_tree configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/

		# Restart pf if required
		if [ "${RECIPE_REQUIRES_NAT_RELOAD}" = "yes" ]
		then
			echo -e "\n"
			question_yes_no "Changes made by this recipe require restarting the NAT router service.\nWould you like to restart it now?"
			if [ "${ANSWER}" = "yes" ]
			then
				echo -e ""
				if [ "${IS_PPP_NAT_ENABLED}" = "YES" ]
				then
					# TODO: resolve why ppp can't reconnect on service restart.
					#service ppp restart
					service ppp stop
					sleep 3
					service ppp start
					sleep 3
					service ppp start
				fi
				if [ "${IS_PF_NAT_ENABLED}" = "YES" ]
				then
					service pf reload
				fi
			fi
		fi

		# Restart jail if required
		if [ "${RECIPE_REQUIRES_JAIL_RESTART}" = "yes" ]
		then
			service jail restart ${JAIL_NAME}
		fi

		# Start jail recipe services
		for SERVICE in ${START_JAIL_SERVICES}
		do
			start_jail_service ${JAIL_NAME} ${SERVICE} --allow-restart
			sleep 3
		done

	elif [ "${RECIPE_SUCCESS}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Jail recipe failed!\n"
		revert_create_jail ${JAIL_NAME}
	else
		echo -e "\n${ORNG}WARNING:${NRML} The recipe did not return a valid RECIPE_SUCCESS variable!\n"
	fi

	if [ "${RECIPE_SUCCESS}" = "devel" ]
	then
		echo -e "\n${LGRN}After tasting your new recipe, you may run the command:${NRML}"
		echo -e "${LBLU}${SCRIPT_NAME} revert-create-jail ${JAIL_NAME}${NRML}\n"

		question_yes_no "Would you like to commit the changes to the config repo?"
		if [ "${ANSWER}" = "yes" ]
		then
			RECIPE_SUCCESS="yes"
		else
			echo -e ""
		fi
	fi

	if [ "${RECIPE_SUCCESS}" = "yes" ]
	then
		git add configs/${HOST_NAME}
		git add configs/${JAIL_NAME}@${HOST_NAME}
		git commit -m "Updating host after 'create-jail-from-recipe ${JAIL_NAME} ${JAIL_HOST_NAME} ${JAIL_RECIPE_NAME}'; ${HOST_NAME}."

		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
			git_push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			fi
		fi
 
		# Save this git commit reference to file, for later use in reverting operations
		git log --format=format:%H -1 > /jls/${JAIL_NAME}/.fdo-post-create-jail.commit.inf

		if [ -f /jls/${JAIL_NAME}/usr/local/etc/ssl/jail-certs.list ]
		then
			echo -e "\n${ORNG}NOTICE:${NRML} This jail requires some SSL certificates to be placed in the directory  "
			echo -e "         '/usr/local/etc/ssl/certs'. They can be copied or symlinked to the     "
			echo -e "         correct file name either manually or by using the 'fdo-cert-manager'   "
			echo -e "         utility. To see a list of the required certificate files, use the      "
			echo -e "         following command:                                                     "
			echo -e "         ${LBLU}cat /jls/${JAIL_NAME}/usr/local/etc/ssl/jail-certs.list${NRML}\n"
		fi

		echo -e "\n${LGRN}Congratulations! We have now finished creating the jail '${JAIL_NAME}'.${NRML}"
		echo -e "${LGRN}To login to the jail, use the command:${NRML}"
		echo -e "${LBLU}jlogin ${JAIL_NAME}${NRML}\n"
	fi

	cd -

}

init_clonezilla_images ()
{

	cd /${REPO_NAME}

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo!"
		echo -e "       Please use the 'init-host' subcommand first.\n       Aborting.\n"
		exit 160
	fi

	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the 'update-config' subcommand to keep the repo up-to-date."
		echo -e "       Aborting.\n"
		exit 161
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Get pool name to use for Clonezilla images.
	POOL_NAME=""
	POOLS_AVAILABLE=`zpool list | tail -n +2 | awk '{print $1}'`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n       Aborting.\n"
		exit 162
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool for Clonezilla images:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n"
			question_yes_no "\nYou have selected '${NRML}${POOL_NAME_TEMP}${LCYN}' to store the Clonezilla images.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				POOL_NAME="${POOL_NAME_TEMP}"
			fi
		done
	fi

	# Get the LAN interface that the NFS share will run on
	CONFIG_LAN_NET_IFACE=`cat ${FDO_CONFIG_ROOT}/net_iface_lan.conf`
	LAN_NET_IFACE=""
	HOST_LAN_IP_ADDRESSES=""
	NET_IFACES=`ifconfig -l`
	for IFACE in ${NET_IFACES}
	do
		if [ "${IFACE}" = "${CONFIG_LAN_NET_IFACE}" ]
		then
			HOST_LAN_IP_ADDRESSES=`ifconfig ${IFACE} | egrep "inet.*netmask" | awk '{print $2}' | egrep "${SERVERS_LAN_SUBNET_C}." | sort`
			if [ "${HOST_LAN_IP_ADDRESSES}" != "" ]
			then
				LAN_NET_IFACE="${IFACE}"
			fi
		fi
	done

	# Exit if the LAN subnet interface was not found
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The LAN interface '${CONFIG_LAN_NET_IFACE}' does not provide a valid '${SERVERS_LAN_SUBNET_C}.*' subnet!\n       Aborting.\n"
		exit 163
	fi

	# Get the LAN IP address of the NFS host
	for IP_ADDRESS in ${HOST_LAN_IP_ADDRESSES}
	do
		# Let's ASSUME that the first and lowest (numerically) IP is the primary LAN IP
		HOST_LAN_IP="${IP_ADDRESS}"
		break
	done

	# Warn if Clonezilla images dataset already exists.
	zfs list ${POOL_NAME}/clonezilla-images 2> /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The ZFS dataset '${POOL_NAME}/clonezilla-images' already exists!\n"
	fi

	sed -i "" "s/mountd_enable=\"NO\"/mountd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/nfs_server_enable=\"NO\"/nfs_server_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpc_lockd_enable=\"NO\"/rpc_lockd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpc_statd_enable=\"NO\"/rpc_statd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpcbind_enable=\"NO\"/rpcbind_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	# Create the ZFS dataset for the Clonezilla images
	zfs create -o mountpoint=/usr/home/partimag ${POOL_NAME}/clonezilla-images

	touch /etc/exports

	echo -e ""

	# Start the NFS services
	service rpcbind start
	service lockd start
	service nfsd start

	# Add mountpoint to NFS exports file
	cat /etc/exports | egrep "^/usr/home/partimag " > /dev/null 2>&1
	if  [ ${?} -ne 0 ]
	then
		echo "/usr/home/partimag -maproot=root -network ${FDO_LAN_SUBNET_B}.0.0 -mask ${FDO_LAN_SUBNET_MASK}" >> /etc/exports
		echo -e ""
		service mountd reload
	fi

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'init-clonezilla-images'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...${NRML}\n"
		git_push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished setting up an NFS share for Clonezilla${NRML}"
	echo -e "${LGRN}images.${NRML}\n"
	echo -e "${YELL}Clonezilla images NFS version:      3${NRML}"
	echo -e "${YELL}Clonezilla images host address:     ${HOST_LAN_IP}${NRML}"
	echo -e "${YELL}Clonezilla images server directory: /home/partimag${NRML}\n"

	cd -

}

merge_local_repo_to_remote ()
{
	# Test that we are actually using a local repo
	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears you are already using a remote repo!\n"
		question_yes_no "Would you like to proceed regardless?"
		if [ "${ANSWER}" = "no" ]
		then
			echo "       Aborting.\n"
			exit 180
		fi
	fi

	# Ask for the URI of the remote repo.
	REMOTE_REPO_URI=""
	while [ "${REMOTE_REPO_URI}" = "" ]
	do
		echo -e "\n${LCYN}Enter the remote git repo URI:${NRML}"
		readee REMOTE_REPO_URI_TEMP
		# Allow use to change their mind about type of repo
		if [ "${REMOTE_REPO_URI_TEMP}" = "" ]
		then
			break
		fi
		# Test the input to see if it is a valid URI (URL)
		test_valid_simple_url "${REMOTE_REPO_URI_TEMP}"
		if [ "${VALID_URL}" = "yes" ]
		then
			question_yes_no "\nYou have entered '${NRML}${REMOTE_REPO_URI_TEMP}${LCYN}'\nas the remote git repo URI.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				REMOTE_REPO_URI=${REMOTE_REPO_URI_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} remote git repo URI is invalid!\n"
		fi
	done

	# Check that the remote repo is valid and that this hostname does not already exist.
	cd /tmp
	rm -rf "${REPO_NAME}"
	echo -e "\n${YELL}We need to check that this host does not already exist in the remote repo.${NRML}"
	echo -e "${YELL}Please enter the remote repo credentials when prompted...${NRML}\n"
	pause_prompt 8
	git clone "${REMOTE_REPO_URI}" "${REPO_NAME}"
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to clone the remote repo!\n       Aborting.\n"
		exit 181
	fi
	if [ ! -d "${REPO_NAME}/configs/" ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The remote repo does not contain a config directory."
		echo -e "         This usually means that it is a newly created, empty repo.\n"
	elif [ -d  "${REPO_NAME}/configs/${HOST_NAME}" ]
	then
		rm -rf "${REPO_NAME}"
		echo -e "\n${LRED}ERROR:${NRML} This host already exists in the remote repo!"
		echo -e "       Consider removing or renaming the stale host config directory in the"
		echo -e "       remote repo.\n       Aborting.\n"
		exit 182
	else
		echo -e "\n${LGRN}The remote repo seems to be ok!${NRML}\n"
	fi
	rm -rf "${REPO_NAME}"

	# Move into the local repo.
	cd "/${REPO_NAME}"

	# Record last local commit, so that we can rewind if needed.
	LAST_LOCAL_COMMIT=`git log -1 | head -1 | awk '{print $2}'`

	# Check for an existing (stale) remote repo, and if user agrees, proceed and delete it.
	EXISTING_REMOTE=`git remote -v | egrep "^origin" | grep '(push)$' | awk '{print $2}'`
	if [ "${EXISTING_REMOTE}" != "" ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} There appears to be an existing remote origin in the local repo!"
		echo -e "         Git URI of origin: ${EXISTING_REMOTE}\n"
		question_yes_no "Would you like to proceed?"
		if [ "${ANSWER}" = "yes" ]
		then
			git remote remove origin
		else
			exit 183
		fi
	fi

	# Add the remote repo URI as this local repos' remote.
	git remote add origin "${REMOTE_REPO_URI}" > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to add the remote repo as the origin!\n       Aborting.\n"
		exit 184
	fi

	# Fetch the remote repo.
	echo -e "\n${YELL}Next we need to fetch the remote repo into our local repo.${NRML}"
	echo -e "${YELL}Please enter the remote repo credentials when prompted...${NRML}\n"
	pause_prompt 8
	git fetch
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to fetch the remote repo (origin/master)!\n       Aborting.\n"
		git remote remove origin
		exit 185
	fi

	# Align the master branch on both local and remote repo.
	git branch --set-upstream-to=origin/master master > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		# Remote is non-empty. Perform a merge of the local and remote master branch.
		echo -e "\n${YELL}Next we need to merge the remote repo and our local repo...${NRML}\n"
		pause_prompt 8
		git merge origin/master --allow-unrelated-histories -m "Merging local repo from host '${HOST_NAME}'."
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The merge operation seems to have failed!\n       Aborting.\n"
		git remote remove origin
		exit 186
		fi
	else
		NEEDS_UPSTREAM_BRANCH_SET="yes"
	fi

	# Lastly, push the local repo deltas to the remote repo.
	echo -e "\n${YELL}Now we need to push the local repo changes to the remote repo.${NRML}"
	echo -e "${YELL}Please enter the remote repo credentials when prompted...${NRML}\n"
	pause_prompt 8
	git_push origin master
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The push operation seems to have failed!\n       Aborting.\n"
		git remote remove origin
		git reset --soft "${LAST_LOCAL_COMMIT}"
		exit 187
	fi

	if [ "${NEEDS_UPSTREAM_BRANCH_SET}" ="yes" ]
	then
		# Align the master branch on both local and remote repo.
		git branch --set-upstream-to=origin/master master > /dev/null 2>&1
	fi

	REPO_URI="${REMOTE_REPO_URI}"
	echo "${REPO_URI}" >  "${FDO_CONFIG_ROOT}/fdo-server-repo.conf"
	
	echo -e "\n\n${LGRN}Congratulations! Successfully merged this hosts local repo to the remote repo.${NRML}\n"

}

##### MAIN EXECUTION THREAD ####################################################

TERM=${TERM}

SUB_CMD="${1}"
SUB_ARG1="${2}"
SUB_ARG2="${3}"
SUB_ARG3="${4}"
SUB_ARG4="${5}"
NUM_SUB_ARGS=$(( ${#} - 1 ))
HOST_NAME=`hostname -s`
FQHN=`hostname -f`
DOMAIN_NAME=`echo ${FQHN} | sed "s/${HOST_NAME}\.//"`

if [ "${SUB_CMD}" != "connect-internet" ]
then
	fetch_latest_self
	check_repo_config
fi

if [ ${#} -lt 1 ]
then
	usage
	exit 1
fi


case "${SUB_CMD}" in

	install-scripts)
		update_local_repo --no-check-scripts
		install_scripts_everywhere
		;;

	add-script)
		# Add new script to local and remote git repo
		test_num_mandatory_sub_args 1
		update_local_repo
		add_script "${SUB_ARG1}"
		;;

	update-script)
		# Update a script to local and remote git repo
		test_num_mandatory_sub_args 1
		update_local_repo
		update_script "${SUB_ARG1}"
		;;

	install-configs)
		update_local_repo

		# Install configs to the host
		question_yes_no "Are you sure you want to install all configs from the repo to this host?"
		if [ "${ANSWER}" = "yes" ]
		then
			install_configs configs/${HOST_NAME} /
		fi

		# Install configs to the jails
		cd /${REPO_NAME}
		for JAIL_NAME in `ls -1 configs | grep -e "@${HOST_NAME}" | cut -d@ -f1`
		do
			question_yes_no "Are you sure you want to install all configs from the repo to the\n'${JAIL_NAME}' jail?"
			if [ "${ANSWER}" = "yes" ]
			then
				install_configs configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/
			fi
		done
		cd -
		;;

	check-configs)
		update_local_repo
		check_all_configs
		;;

	add-config)
		# Add a config file from the system to local and remote git repo.
		test_num_mandatory_sub_args 1
		update_local_repo
		add_config "${SUB_ARG1}"
		;;

	update-config)
		# Update a config file from the system to local and remote git repo.
		test_num_mandatory_sub_args 1
		update_local_repo
		update_config "${SUB_ARG1}"
		;;

	connect-internet)
		# Create a non-persistent connection to the internet so that we can access FDo resources etc.
		connect_internet
		;;

	init-host)
		# Register a new host in the repo, install essential packages and initial configuration from templates.
		test_num_mandatory_sub_args 2
		init_host "${SUB_ARG1}" "${SUB_ARG2}"
		;;

	patch-host)
		# Use freebsd-update to update to latest patch level.
		patch_host
		;;

	setup-vnc-desktop)
		# Install minimal X desktop environment accessible via VNC using IceWM, Roxterm, Xfe, Firefox and TightVNC.
		update_local_repo
		setup_vnc_desktop
		;;

	init-hotdesking)
		# Initialise the NIS/NFS hostdesking subsystem.
		update_local_repo
		init_hotdesking
		;;

	init-clonezilla-images)
		# Initialise the NFS share for Clonezilla images.
		update_local_repo
		init_clonezilla_images
		;;

	merge-local-repo-to-remote)
		# Move and merge a local repo to a private remote repo.
		merge_local_repo_to_remote
		;;

	upgrade-repo-from-upstream)
		# Upgrade the private repo to include changes from the public upstream skeleton repo.
		update_local_repo
		upgrade_repo_from_upstream --push
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to upgrade from the public upstream skeleton git repo.\n"
		fi
		;;

	init-jails)
		# Initialise the FDo jails subsystem.
		update_local_repo
		init_jails
		;;

	create-jail)
		# Create a vanilla jail.
		test_num_mandatory_sub_args 2
		update_local_repo
		JAIL_IP=""
		create_jail "${SUB_ARG1}" "${SUB_ARG2}"
		;;

	create-jail-from-recipe)
		# Create a jail from a jail recipe.
		test_num_mandatory_sub_args 3
		update_local_repo
		JAIL_IP=""
		create_jail_from_recipe "${SUB_ARG1}" "${SUB_ARG2}" "${SUB_ARG3}"
		;;

	revert-create-jail)
		# Revert back to before last jail creation (developers).
		test_num_mandatory_sub_args 1
		revert_create_jail "${SUB_ARG1}"
		;;

	init-remote-desktops)
		# Initialise the FDo remote desktop subsystem (currently based on VirtualBox).
		update_local_repo
		init_remote_desktops
		;;

	create-remote-desktop-template)
		# Create a template (uses ZFS snapshots) for a particular type of remote desktop.
		test_num_mandatory_sub_args 1
		update_local_repo
		create_remote_desktop_template "${SUB_ARG1}"
		;;

	create-remote-desktop-instance)
		# Create a VM instance from a remote desktop template (uses ZFS snapshots).
		test_num_mandatory_sub_args 3
		update_local_repo
		create_remote_desktop_instance "${SUB_ARG1}" "${SUB_ARG2}" "${SUB_ARG3}"
		;;

	*)
		echo ""
		echo -e "${LRED}ERROR:${NRML} Sub-command ${SUB_CMD} is unknown!\n       Aborting.\n"
		usage
		exit 2
		;;

esac

################################################################################
