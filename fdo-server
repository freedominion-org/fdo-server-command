#!/bin/sh

# Copyright (c) 2016 Euan Thoms <euan@potensol.com>.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


##### GLOBAL STATIC VARIABLE DECLARATIONS ##########

SCRIPT_NAME=`basename $0`
REPO_NAME="fdo-server"
FDO_CONFIG_ROOT="/usr/local/etc/fdo"
FDO_SERVER_SKELETON_REPO="https://github.com/freedominion-org/fdo-server.git"
REPO_URI=`cat "${FDO_CONFIG_ROOT}/fdo-server-repo.conf" 2> /dev/null`
FETCH_LATEST_SELF_URL="http://freedominion.org/"
ESSENTIAL_PACKAGES="apcupsd axel bash bash-completion bsdadminscripts cpdup curl dmidecode git p7zip py27-speedtest-cli rsync stress tmux tree unrar unzip zfs-stats-lite zip nmap vim-lite"
ESSENTIAL_JAIL_PACKAGES="axel bash bash-completion bsdadminscripts cpdup curl portmaster rsync tree unrar unzip zip vim-lite"
REMOTE_DESKTOP_PACKAGES="virtualbox-ose"
VNC_DESKTOP_PACKAGES="xorg icewm clearlooks-themes roxterm xfe tightvnc firefox"
DIALOG_OUT_FILE="/tmp/fdo-server.dialog.answer"
NET_IFACES_IGNORED="^tun[0-9]|^vboxnet[0-9]|^lo[0-9]|^vlan[0-9]|^pflog[0-9]"
AUX_LOCAL_SERVER_IP_MIN=2
AUX_LOCAL_SERVER_IP_MAX=9
PKG_REPO_CONF_FILE="FDo-pkg.conf"
PKG_REPO_CERT_FILE="FDo-pkg.cert"

FDO_LAN_SUBNET_B="192.168"
FDO_LAN_SUBNET_NETMASK="255.255.0.0"
SERVICES_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.10"
WORKSTATIONS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.20"
HOTDESKS_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.30"
MOBILES_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.40"
DYNAMIC_LAN_SUBNET_C="${FDO_LAN_SUBNET_B}.50"

LRED="\033[1;31m"
LGRN="\033[1;32m"
LBLU="\033[1;34m"
LCYN="\033[1;36m"
CYAN="\033[0;36m"
YELL="\033[1;33m"
ORNG="\033[0;33m"
GREY="\033[0;37m"
DGRY="\033[1;30m"
NRML="\033[0;00m"

CARRIAGE_RETURN="
"


####################################################

usage ()
{
	if [ "${NO_DISPLAY_USAGE}" = "yes" ]
	then
		return 1
	fi

	echo -e ""
	echo -e "${LCYN}    ---- HOST MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} connect-internet${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} new-host host_name domain_name${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} new-host beastie1 example.net${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} patch-host${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} setup-vnc-desktop${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-hotdesking${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-clonezilla-images${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- SCRIPT MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} install-scripts${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} add-script script_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} add-script /usr/local/bin/findinfiles${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} update-script script_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} update-script /usr/local/bin/replaceinfiles${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- CONFIG FILE MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} add-config config_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} add-config /etc/ntp.conf${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} add-config /jls/dhcp/usr/local/etc/dhcpd.conf${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} update-config config_path${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} update-config /etc/ntp.conf${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} update-config /jls/dhcp/usr/local/etc/dhcpd.conf${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} install-configs${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} check-configs [--silent]${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- JAIL MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-jails${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-jail jail_name jail_hostname${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-jail foo foobar.example.net${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-jail-from-recipe jail_name jail_hostname recipe_name${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-jail-from-recipe dns_cache dns-cache dns_cache${NRML}"
	echo -e ""
	echo -e ""
	echo -e "${LCYN}    ---- REMOTE DESKTOP MANAGEMENT ----${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} init-remote-desktops${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-remote-desktop-template template_name${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-remote-desktop-template Windows7${NRML}"
	echo -e ""
	echo -e "${YELL}Usage:   ${LGRN}${SCRIPT_NAME} create-remote-desktop-instance template_name vnc_port_offset vnc_password${NRML}"
	echo -e "${NRML}Example: ${LBLU}${SCRIPT_NAME} create-remote-desktop-instance Windows7 01 opensesame${NRML}"
	echo -e ""
}

pause_prompt ()
{
	# $[1} is the pause duration in seconds (maximum is 25).
	PAUSE_DURATION=$(( ${1} * 10 ))
	if [ ${PAUSE_DURATION} -gt 250 ]
	then
		PAUSE_DURATION=250
	fi
	echo -e "\n${GREY}Press any key to continue...${NRML}\c"  
	CURRENT_TTY_SETTINGS=$(stty -g)
	stty raw -echo min 0 time ${PAUSE_DURATION}
	printf '%s' $(dd bs=1 count=1 2>/dev/null) > /dev/null
	stty ${CURRENT_TTY_SETTINGS}
	echo -e "\n"
}

question_yes_no ()
{

	LOOP=1

	while [ ${LOOP} = 1 ]
		do
		echo -e "${LCYN}${1} (yes/no): ${NRML}\c"
		read ANSWER
		if [ "${ANSWER}" = "yes" ] || [ "${ANSWER}" = "no" ]
		then
			LOOP=0
		fi
		echo ""
	done

}

question_yes ()
{

	LOOP=1

	while [ ${LOOP} = 1 ]
		do
		echo -e "${LCYN}${1} (yes): ${NRML}\c"
		read ANSWER
		if [ "${ANSWER}" = "yes" ]
		then
			LOOP=0
		fi
		echo ""
	done

}

get_class_b_subnet ()
{
	CLASS_B_SUBNET_IP="${1}"
	CLASS_B_SUBNET_FIRST=`echo "${CLASS_B_SUBNET_IP}" | cut -d. -f1`
	CLASS_B_SUBNET_SECOND=`echo "${CLASS_B_SUBNET_IP}" | cut -d. -f2`
	CLASS_B_SUBNET="${CLASS_B_SUBNET_FIRST}.${CLASS_B_SUBNET_SECOND}"
}

get_class_c_subnet ()
{
	CLASS_C_SUBNET_IP="${1}"
	CLASS_C_SUBNET_FIRST=`echo "${CLASS_C_SUBNET_IP}" | cut -d. -f1`
	CLASS_C_SUBNET_SECOND=`echo "${CLASS_C_SUBNET_IP}" | cut -d. -f2`
	CLASS_C_SUBNET_THIRD=`echo "${CLASS_C_SUBNET_IP}" | cut -d. -f3`
	CLASS_C_SUBNET="${CLASS_C_SUBNET_FIRST}.${CLASS_C_SUBNET_SECOND}.${CLASS_C_SUBNET_THIRD}"
}

test_valid_person_name ()
{

	TEST_CASE="${1}"

	VALID_PERSON_NAME="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_PERSON_NAME="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^[a-zA-Z0-9]*[a-zA-Z0-9\ ]*[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_PERSON_NAME="no"
		return 2
	fi

}

test_valid_email_address ()
{

	TEST_CASE="${1}"

	VALID_EMAIL_ADDRESS="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_EMAIL_ADDRESS="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^([a-zA-Z0-9]+([\.\_\-]?[a-zA-Z0-9]+)*)+([\+]([a-zA-Z0-9]+([\.\_\/\-]?[a-zA-Z0-9]+)*)+)?\@((([a-zA-Z0-9]+[\-])*[a-zA-Z0-9]+)+\.)+[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_EMAIL_ADDRESS="no"
		return 2
	fi

}

test_valid_inet_address ()
{

	TEST_CASE="${1}"

	VALID_INET_ADDRESS="yes"

	if [ "${TEST_CASE}" = "" ]
	then 
		VALID_INET_ADDRESS="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed "s/^[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}$//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_INET_ADDRESS="no"
		return 2
	fi

	NO_ZEROS_IN_FRONT=`echo "${TEST_CASE}" | sed "s/\.0[0-9]//" | sed "s/^0//"`
	if [ "${NO_ZEROS_IN_FRONT}" != "${TEST_CASE}" ]
	then
		VALID_INET_ADDRESS="no"
		return 3
	fi

	ONE=`echo "${TEST_CASE}" | cut -d. -f1`
	TWO=`echo "${TEST_CASE}" | cut -d. -f2`
	THREE=`echo "${TEST_CASE}" | cut -d. -f3`
	FOUR=`echo "${TEST_CASE}" | cut -d. -f4`

	if [ ${ONE} -gt 255 ] || [ ${TWO} -gt 255 ] || [ ${THREE} -gt 255 ] || [ ${FOUR} -gt 255 ]
	then
		VALID_INET_ADDRESS="no"
		return 4
	fi

}

test_valid_host_name ()
{

	TEST_CASE="${1}"

	VALID_HOST_NAME="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_HOST_NAME="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^([a-zA-Z0-9]+[\-])*[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_HOST_NAME="no"
		return 2
	fi

}

test_valid_fqhn ()
{

	TEST_CASE="${1}"

	VALID_FQHN="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_FQHN="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^((([a-zA-Z0-9]+[\-])*[a-zA-Z0-9]+)+\.)+[a-zA-Z0-9]+//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_FQHN="no"
		return 2
	fi

}

test_ping_host ()
{

	TEST_CASE="${1}"

	VALID_HOST_PING="yes"

	ping -c 3 ${TEST_CASE} > /dev/null 2>&1

	if [ ${?} -ne 0 ]
	then
		VALID_HOST_PING="no"
		return 1
	fi
}

test_valid_simple_url ()
{

	TEST_CASE="${1}"

	VALID_URL="yes"

	if [ "${TEST_CASE}" = "" ]
	then
		VALID_URL="no"
		return 1
	fi

	IS_SYNTAX_OK=`echo "${TEST_CASE}" | sed -r "s/^http[s]?\:\/\/[a-zA-Z0-9]+([\-]*[a-zA-Z0-9]+)*(\.[a-zA-Z0-9]+([\_\-]*[a-zA-Z0-9]+)*)*(:[0-9]+)?(\/[a-zA-Z0-9]+([\_\-]*[a-zA-Z0-9]+)*(\.[a-zA-Z0-9]+([\_\-]*[a-zA-Z0-9]+)*)*)*[\/]*//" | wc -L`
	if [ ${IS_SYNTAX_OK}  -ne 0 ]
	then
		VALID_URL="no"
		return 2
	fi

}

fetch_latest_self ()
{
	echo -e "\n${YELL}Fetching the latest version of this utility...${NRML}\n"
	cd /root
	fetch -d ${FETCH_LATEST_SELF_URL}${SCRIPT_NAME}
	if [ $? -ne 0 ]
	then
		question_yes_no "\nUnable to fetch the latest version of this utility.\nWould you like to continue anyway?"
		if [ "${ANSWER}" = "no" ]
		then
			exit 10
		fi
	else
		EXISTING_SHA256=`sha256 -q /usr/local/sbin/${SCRIPT_NAME}`
		FETCHED_SHA256=`sha256 -q ${SCRIPT_NAME}`
		if [ "${EXISTING_SHA256}" != "${FETCHED_SHA256}" ]
		then
			if [ ! -d /usr/local/sbin/ ]
			then
				mkdir -p /usr/local/sbin
			fi
			mv /root/${SCRIPT_NAME} /usr/local/sbin/
			chmod +x /usr/local/sbin/${SCRIPT_NAME}
			echo -e "\n${YELL}A newer version has now been installed.\nPlease rerun this utility.${NRML}\n"
			exit 11
		else
			echo -e "\n${YELL}The current version of this utility appears to be up to date.${NRML}\n"
			rm /root/${SCRIPT_NAME}
		fi
	fi

	cd -

}

check_repo_config ()
{

	# If REPO_URI is already set, then no need to proceed
	if [ "${REPO_URI}" != "" ]
	then
		return 0
	fi

	# Get the type of repo and, if applicable, the remote repo URI
	while [ "${REPO_URI}" = "" ]
	do
		echo -e "\n\n${LGRN}It appears that this is the first time you have used ${SCRIPT_NAME}${NRML}"
		echo -e "${LGRN}on this host.${NRML}\n"
		echo -e "${YELL}If this is your first host and you don't have a private remote git repo running${NRML}"
		echo -e "${YELL}yet. Then enter 'local' at the next prompt.${NRML}\n"

		pause_prompt 25

		# Prompt for the type of repo to use, remote or local.
		REPO_TYPE=""
		while [ "${REPO_TYPE}" = "" ]
		do
			echo -e "\n${LCYN}Would you like to use an existing remote git repo (recommended, if available),${NRML}"
			echo -e "${LCYN}or start with a local repo (not backed up remotely, no central management)?${NRML}"
			echo -e "${LCYN}(remote/local): ${NRML}\c"
			read REPO_TYPE_TEMP
			# Check input validation.
			if [ "${REPO_TYPE_TEMP}" = "remote" ] || [ "${REPO_TYPE_TEMP}" = "local" ]
			then
				REPO_TYPE="${REPO_TYPE_TEMP}"
			fi
		done 

		# If it does not exist, create the root path for FDo config files
		if [ ! -f ${FDO_CONFIG_ROOT} ]
		then
			mkdir -p ${FDO_CONFIG_ROOT}
		fi

		if [ "${REPO_TYPE}" = "local" ]
		then
			REPO_URI="local"
		else
			# Get the URI of the remote git repo
			REMOTE_REPO_URI=""
			while [ "${REMOTE_REPO_URI}" = "" ]
			do
				echo -e "\n${LCYN}Enter the remote git repo URI:${NRML}"
				read REMOTE_REPO_URI_TEMP
				# Allow use to change their mind about type of repo
				if [ "${REMOTE_REPO_URI_TEMP}" = "" ]
				then
					break
				fi
				# Test the input to see if it is a valid URI (URL)
				test_valid_simple_url "${REMOTE_REPO_URI_TEMP}"
				if [ "${VALID_URL}" = "yes" ]
				then
					question_yes_no "\nYou have entered '${REMOTE_REPO_URI_TEMP}'\nas the remote git repo URI.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						REMOTE_REPO_URI=${REMOTE_REPO_URI_TEMP}
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} remote git repo URI is invalid!\n"
				fi
			done
			REPO_URI="${REMOTE_REPO_URI}"
		fi

	done

	# Store the repo URI in it's FDo config file
	echo "${REPO_URI}" > ${FDO_CONFIG_ROOT}/fdo-server-repo.conf

	echo -e "\n${YELL}The local repo will be stored in the path '/${REPO_NAME}'.${NRML}\n"
	NO_DISPLAY_USAGE="yes"

}

backup_file ()
{
	FILE_PATH=${1}
	CHANGE_AGENT=${2}
	NOW=`date "+%Y-%m-%d_%H-%M-%S"`
	if [ -f ${FILE_PATH} ]
	then
		cp ${FILE_PATH} ${FILE_PATH}.${CHANGE_AGENT}_backup_${NOW}
	fi
}

install_file_tree ()
{

	## TODO: allow chown flags ( e.g. "user:group") to be passed and set on installed files.

	SOURCE_FILES_ROOT="${1}"
	DEST_FILES_ROOT="${2}"

	for SOURCE_FILE_PATH in `find "${SOURCE_FILES_ROOT}" -print | tail -n +2 | sort`
	do

		RELATIVE_DEST_FILE_PATH=`echo ${SOURCE_FILE_PATH} | sed "s|${SOURCE_FILES_ROOT}/||"`
		DEST_FILE_PATH="${DEST_FILES_ROOT}${RELATIVE_DEST_FILE_PATH}"

		if [ -d "${SOURCE_FILE_PATH}" ]
		then
			if [ ! -d "${DEST_FILE_PATH}" ]
			then
				mkdir "${DEST_FILE_PATH}"
			fi
			FILE_UID=`ls -ldn "${SOURCE_FILE_PATH}" | awk '{print $3}'`
			FILE_GID=`ls -ldn "${SOURCE_FILE_PATH}" | awk '{print $4}'`
			chown ${FILE_UID}:${FILE_GID} "${DEST_FILE_PATH}"
		else
			cp "${SOURCE_FILE_PATH}" "${DEST_FILE_PATH}"
		fi
		if [ $? -ne 0 ]
		then
			ERROR_COUNT=$((ERROR_COUNT + 1))
		fi
	done

}

compare_file_tree ()
{

	SOURCE_FILES_ROOT=${1}
	DEST_FILES_ROOT=${2}
	SILENT_MODE="no"

	if [ "${3}" = "--silent" ]
	then
		SILENT_MODE="yes"
	fi

	for SOURCE_FILE_PATH in `find ${SOURCE_FILES_ROOT} -print | tail -n +2 | sort`
	do

		RELATIVE_DEST_FILE_PATH=`echo ${SOURCE_FILE_PATH} | sed "s|${SOURCE_FILES_ROOT}/||"`
		DEST_FILE_PATH=${DEST_FILES_ROOT}${RELATIVE_DEST_FILE_PATH}

		if [ -d "${SOURCE_FILE_PATH}" ]
		then
			if [ ! -d ${DEST_FILE_PATH} ]
			then
				echo -e "${ORNG}WARNING:${NRML} The following directory ${LRED}DOES NOT EXIST${NRML}: ${DEST_FILE_PATH}"
			fi
		else
			if [ ! -f ${DEST_FILE_PATH} ]
			then
				echo -e "${ORNG}WARNING:${NRML} The following file      ${LRED}DOES NOT EXIST${NRML}: ${DEST_FILE_PATH}"
			else
				diff ${SOURCE_FILE_PATH} ${DEST_FILE_PATH} > /dev/null 2>&1
				if [ $? -eq 0 ]
				then
					echo -e "${LGRN}CHECKED${NRML}: The following file is ${LGRN}IN CHECK${NRML}:       ${DEST_FILE_PATH}"
				else
					echo -e "${ORNG}WARNING${NRML}: The following file is ${ORNG}OUT OF CHECK${NRML}:   ${DEST_FILE_PATH}"
					if [ "${SILENT_MODE}" = "no" ]
					then
						question_yes_no "Would you like to see the diff for ${DEST_FILE_PATH} ?"
						if [ "${ANSWER}" = "yes" ]
						then
							echo ""
							diff -u ${SOURCE_FILE_PATH} ${DEST_FILE_PATH}
							echo ""
						fi
					fi
				fi
			fi
		fi
	done

}

init_git_config ()
{

	CWD=`pwd`
	cd /${REPO_NAME}

	echo -e "\n\n${YELL}Initialising git config...${NRML}\n"

	git config user.name > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		while [ "${GIT_USER_NAME}" = "" ]
		do
			echo -e "\n${LCYN}Enter the git user name: ${NRML}\c"
			read GIT_USER_NAME_TEMP
			# Check that the git user name only contains letters numbers and spaces. 
			test_valid_person_name "${GIT_USER_NAME_TEMP}"
			if [ "${VALID_PERSON_NAME}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${GIT_USER_NAME_TEMP}' as the git user name.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					GIT_USER_NAME=${GIT_USER_NAME_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The name can not be '${GIT_USER_NAME}'."
				echo -e "       It must contain only letters, numbers and spaces.\n"
			fi
		done
		git config user.name "${GIT_USER_NAME}"
	fi

	git config user.email > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		while [ "${GIT_USER_EMAIL}" = "" ]
		do
			echo -e "\n${LCYN}Enter the git user email address: ${NRML}\c"
			read GIT_USER_EMAIL_TEMP
			# Check that the git user email only contains letters, numbers, periods, pluses, hyphens, underscores and one @.
			test_valid_email_address "${GIT_USER_EMAIL_TEMP}"
			if [ "${VALID_EMAIL_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${GIT_USER_EMAIL_TEMP}' as the git user email.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					GIT_USER_EMAIL=${GIT_USER_EMAIL_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} The email address can not be '${GIT_USER_EMAIL}'."
				echo -e "       It must be a valid email address.\n"
			fi
		done
		git config user.email "${GIT_USER_EMAIL}"
	fi

	git config push.default > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		git config push.default "simple"
	fi

	cd ${CWD}

}

init_local_repo ()
{

	CWD=`pwd`

	echo -e "\n\n${YELL}Initialising the local repo...${NRML}\n"

	# Move to '/' because this is where we keep the local repo
	cd /

	# Clone or update the git repository
	if [ -d "/${REPO_NAME}" ]
	then

		# The local repo already exists.

		cd /${REPO_NAME}

		if [ "${REPO_URI}" = "local" ]
		then
			echo -e "${YELL}The local git repo already exists.${NRML}"
			echo -e "${YELL}Updating from the upstream skeleton repo...${NRML}\n"
			# Temporarily reattach to public upstream skeleton repo, to pull latest changes.
			git remote add origin "${FDO_SERVER_SKELETON_REPO}"
			git fetch
			git branch --set-upstream-to=origin/master master
			git pull
			# Detach from the remote repo
			git remote remove origin
		else
			echo -e "${YELL}The local git repo already exists.${NRML}"
			echo -e "${YELL}Updating from the private remote repo...${NRML}\n"
			# Attach the local repo to the private remote repo.
			git remote add origin "${REPO_URI}"
			git fetch
			git branch --set-upstream-to=origin/master master
			# Update (pull) the latest changes from the private remote repo.
			git pull
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to update git repo."
				echo -e "       ${LRED}Aborting.${NRML}\n"
				exit 170
			fi
		fi

	else

		# The local repo does not exist yet.

		if [ "${REPO_URI}" = "local" ]
		then
			# Clone the upstream skeleton repo from github.
			echo -e "${YELL}Cloning the upstream skeleton git repo...${NRML}\n"
			git clone "${FDO_SERVER_SKELETON_REPO}"
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to clone upstream skeleton git repo."
				echo -e "       ${LRED}Aborting.${NRML}\n"
				exit 171
			fi
			# After we get the skeleton, detach from the upstream skeleton repo.
			cd /${REPO_NAME}
			git remote remove origin
		else
			# Clone our private remote git repo
			echo -e "${YELL}Cloning our private remote git repo...${NRML}\n"
			git clone ${REPO_URI}
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to clone private remote git repo."
				echo -e "       ${LRED}Aborting.${NRML}\n"
				exit 172
			fi
		fi

	fi

	echo -e "\n${LGRN}Finished initialising the local repo.${NRML}\n\n"

	cd ${CWD}

}

update_local_repo ()
{

	if [ ! -d "/${REPO_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the local git repo ('/${REPO_NAME}') does not exist!"
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 12
	fi

	if [ "${REPO_URI}" = "local" ]
	then
		echo -e "\n${YELL}No need to update local repo, there is no remote repo.${NRML}\n"
	else
		cd /${REPO_NAME}
		echo -e "\n${YELL}First, let's update the local git repo...${NRML}\n"
		git pull
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to update the local git repo."
			echo -e "       Please use 'git status' to find the cause.\n"
			exit 13
		fi
		cd -
	fi

}

install_scripts ()
{

	INSTALL_PATH=${1}
	ERROR_COUNT=0

	cd /${REPO_NAME}

	install_file_tree scripts ${INSTALL_PATH}

	if [ ${ERROR_COUNT} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to copy one or more scripts to target location:"
		echo -e "       ${ORNG}(${INSTALL_PATH})${NRML}\n"
	else
		echo -e "\n${LGRN}SUCCESS:${NRML} Installed all scripts successfully!"
		echo -e "         ${LGRN}(${INSTALL_PATH})${NRML}\n"
	fi

	cd -

}

add_script ()
{

	## TODO: test arguments

	SCRIPT_PATH="${1}"
	cd /${REPO_NAME}
	if [ "${SCRIPT_PATH}" = "" ] || [ ! -f ${SCRIPT_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The referenced file '${SCRIPT_PATH}' does not exist.\n"
		exit 14
	elif [ -f "scripts${SCRIPT_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file 'scripts${SCRIPT_PATH}' already exists."
		echo -e "       Please consider using '${SCRIPT_NAME} update-script' instead.\n"
		exit 15
	else
		cp ${SCRIPT_PATH} scripts${SCRIPT_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${SCRIPT_PATH}' to local git repo.\n"
			exit 16
		fi
		git add scripts${SCRIPT_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to add '${SCRIPT_PATH}' to local git repo.\n"
			exit 17
		fi
		git commit -m "Added new script; '${SCRIPT_PATH}'."
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${SCRIPT_PATH}' to local git repo."
			echo -e "       Please consider manually running 'git reset --hard' to previous commit.\n"
			exit 18
		fi
		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\nPushing changes to ${REPO_NAME} remote repo...\n"
			git push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			fi
		fi
		echo -e "\nOK, it seems we've successfully added the new script!\n" 
	fi

	cd -

}

update_script ()
{

	SCRIPT_PATH="${1}"
	cd /${REPO_NAME}
	if [ "${SCRIPT_PATH}" = "" ] || [ ! -f "${SCRIPT_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The referenced file '${SCRIPT_PATH}' does not exist.\n"
		exit 20
	elif [ ! -f "scripts${SCRIPT_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file 'scripts${SCRIPT_PATH}' does not exist.\n"
		exit 21
	else
		echo -e "\n${LCYN}Enter a short explanation of the changes made: ${NRML}\c"
		read CHANGE_MESSAGE
		cp ${SCRIPT_PATH} scripts${SCRIPT_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${SCRIPT_PATH}' to local git repo.\n"
			exit 22
		fi
		git add scripts${SCRIPT_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to update '${SCRIPT_PATH}' to local git repo.\n"
			exit 23
		fi
		git commit -m "Updated script; '${SCRIPT_PATH}': ${CHANGE_MESSAGE}."
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${SCRIPT_PATH}' to local git repo."
			echo -e "       Please consider manually running 'git reset --hard' to previous commit.\n"
			exit 24
		fi
		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\n${YELL}Pushing changes to ${REPO_NAME} remote repo...\n"
			git push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo.${NRML}"
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			fi
		fi
		echo -e "\n${LGRN}OK, it seems we've successfully added the new script!${NRML}\n" 
	fi

	cd -

}

install_configs ()
{

	CONFIG_REPO_ROOT=${1}
	INSTALL_PATH=${2}
	ERROR_COUNT=0

	cd /${REPO_NAME}

	if [ ! -d ${CONFIG_REPO_ROOT} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the repo config directory ('${CONFIG_REPO_ROOT}') does not exist!"
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 26
	fi 

	if [ ! -d ${INSTALL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the installation directory ('${INSTALL_PATH}') does not exist!"
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 27
	fi 

	install_file_tree ${CONFIG_REPO_ROOT} ${INSTALL_PATH}

	if [ ${ERROR_COUNT} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to copy one or more config files to target location. (${CONFIG_REPO_ROOT})\n"
	else
		echo -e "\nInstalled all config files successfully! (${CONFIG_REPO_ROOT})\n"
	fi

	cd -

}

check_configs ()
{

	CONFIG_REPO_ROOT=${1}
	INSTALL_PATH=${2}
	ERROR_COUNT=0

	cd /${REPO_NAME}

	if [ ! -d ${CONFIG_REPO_ROOT} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the repo config directory ('${CONFIG_REPO_ROOT}') does not exist!"
		echo -e "       ${LRED}Check aborted.${NRML}\n"
		return 1
	fi 

	if [ ! -d ${INSTALL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears the installation directory ('${INSTALL_PATH}') does not exist!"
		echo -e "       ${LRED}Check aborted.${NRML}\n"
		return 2
	fi 

	compare_file_tree ${CONFIG_REPO_ROOT} ${INSTALL_PATH} ${3}

	cd -

}

add_config ()
{

	CONFIG_FULL_PATH="${1}"

	cd /${REPO_NAME}

	echo "${CONFIG_FULL_PATH}" | grep -e "/jls/" > /dev/null 2>&1
	if [ $? -eq 0 ]
	then
		# config file belongs to a jail
		JAIL_NAME=`echo ${CONFIG_FULL_PATH}  | cut -d/ -f3`
		CONFIG_REPO_ROOT=configs/${JAIL_NAME}@${HOST_NAME}
		CONFIG_RELATIVE_PATH=`echo ${CONFIG_FULL_PATH} | sed "s|/jls/${JAIL_NAME}||"`
	else
		# config file belongs to the host
		CONFIG_REPO_ROOT=configs/${HOST_NAME}
		CONFIG_RELATIVE_PATH=${CONFIG_FULL_PATH}
	fi

	CONFIG_REPO_DIR=`dirname "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}"`
	if [ ! -d ${CONFIG_REPO_DIR} ]
	then
		mkdir -p ${CONFIG_REPO_DIR}
	fi

	if [ "${CONFIG_FULL_PATH}" = "" ] || [ ! -f ${CONFIG_FULL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The file '${CONFIG_FULL_PATH}' does not exist.\n"
		exit 30
	elif [ -f "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file '${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}' already exists."
		echo -e "       Please consider using '${SCRIPT_NAME} update-config' instead.\n"
		exit 31
	else
		cp ${CONFIG_FULL_PATH} ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}
		if [ $? -ne 0 ]
		then  
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${CONFIG_FULL_PATH}' to local git repo.\n"
			exit 32
		fi
		git add ${CONFIG_REPO_ROOT}${CONFIG_REALTIVE_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to add '${CONFIG_FULL_PATH}' to local git repo.\n"
			exit 33
		fi
		git commit -m "Added new config; '${CONFIG_FULL_PATH}' for ${HOST_NAME}."
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${CONFIG_FULL_PATH}' to local git repo."
			echo -e "       Please consider manually running 'git reset --hard' to previous commit.\n"
			exit 34
		fi
		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\nPushing changes to ${REPO_NAME} remote repo...\n"
			git push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			fi
		fi
		echo -e "\nOK, it seems we've successfully added the new config file!\n"
	fi

	cd -

}

update_config ()
{

	CONFIG_FULL_PATH="${1}"

	cd /${REPO_NAME}

	echo "${CONFIG_FULL_PATH}" | grep -e "/jls/" > /dev/null 2>&1
	if [ $? -eq 0 ]
	then
		# config file belongs to a jail
		JAIL_NAME=`echo ${CONFIG_FULL_PATH} | cut -d/ -f3`
		CONFIG_REPO_ROOT=configs/${JAIL_NAME}@${HOST_NAME}
		CONFIG_RELATIVE_PATH=`echo ${CONFIG_FULL_PATH} | sed "s|/jls/${JAIL_NAME}||"`
	else
		# config file belongs to the host
		CONFIG_REPO_ROOT=configs/${HOST_NAME}
		CONFIG_RELATIVE_PATH=${CONFIG_FULL_PATH}
	fi

	CONFIG_REPO_DIR=`dirname "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}"`
	if [ ! -d ${CONFIG_REPO_DIR} ]
	then
		mkdir -p ${CONFIG_REPO_DIR}
	fi

	if [ "${CONFIG_FULL_PATH}" = "" ] || [ ! -f ${CONFIG_FULL_PATH} ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The file '${CONFIG_FULL_PATH}' does not exist.\n"
		exit 40
	elif [ ! -f "${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The local repo file '${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}' does not exist.\n"
		exit 41
	else
		echo -e "\n${LCYN}Enter a short explanation of the changes made: ${NRML}\c"
		read CHANGE_MESSAGE
		cp ${CONFIG_FULL_PATH} ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}
		if [ $? -ne 0 ]
		then  
			echo -e "\n${LRED}ERROR:${NRML} Failed to copy '${CONFIG_FULL_PATH}' to local git repo.\n"
			exit 42
		fi
		git add ${CONFIG_REPO_ROOT}${CONFIG_RELATIVE_PATH}
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to update '${CONFIG_FULL_PATH}' to local git repo.\n"
			exit 43
		fi
		git commit -m "Updated config; '${CONFIG_FULL_PATH}' for ${HOST_NAME}: ${CHANGE_MESSAGE}."
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to commit '${CONFIG_FULL_PATH}' to local git repo."
			echo -e "       Please consider manually running 'git reset --hard' to previous commit.\n"
			exit 44
		fi
		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\nPushing changes to ${REPO_NAME} remote repo...\n"
			git push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			fi
		fi
		echo -e "\nOK, it seems we've successfully added the new config file!\n"
	fi

	cd -

}

connect_internet ()
{

	# Get available interfaces and the quantity thereof
	NET_IFACES=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "${NET_IFACES_IGNORED}" | cut -d: -f1`
	NUM_NET_IFACES=`echo ${NET_IFACES} | wc -w`
	if [ ${NUM_NET_IFACES} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No usable network interfaces found."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 150
	fi

	WAN_NET_IFACE=""
	USES_PPP=""
	USES_VLAN=""
	VLAN_ID=""
	PPP_AUTHNAME=""
	PPP_AUTHKEY=""
	IS_WAN_IFACE_DHCP=""
	WAN_IFACE_IP=""
	WAN_IFACE_NETMASK=""
	WAN_ROUTER_IP=""

	# Configure WAN interface.
	if [ ${NUM_NET_IFACES} -lt 2 ]
	then
		WAN_NET_IFACE=${NET_IFACES}
		echo -e "\n${YELL}Using ${WAN_NET_IFACE} as the WAN (internet facing) network interface,${NRML}"
		echo -e "${YELL}since it's all that's available.${NRML}\n"
	else
		SELECT_IFACE_PROMPT="Select the WAN network interface (internet facing):"
		while [ "${WAN_NET_IFACE}" = "" ]
		do
			dialog --no-items --no-cancel --menu "${SELECT_IFACE_PROMPT}" 12 40 10 ${NET_IFACES} 2> ${DIALOG_OUT_FILE}
			WAN_NET_IFACE_TEMP=`cat ${DIALOG_OUT_FILE}`
			question_yes_no "\n\nYou have selected '${WAN_NET_IFACE_TEMP}' as the WAN interface for this host.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				WAN_NET_IFACE="${WAN_NET_IFACE_TEMP}"
			fi
		done
	fi

	# Optionally configure PPP
	question_yes_no "\nDo you want to use PPPoE for the WAN interface (internet facing)?"
	USES_PPP=${ANSWER}
	if [ "${USES_PPP}" = "yes" ]
	then
		question_yes_no "\nDoes your PPPoE connection require a VLAN tag?"
		USES_VLAN=${ANSWER}
		if [ "${USES_VLAN}" = "yes" ]
		then
			while [ "${VLAN_ID}" = "" ]
			do
				echo -e "\n${LCYN}Enter VLAN ID (tag): ${NRML}\c"
				read VLAN_ID_TEMP
				# Check that the VLAN ID only contains numbers with a minimum of 1 characters.
				TEST=`echo "${VLAN_ID_TEMP}" | sed -r "s/^[0-9]+//" | wc -L`
				if [ ${TEST} -ne 0 ] || [ "${VLAN_ID_TEMP}" = "" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} The VLAN ID can not be '${VLAN_ID}'."
					echo -e "       It must be at least one character and only contain numbers.\n"
				else
					question_yes_no "\nYou have entered '${VLAN_ID_TEMP}' as the VLAN ID.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						VLAN_ID=${VLAN_ID_TEMP}
					fi
				fi
			done
		fi

		# Get PPP authname
		while [ "${PPP_AUTHNAME}" = "" ]
		do
			echo -e "\n${LCYN}Enter PPP authname (dialing username): ${NRML}\c"
			read PPP_AUTHNAME_TEMP1
			echo -e "${LCYN}Re-enter PPP authname                : ${NRML}\c"
			read PPP_AUTHNAME_TEMP2
			
			if [ "${PPP_AUTHNAME_TEMP1}" != "${PPP_AUTHNAME_TEMP2}" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Authname mismatch, try again!\n"
			elif [ "${PPP_AUTHNAME_TEMP1}" = "" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Authname not entered, try again!\n"
			else
				PPP_AUTHNAME=${PPP_AUTHNAME_TEMP1}
			fi
		done

		# Get PPP authkey
		while [ "${PPP_AUTHKEY}" = "" ]
		do
			echo -e "\n${LCYN}Enter PPP authkey (dialing password): ${NRML}\c"
			read PPP_AUTHKEY_TEMP1
			echo -e "${LCYN}Re-enter PPP authkey                : ${NRML}\c"
			read PPP_AUTHKEY_TEMP2
			
			if [ "${PPP_AUTHKEY_TEMP1}" != "${PPP_AUTHKEY_TEMP2}" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Authkey mismatch, try again!\n"
			elif [ "${PPP_AUTHKEY_TEMP1}" = "" ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Authkey not entered, try again!\n"
			else
				PPP_AUTHKEY=${PPP_AUTHKEY_TEMP1}
			fi
		done

		echo -e ""
	fi
	# END: configure PPP


	# Configure WAN interface IP address and subnet mask
	question_yes_no "\nDo you want to use DHCP for the WAN interface?"
	IS_WAN_IFACE_DHCP=${ANSWER}
	if [ "${IS_WAN_IFACE_DHCP}" = "no" ]
	then
		# Set up static IP and netmask for WAN interface
		while [ "${WAN_IFACE_IP}" = "" ]
		do
			echo -e "\n${LCYN}Enter static IP for WAN interface: ${NRML}\c"
			read WAN_IFACE_IP_TEMP
			test_valid_inet_address "${WAN_IFACE_IP_TEMP}"
			if [ "${VALID_INET_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${WAN_IFACE_IP_TEMP}' as the WAN interface IP address.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_IFACE_IP=${WAN_IFACE_IP_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} IP address is invalid!\n"
			fi
		done

		while [ "${WAN_IFACE_NETMASK}" = "" ] && [ "${USES_PPP}" != "yes" ]
		do
			echo -e "\n${LCYN}Enter netmask for WAN interface: ${NRML}\c"
			read WAN_IFACE_NETMASK_TEMP
			test_valid_inet_address "${WAN_IFACE_NETMASK_TEMP}"
			if [ "${VALID_INET_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${WAN_IFACE_NETMASK_TEMP}' as the WAN interface netmask.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_IFACE_NETMASK=${WAN_IFACE_NETMASK_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} Subnet mask is invalid!\n"
			fi
		done

		# Set default router
		while [ "${WAN_ROUTER_IP}" = "" ]
		do
			echo -e "\n${LCYN}Enter the default router IP address for this host: ${NRML}\c"
			read WAN_ROUTER_IP_TEMP
			test_valid_inet_address "${WAN_ROUTER_IP_TEMP}"
			if [ "${VALID_INET_ADDRESS}" = "yes" ]
			then
				question_yes_no "\nYou have entered '${WAN_ROUTER_IP_TEMP}' as the default router.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_ROUTER_IP=${WAN_ROUTER_IP_TEMP}
				fi
			else
				echo -e "\n${LRED}ERROR:${NRML} Default router IP address is invalid!\n"
			fi
		done
	fi
	# END: if IS_WAN_IFACE_DHCP = no


	# Stop services that may interfere with a simple internet connection
	echo -e "\n${YELL}Stopping unwanted network services...${NRML}\n"
	service natd onestop > /dev/null 2>&1
	service pflog onestop > /dev/null 2>&1
	service pf onestop > /dev/null 2>&1
	service ipfw onestop > /dev/null 2>&1
	service ipfilter onestop > /dev/null 2>&1
	service ppp onestop > /dev/null 2>&1
	pkill ppp

	sleep 10

	# Destroy all existing interfaces
	echo -e "\n${YELL}Destroying existing interfaces...${NRML}\n"
	NET_IFACES_TO_DESTROY=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "^lo0" | cut -d: -f1`
	for IFACE_TO_DESTROY in ${NET_IFACES_TO_DESTROY}
	do
		ifconfig ${IFACE_TO_DESTROY} down delete > /dev/null 2>&1
		ifconfig ${IFACE_TO_DESTROY} destroy > /dev/null 2>&1
	done

	# Flush routing table
	echo -e "\n${YELL}Flushing routing table...${NRML}\n"
	route flush > /dev/null 2>&1

	# Backup and replace resolv.conf with a generic working copy
	backup_file /etc/resolv.conf connect-internet
	echo "nameserver 8.8.8.8" > /etc/resolv.conf

	# Setup interface and routing
	echo -e "\n${YELL}Setup WAN interface and routing...${NRML}\n"
	ifconfig ${WAN_NET_IFACE} up

	if [ "${USES_PPP}" = "yes" ]
	then
		backup_file /etc/ppp/ppp.conf connect-internet
		echo "default:" > /etc/ppp/ppp.conf
		echo " set log Phase Chat LCP IPCP CCP tun command" >> /etc/ppp/ppp.conf
		echo " ident user-ppp VERSION" >> /etc/ppp/ppp.conf
		echo " disable iface-alias" >> /etc/ppp/ppp.conf
		echo " iface clear" >> /etc/ppp/ppp.conf
		if [ "${USES_VLAN}" = "yes" ]
		then
			ifconfig ${WAN_NET_IFACE}.${VLAN_ID} create vlan ${VLAN_ID} vlandev ${WAN_NET_IFACE} up
			echo " set device PPPoE:${WAN_NET_IFACE}_${VLAN_ID}" >> /etc/ppp/ppp.conf
		else
			echo " set device PPPoE:${WAN_NET_IFACE}" >> /etc/ppp/ppp.conf
		fi
		echo " set authname ${PPP_AUTHNAME}" >> /etc/ppp/ppp.conf
		echo " set authkey ${PPP_AUTHKEY}" >> /etc/ppp/ppp.conf
		echo " set dial" >> /etc/ppp/ppp.conf
		echo " set timeout 0" >> /etc/ppp/ppp.conf
		echo " set lqrperiod 30" >> /etc/ppp/ppp.conf
		echo " enable lqr echo" >> /etc/ppp/ppp.conf
		echo " set redial 15 0" >> /etc/ppp/ppp.conf
		echo " set reconnect 5 0" >> /etc/ppp/ppp.conf
		echo " set login" >> /etc/ppp/ppp.conf
		if [ "${IS_WAN_IFACE_DHCP}" = "yes"  ]
		then
			echo " set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255 0.0.0.0" >> /etc/ppp/ppp.conf
		else
			echo " set ifaddr ${WAN_IFACE_IP}/0 ${WAN_ROUTER_IP}/0 255.255.255.255 0.0.0.0" >> /etc/ppp/ppp.conf
		fi
		echo " add default HISADDR" >> /etc/ppp/ppp.conf
		ppp -ddial
	else
		if [ "${IS_WAN_IFACE_DHCP}" = "yes" ]
		then
			pkill dhclient > /dev/null 2>&1
			backup_file /etc/resolv.conf connect-internet
			dhclient ${WAN_NET_IFACE}
			if [ ${?} -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} DHCP failed on ${WAN_NET_IFACE}!\n"
				exit 152
			fi
		else
			ifconfig ${WAN_NET_IFACE} inet ${WAN_IFACE_IP} netmask ${WAN_IFACE_NETMASK} up
			route add default ${WAN_ROUTER_IP} > /dev/null 2>&1
		fi
	fi

	IS_IP_WORKING="no"
	WAIT_CYCLES=0

	while [ "${IS_IP_WORKING}" = "no" ] && [ ${WAIT_CYCLES} -lt 10 ]
	do
		# Sleep for 10 seconds for connection to establish
		echo -e "\n${YELL}Waiting for 10 seconds for connection to establish...${NRML}\n"
		sleep 10

		# Test internet connection
		ping -c 3 8.8.8.8 > /dev/null 2>&1
		if [ ${?} -eq 0 ]
		then
			IS_IP_WORKING="yes"
		fi

		WAIT_CYCLES=$(( ${WAIT_CYCLES} + 1 ))
	done

	if [ "${IS_IP_WORKING}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} IP connection failed! Unable to ping 8.8.8.8.\n"
		exit 153
	fi

	IS_DNS_WORKING="no"
	WAIT_CYCLES=0

	while [ "${IS_DNS_WORKING}" = "no" ] && [ ${WAIT_CYCLES} -lt 3 ]
	do

		if [ ${WAIT_CYCLES} -ne 0 ]
		then
			# Sleep for 10 seconds for DNS to establish
			echo -e "\n${YELL}Waiting for 10 seconds for DNS to establish...${NRML}\n"
			sleep 10
		fi

		# Test DNS
		host google.com > /dev/null 2>&1
		if [ ${?} -eq 0 ]
		then
			IS_DNS_WORKING="yes"
		fi
		
		WAIT_CYCLES=$(( ${WAIT_CYCLES} + 1 ))
	done
			
	if [ "${IS_DNS_WORKING}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} internet DNS failed! Unable to lookup google.com.\n"
		exit 154
	fi

	echo -e "\n${LGRN}Successfully connected to the internet!${NRML}\n"

	# END: configure WAN interface

}

new_host_cleanup ()
{
	rm -rf configs/${HOST_NAME}
	exit 50
}

new_host ()
{

	trap 'new_host_cleanup' HUP INT QUIT KILL TERM

	# NOTE: we have to assume we only have base userland at this point. No local repo either.

	HOST_NAME=${1}
	DOMAIN_NAME=${2}

	# Check that user has supplied a hostname and domain name.
	if [ $# -lt 2 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Not enough arguments supplied.\n"
		usage
		exit 51
	fi

	test_valid_host_name "${HOST_NAME}"
	if [ "${VALID_HOST_NAME}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The hostname can not be '${HOST_NAME}'."
		echo -e "       It must only contain letters, numbers and hyphens."
		echo -e "       It must not begin or end with a hyphen.\n"
		exit 53
	fi

	# Check that the domain name is valid.
	test_valid_fqhn  "${DOMAIN_NAME}"
	if [ "${VALID_FQHN}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The domain name can not be '${DOMAIN_NAME}'."
		echo -e "       It must only contain letters, numbers, periods and hyphens."
		echo -e "       It must not begin or end with a hyphen or a period.\n"
		exit 54
	fi

	# Update pkgng repositories
	echo -e "\n${YELL}First we need to update pkg (pkgng) repositories...${NRML}\n"
	pkg update
	if [ $? -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to update pkg (pkgng) repositories."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 55
	fi

	# Install essential packages
	echo -e "\n${YELL}Next we need to install some essential packages. Please accept when prompted...${NRML}\n"
	pause_prompt 8
	pkg install ${ESSENTIAL_PACKAGES}
	if [ $? -ne 0 ]
	then   
		echo -e "\n${LRED}ERROR:${NRML} Failed to install essential packages."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 56
	fi

	init_local_repo

	cd /${REPO_NAME}

	# Check that the hostname is not already taken.
	if [ -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The hostname can not be '${HOST_NAME}'!"
		echo -e "       It is already registered as a host in the repo.\n"
		exit 59
	fi

	# Copy new-host template configs to the repo
	mkdir configs/${HOST_NAME}
	install_file_tree config-templates/new-host configs/${HOST_NAME}/

	# Update hostname
	sed -i "" "s/^hostname\=.*/hostname\=${HOST_NAME}\.${DOMAIN_NAME}/" configs/${HOST_NAME}/etc/rc.conf
	hostname ${HOST_NAME}.${DOMAIN_NAME}

	# Get available interfaces and the quantity thereof
	NET_IFACES=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "${NET_IFACES_IGNORED}" | cut -d: -f1`
	NUM_NET_IFACES=`echo ${NET_IFACES} | wc -w`
	if [ ${NUM_NET_IFACES} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No usable network interfaces found!\n"
		echo -e "       ${LRED}Aborting.${NRML}\n"
		new_host_cleanup
		exit 60
	fi


	SERVER_TYPE=""
	while [ "${SERVER_TYPE}" = "" ]
	do
		dialog --no-cancel --menu "Select the type of server:" 12 80 10 \
					 "remote" "Remote Server (Datacenter/Cloud)" \
					 "primary_local" "Primary Local Server (Internet & LAN Gateway/NAT Router)" \
					 "auxiliary_local" "Auxiliary Local Server (LAN)" \
					 2> ${DIALOG_OUT_FILE}
		SERVER_TYPE_TEMP=`cat ${DIALOG_OUT_FILE}`
		echo -e "\n\n"
		question_yes_no "You have selected '${SERVER_TYPE_TEMP}' as the server type for this host.\nIs this correct?"
		if [ "${ANSWER}" = "yes" ]
		then
			SERVER_TYPE="${SERVER_TYPE_TEMP}"
		fi
	done

	WAN_NET_IFACE=""
	LAN_NET_IFACE=""
	USES_PPP=""
	USES_VLAN=""
	VLAN_ID=""
	PPP_AUTHNAME=""
	PPP_AUTHKEY=""
	IS_WAN_IFACE_DHCP=""
	IS_LAN_IFACE_DHCP=""
	WAN_IFACE_IP=""
	LAN_IFACE_IP=""
	WAN_IFACE_NETMASK=""
	LAN_IFACE_NETMASK=""
	WAN_ROUTER_IP=""

	case ${SERVER_TYPE} in
		remote)
			LAN_NET_IFACE="lo1"
			;;
		primary_local)
			if [ ${NUM_NET_IFACES} -lt 2 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Not enough network interfaces found (2 required)!"
				echo -e "       ${LRED}Aborting.${NRML}\n"
				new_host_cleanup
				exit 61
			fi
			;;
		auxiliary_local)
			WAN_NET_IFACE="NULL"
			;;
	esac

	# Configure WAN interface (if required).
	if [ "${WAN_NET_IFACE}" != "NULL" ]
	then
		if [ ${NUM_NET_IFACES} -lt 2 ]
		then
			WAN_NET_IFACE=${NET_IFACES}
			echo -e "\n${YELL}Using ${WAN_NET_IFACE} as the WAN (internet facing) network interface,${NRML}"
			echo -e "${YELL}since it's all that's available.${NRML}\n"
		else
			SELECT_IFACE_PROMPT="Select the WAN network interface (internet facing):"
			while [ "${WAN_NET_IFACE}" = "" ]
			do
				dialog --no-items --no-cancel --menu "${SELECT_IFACE_PROMPT}" 12 40 10 ${NET_IFACES} 2> ${DIALOG_OUT_FILE}
				WAN_NET_IFACE_TEMP=`cat ${DIALOG_OUT_FILE}`
				question_yes_no "\n\nYou have selected '${WAN_NET_IFACE_TEMP}' as the WAN interface for this host.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					WAN_NET_IFACE="${WAN_NET_IFACE_TEMP}"
				fi
			done
		fi

		sed -i "" "s/WAN_NET_IFACE/${WAN_NET_IFACE}/g" configs/${HOST_NAME}/etc/rc.conf

		# Optionally configure PPP
		question_yes_no "\nDo you want to use PPPoE for the WAN interface (internet facing)?"
		USES_PPP=${ANSWER}
		if [ "${USES_PPP}" = "yes" ]
		then
			question_yes_no "\nDoes your PPPoE connection require a VLAN tag?"
			USES_VLAN=${ANSWER}
			if [ "${USES_VLAN}" = "yes" ]
			then
				while [ "${VLAN_ID}" = "" ]
				do
					echo -e "\n${LCYN}Enter VLAN ID (tag): ${NRML}\c"
					read VLAN_ID_TEMP
					# Check that the VLAN ID only contains numbers with a minimum of 1 characters.
					TEST=`echo "${VLAN_ID_TEMP}" | sed -r "s/^[0-9]+//" | wc -L`
					if [ ${TEST} -ne 0 ] || [ "${VLAN_ID_TEMP}" = "" ]
					then
						echo -e "\n${LRED}ERROR:${NRML} The VLAN ID can not be '${VLAN_ID}'."
						echo -e "       It must be at least one character and only contain numbers.\n"
					else
						question_yes_no "\nYou have entered '${VLAN_ID_TEMP}' as the VLAN ID.\nIs this correct?"
						if [ "${ANSWER}" = "yes" ]
						then
							VLAN_ID=${VLAN_ID_TEMP}
						fi
					fi
				done
				sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"up\"\\${CARRIAGE_RETURN}ifconfig_${WAN_NET_IFACE}_${VLAN_ID}=\"up\"/" configs/${HOST_NAME}/etc/rc.conf
				sed -i "" "s/^#vlans_${WAN_NET_IFACE}=\"\"/vlans_${WAN_NET_IFACE}=\"${VLAN_ID}\"/" configs/${HOST_NAME}/etc/rc.conf
				sed -i "" "s/PPP_IFACE/${WAN_NET_IFACE}_${VLAN_ID}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			else
				sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"up\"/" configs/${HOST_NAME}/etc/rc.conf
				sed -i "" "s/PPP_IFACE/${WAN_NET_IFACE}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			fi
	
			# Get PPP authname
			while [ "${PPP_AUTHNAME}" = "" ]
			do
				echo -e "\n${LCYN}Enter PPP authname (dialing username): ${NRML}\c"
				read PPP_AUTHNAME_TEMP1
				echo -e "${LCYN}Re-enter PPP authname                : ${NRML}\c"
				read PPP_AUTHNAME_TEMP2
				
				if [ "${PPP_AUTHNAME_TEMP1}" != "${PPP_AUTHNAME_TEMP2}" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Authname mismatch, try again!\n"
				elif [ "${PPP_AUTHNAME_TEMP1}" = "" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Authname not entered, try again!\n"
				else
					PPP_AUTHNAME=${PPP_AUTHNAME_TEMP1}
				fi
			done

			# Get PPP authkey
			while [ "${PPP_AUTHKEY}" = "" ]
			do
				echo -e "\n${LCYN}Enter PPP authkey (dialing password): ${NRML}\c"
				read PPP_AUTHKEY_TEMP1
				echo -e "${LCYN}Re-enter PPP authkey                : ${NRML}\c"
				read PPP_AUTHKEY_TEMP2
				
				if [ "${PPP_AUTHKEY_TEMP1}" != "${PPP_AUTHKEY_TEMP2}" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Authkey mismatch, try again!\n"
				elif [ "${PPP_AUTHKEY_TEMP1}" = "" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} Authkey not entered, try again!\n"
				else
					PPP_AUTHKEY=${PPP_AUTHKEY_TEMP1}
				fi
			done

			echo -e ""
	
			sed -i "" "s/isp_username/${PPP_AUTHNAME}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			sed -i "" "s/isp_password/${PPP_AUTHKEY}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			sed -i "" "s/ppp_enable=\"NO\"/ppp_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
			sed -i "" "s/ppp_nat=\"NO\"/ppp_nat=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
			echo "tun0" > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/net_iface_wan.conf
		else
			echo "${WAN_NET_IFACE}" > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/net_iface_wan.conf
		fi
		# END: configure PPP


		# Configure WAN interface IP address and subnet mask
		question_yes_no "\nDo you want to use DHCP for the WAN interface?"
		IS_WAN_IFACE_DHCP=${ANSWER}
		if [ "${IS_WAN_IFACE_DHCP}" = "no" ]
		then
			# Set up static IP and netmask for WAN interface
			while [ "${WAN_IFACE_IP}" = "" ]
			do
				echo -e "\n${LCYN}Enter static IP for WAN interface: ${NRML}\c"
				read WAN_IFACE_IP_TEMP
				test_valid_inet_address "${WAN_IFACE_IP_TEMP}"
				if [ "${VALID_INET_ADDRESS}" = "yes" ]
				then
					get_class_c_subnet ${WAN_IFACE_IP_TEMP}
					get_class_b_subnet ${WAN_IFACE_IP_TEMP}
					WAN_SUBNET_C="${CLASS_C_SUBNET}"
					WAN_SUBNET_B="${CLASS_B_SUBNET}"
					if [ "${WAN_SUBNET_B}" = "${FDO_LAN_SUBNET_B}" ]
					then
						echo -e "\n${LRED}ERROR:${NRML} In a gateway configuration the WAN interface IP address must not be in"
						echo -e "       the 192.168.0.0/16 subnet!\n"
					else
						question_yes_no "\nYou have entered '${WAN_IFACE_IP_TEMP}' as the WAN interface IP address.\nIs this correct?"
						if [ "${ANSWER}" = "yes" ]
						then
							WAN_IFACE_IP=${WAN_IFACE_IP_TEMP}
						fi
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} IP address is invalid!\n"
				fi
			done

			while [ "${WAN_IFACE_NETMASK}" = "" ] && [ "${USES_PPP}" != "yes" ]
			do
				echo -e "\n${LCYN}Enter netmask for WAN interface: ${NRML}\c"
				read WAN_IFACE_NETMASK_TEMP
				test_valid_inet_address "${WAN_IFACE_NETMASK_TEMP}"
				if [ "${VALID_INET_ADDRESS}" = "yes" ]
				then
					question_yes_no "\nYou have entered '${WAN_IFACE_NETMASK_TEMP}' as the WAN interface netmask.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						WAN_IFACE_NETMASK=${WAN_IFACE_NETMASK_TEMP}
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} Subnet mask is invalid!\n"
				fi
			done

			# Set default router
			while [ "${WAN_ROUTER_IP}" = "" ]
			do
				echo -e "\n${LCYN}Enter the default router IP address for this host: ${NRML}\c"
				read WAN_ROUTER_IP_TEMP
				test_valid_inet_address "${WAN_ROUTER_IP_TEMP}"
				if [ "${VALID_INET_ADDRESS}" = "yes" ]
				then
					question_yes_no "\nYou have entered '${WAN_ROUTER_IP_TEMP}' as the default router.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						WAN_ROUTER_IP=${WAN_ROUTER_IP_TEMP}
					fi
				else
					echo -e "\n${LRED}ERROR:${NRML} Default router IP address is invalid!\n"
				fi
			done
	
			if [ "${USES_PPP}" = "yes" ]
			then
				sed -i "" "s|^ #set ifaddr .*| set ifaddr ${WAN_IFACE_IP}/0 ${WAN_ROUTER_IP}/0 255.255.255.255 0.0.0.0|" configs/${HOST_NAME}/etc/ppp/ppp.conf
			else
				sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"inet ${WAN_IFACE_IP} netmask ${WAN_IFACE_NETMASK}\"/" configs/${HOST_NAME}/etc/rc.conf
				sed -i "" "s/^#defaultrouter=\"\"/defaultrouter=\"${WAN_ROUTER_IP}\"/" configs/${HOST_NAME}/etc/rc.conf
			fi
		elif [ "${USES_PPP}" = "yes" ]
		then
			sed -i "" "s|^ #set ifaddr | set ifaddr |" configs/${HOST_NAME}/etc/ppp/ppp.conf
		else
			sed -i "" "s/^#ifconfig_${WAN_NET_IFACE}=\"\"/ifconfig_${WAN_NET_IFACE}=\"DHCP\"/" configs/${HOST_NAME}/etc/rc.conf
		fi
		# END: if IS_WAN_IFACE_DHCP = no

		sed -i "" "s/^gateway_enable\=.*/gateway_enable\=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf

	fi
	# END: configure WAN interface


	# Configure LAN interface
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		REMAINING_NET_IFACES=`ifconfig | grep "^[a-z].*[0-9].*:" | egrep -v "${NET_IFACES_IGNORED}|^${WAN_NET_IFACE}" | cut -d: -f1`
		NUM_REMAINING_NET_IFACES=`echo ${REMAINING_NET_IFACES} | wc -w`
		if [ ${NUM_REMAINING_NET_IFACES} -lt 2 ]
		then
			LAN_NET_IFACE=${REMAINING_NET_IFACES}
			echo -e "\n\n${YELL}Using ${LAN_NET_IFACE} as the LAN network interface,${NRML}"
			echo -e "${YELL}since it's all that's available.${NRML}\n"
		else
			SELECT_IFACE_PROMPT="Select the LAN network interface:"
			while [ "${LAN_NET_IFACE}" = "" ]
			do
				dialog --no-items --no-cancel --menu "${SELECT_IFACE_PROMPT}" 12 40 10 ${REMAINING_NET_IFACES} 2> ${DIALOG_OUT_FILE}
				LAN_NET_IFACE_TEMP=`cat ${DIALOG_OUT_FILE}`
				question_yes_no "\n\nYou have selected '${LAN_NET_IFACE_TEMP}' as the LAN interface for this host.\nIs this correct?"
				if [ "${ANSWER}" = "yes" ]
				then
					LAN_NET_IFACE="${LAN_NET_IFACE_TEMP}"
				fi
			done
		fi
	fi

	if [ "${SERVER_TYPE}" = "remote" ]
	then
		sed -i "" "s/^#cloned_interfaces=\"\"/cloned_interfaces=\"${LAN_NET_IFACE}\"/" configs/${HOST_NAME}/etc/rc.conf
	fi
	echo "${LAN_NET_IFACE}" > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/net_iface_lan.conf
	sed -i "" "s/LAN_NET_IFACE/${LAN_NET_IFACE}/g" configs/${HOST_NAME}/etc/rc.conf

	LAN_SUBNET_B="${FDO_LAN_SUBNET_B}"
	LAN_SUBNET_C="${SERVICES_LAN_SUBNET_C}"
	LAN_IFACE_NETMASK="${FDO_LAN_SUBNET_NETMASK}"

	if [ "${WAN_NET_IFACE}" != "NULL" ]
	then
		# Assuming this host is a remote or primary_local type server
		LAN_IFACE_IP="${LAN_SUBNET_C}.1"
		sed -i "" "s/^#ifconfig_${LAN_NET_IFACE}=\"\"/ifconfig_${LAN_NET_IFACE}=\"inet ${LAN_IFACE_IP} netmask ${LAN_IFACE_NETMASK}\"/" configs/${HOST_NAME}/etc/rc.conf
		if [ "${USES_PPP}" = "yes" ]
		then
			sed -i "" "s/^ #nat/ nat/" configs/${HOST_NAME}/etc/ppp/ppp.conf
			sed -i "" "s/LAN_SUBNET_C/${LAN_SUBNET_C}/" configs/${HOST_NAME}/etc/ppp/ppp.conf
		fi
	else
		# Assuming this host is an aux_local type server
		question_yes_no "\nDo you want to use DHCP for the LAN interface?"
		IS_LAN_IFACE_DHCP=${ANSWER}
		if [ "${IS_LAN_IFACE_DHCP}" = "no" ]
		then
			# Set up static IP and netmask for LAN interface
			SELECT_IP_LIST=""
			CURRENT_IP=${AUX_LOCAL_SERVER_IP_MIN}
			while [ ${CURRENT_IP} -le ${AUX_LOCAL_SERVER_IP_MAX} ]
			do
				SELECT_IP_LIST="${SELECT_IP_LIST} ${CURRENT_IP} ${LAN_SUBNET_C}.${CURRENT_IP}"
				CURRENT_IP=$(( ${CURRENT_IP} + 1 ))
			done

			while [ "${LAN_IFACE_IP}" = "" ]
			do
				dialog --no-cancel --menu "Select LAN interface IP:" 18 40 16 ${SELECT_IP_LIST} 2> ${DIALOG_OUT_FILE}
				IP_LAST_DIGIT=`cat ${DIALOG_OUT_FILE}`
				LAN_IFACE_IP_TEMP="${LAN_SUBNET_C}.${IP_LAST_DIGIT}"
				if [ "${LAN_IFACE_IP_TEMP}" = "" ]
				then
					echo -e "\n${LRED}ERROR:${NRML} No IP address selected! Try again.\n"
					pause_prompt 5
				else
					question_yes_no "\n\nYou have selected '${LAN_IFACE_IP_TEMP}' as the LAN interface IP address.\nIs this correct?"
					if [ "${ANSWER}" = "yes" ]
					then
						LAN_IFACE_IP=${LAN_IFACE_IP_TEMP}
					fi
				fi
			done
			sed -i "" "s/^#ifconfig_${LAN_NET_IFACE}=\"\"/ifconfig_${LAN_NET_IFACE}=\"inet ${LAN_IFACE_IP} netmask ${LAN_IFACE_NETMASK}\"/" configs/${HOST_NAME}/etc/rc.conf
		else
			sed -i "" "s/^#ifconfig_${LAN_NET_IFACE}=\"\"/ifconfig_${LAN_NET_IFACE}=\"DHCP\"/" configs/${HOST_NAME}/etc/rc.conf
		fi
		# END: if IS_LAN_IFACE_DHCP = no
	fi
	# END: if WAN_NET_IFACE != NULL

	sed -i "" "s/LAN_SUBNET_C/${LAN_SUBNET_C}/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/LAN_SUBNET_C/${LAN_SUBNET_C}/" configs/${HOST_NAME}/etc/jail.conf

	# END: configure LAN interface

	# Configure firewall / NAT router
	if [ "${WAN_NET_IFACE}" != "NULL" ] && [ "${USES_PPP}" = "no" ]
	then
		sed -i "" "s|WAN_NET_IFACE|${WAN_NET_IFACE}|" configs/${HOST_NAME}/etc/pf.conf
		sed -i "" "s|LAN_NET_IFACE|${LAN_NET_IFACE}|" configs/${HOST_NAME}/etc/pf.conf
		sed -i "" "s|LAN_SUBNET_C|${LAN_SUBNET_C}|" configs/${HOST_NAME}/etc/pf.conf
		sed -i "" "s|^pf_enable=.*|pf_enable\=\"YES\"|" configs/${HOST_NAME}/etc/rc.conf
		sed -i "" "s|^pflog_enable=.*|pflog_enable\=\"YES\"|" configs/${HOST_NAME}/etc/rc.conf
	fi

	# Additional network configuration
	sed -i "" "s|LAN_SUBNET_C|${LAN_SUBNET_C}|" configs/${HOST_NAME}/etc/resolv.conf.static
	sed -i "" "s|DOMAIN_NAME|${DOMAIN_NAME}|" configs/${HOST_NAME}/etc/resolv.conf.static

	# Ask if we want to continue past point of no return
	question_yes_no "\nWe will now make permanent changes to the new host system,\nwould you like to continue?"
	if [ "${ANSWER}" = "no" ]
	then
		new_host_cleanup
	fi

	#### POINT OF NO RETURN ####

	# Backup existing core system conf files
	backup_file /etc/rc.conf new-host
	backup_file /etc/sysctl.conf new-host
	backup_file /boot/loader.conf new-host

	# Install new-host configs to the system so that FDO user has a useful profile
	install_file_tree configs/${HOST_NAME} /

	# Set password for toor user
	echo -e "\n${LCYN}Next we need to set a password for the toor user (interactive root shell${NRML}"
	echo -e "${LCYN}account). This can be the same as the root user password.${NRML}\n"
	passwd toor

	# Set login shell for toor user
	chsh -s bash toor

	# Add arbitrary ssh login user
	echo -e "\n\n${LCYN}Next we will add an arbitrary user so that we can login via SSH.${NRML}"
	echo -e "${LCYN}It's recommended NOT to use an easy to guess username like admin or your own${NRML}"
	echo -e "${LCYN}name.${NRML}"

	# Get valid login name
	FDO_USERNAME=""
	while [ "${FDO_USERNAME}" = "" ]
	do  
		echo -e "\n${LCYN}Enter login account username: ${NRML}\c"
		read FDO_USERNAME_TEMP
		# Check that the username only contains letters, numbers, periods and underscores with a minimum of 3 characters.
		TEST=`echo "${FDO_USERNAME_TEMP}" | sed -r "s/^[a-z0-9][a-z0-9\.\-]+[a-z0-9]//" | wc -L`
		if [ ${TEST} -ne 0 ] || [ "${FDO_USERNAME_TEMP}" = "" ]
		then 
			echo -e "\n${LRED}ERROR:${NRML} The username can not be '${FDO_USERNAME_TEMP}'."
			echo -e "       It must be at least three characters and only contain lower case"
			echo -e "       letters, numbers, periods and hyphens.\n"
		else
			question_yes_no "\nYou have entered '${FDO_USERNAME_TEMP}' as the login account username.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				FDO_USERNAME=${FDO_USERNAME_TEMP}
			fi
		fi
	done

	pw useradd ${FDO_USERNAME} -m -s /usr/local/bin/bash -c "FDo login user" -G "operator wheel"
	echo -e "\n${LCYN}And now give this user account a password.${NRML}\n"
	passwd ${FDO_USERNAME}

	echo -e "\n${LGRN}You should now be able to switch user from ${FDO_USERNAME}${NRML}"
	echo -e "${LGRN}to toor using the command:${NRML}"
	echo -e "${LBLU}root${NRML}\n"

	# Store FDO_USERNAME in it's config file
	echo ${FDO_USERNAME} > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/fdo_username.conf

	# Timezone setup
	echo -e "\n${LCYN}Let's perform the hosts timezone setup. Press enter to proceed... ${NRML}\c"
	read ENTER_PRESSED
	tzsetup
	TZ_AVAILABLE=`cat /usr/share/zoneinfo/zone.tab | egrep -v "^#" | awk '{print $3}' | sort`
	TZ=""
	while [ "${TZ}" = "" ]
	do
		dialog --no-cancel --no-items --menu "Select timezone for the hosts TZ environment variable:" 30 60 26 ${TZ_AVAILABLE} 2> ${DIALOG_OUT_FILE}
		TZ_TEMP=`cat ${DIALOG_OUT_FILE}`
		question_yes_no "\n\nYou have selected '${TZ_TEMP}' for the TZ for this host.\nIs this correct?"
		if [ "${ANSWER}" = "yes" ]
		then
			TZ="${TZ_TEMP}"
		fi
	done
	sed -i "" "s|HOST_TIMEZONE|${TZ}|" configs/${HOST_NAME}/etc/profile

	# Set correct time/date from ntp.org
	echo -e "\n${YELL}Setting correct time and date from ntp.org...${NRML}\n"
	service ntpd stop
	ntpdate pool.ntp.org
	service ntpd start

	# Locale setup
	question_yes_no "\n\nWould you like to configure the locale for this host?"
	if [ "${ANSWER}" = "yes" ]
	then
		LOCALE_AVAILABLE=`ls -1 /usr/share/locale/ | egrep -v "^UTF-8" | sort`
		LOCALE=""
		while [ "${LOCALE}" = "" ]
		do
			dialog --no-cancel --no-items --menu "Select the locale for the host:" 30 60 26 ${LOCALE_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			LOCALE_TEMP=`cat ${DIALOG_OUT_FILE}`
			echo -e "\n\n"
			question_yes_no "You have selected '${LOCALE_TEMP}' for the locale for this host.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				LOCALE="${LOCALE_TEMP}"
			fi
		done
		sed -i "" "s|HOST_LOCALE|${LOCALE}|" configs/${HOST_NAME}/etc/profile
	fi

	#### CONFIG PROFILE FINISHED ####

	# Install scripts to the system
	install_scripts /

	# Install final new-host configs to the system
	install_file_tree configs/${HOST_NAME} /

	# Create ssl certs directory
	mkdir -p /usr/local/etc/ssl/certs

	# If not using DHCP, symlink resolv.conf.static to resolv.conf
	if [ "${IS_PRIMARY_IFACE_DHCP}" = "no" ] || [ "${USES_PPP}" = "yes" ]
	then
		backup_file /etc/resolv.conf new-host
		rm /etc/resolv.conf
		ln -s /etc/resolv.conf.static /etc/resolv.conf
	fi

	# Initialise the git config, so we can commit and push without warnings.
	init_git_config

	# Remove the .gitignore from the local repo configs directory (if it exists)
	git rm configs/.gitignore 2> /dev/null

	# Commit this hosts config to the local repo 
	echo -e "\n${YELL}Committing this hosts config to the local repo...${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Adding new host; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\nPushing changes to the private remote repo...\n"
		git push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished setting up the new host:${NRML}"
	echo -e "${LGRN}'${HOST_NAME}'.${NRML}\n\n" 
	question_yes_no "Would you like to reboot now for new settings to take full effect?\n[RECOMMENDED]"
	if [ "${ANSWER}" = "yes" ]
	then
		reboot
	fi

	cd -

} ## END: new_host()

patch_host()
{

	PATCH_HOST_NEEDS_REBOOT="no"

	echo -e "\n${YELL}We are now going to perform a 'freebsd-update fetch' operation.${NRML}"
	echo -e "${YELL}It may take a while...${NRML}\n"

	PAGER=cat freebsd-update fetch > /tmp/fdo-freebsd-update.output
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The 'freebsd-update fetch' operation failed!"
		echo -e "       Check for network related issues."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		rm /tmp/fdo-freebsd-update.output
		return 1
	fi

	cat /tmp/fdo-freebsd-update.output | tail -1 | grep "^No updates needed" > /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LGRN}This host does not need patches installed, it's already fully patched.${NRML}\n"
		rm /tmp/fdo-freebsd-update.output
		return 0
	fi

	echo -e "\n${YELL}And now let's perform a 'freebsd-update install' operation...${NRML}\n"

	PAGER=cat freebsd-update install > /tmp/fdo-freebsd-update.output
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The 'freebsd-update install' operation failed!"
		echo -e "       Check FDo documentation for help."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		rm /tmp/fdo-freebsd-update.output
		return 2
	fi

	echo -e "\n${LGRN}This host has been successfully patched!${NRML}\n"

	cat /tmp/fdo-freebsd-update.output | tail -2 | grep "Please reboot" > /dev/null
	if [ ${?} -eq 0 ]
	then
		PATCH_HOST_NEEDS_REBOOT="yes"
		echo -e "\n${ORGN}ATTENTION: Please reboot when appropriate to pick up changes in patched kernel.${NRML}\n"
	fi

	rm /tmp/fdo-freebsd-update.output
	return 0

}

setup_vnc_desktop()
{

	cd /${REPO_NAME}

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo!"
		echo -e "       Please use the 'new-host' subcommand first.\n"
		exit 70
	fi

	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use 'update-config' to keep the repo up-to-date.\n"
		exit 71
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Update pkgng repositories
	echo -e "\n${YELL}Next we need to update pkg (pkgng) repositories...${NRML}\n"
	pkg update
	if [ $? -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Failed to update pkg (pkgng) repositories."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 72
	fi

	# Install desktop / vnc packages
	echo -e "\n${YELL}Next we need to install some required packages. Please accept when prompted...${NRML}\n"
	pause_prompt 8
	pkg install ${VNC_DESKTOP_PACKAGES}
	if [ $? -ne 0 ]
	then   
		echo -e "\n${LRED}ERROR:${NRML} Failed to install required packages."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 73
	fi

	FDO_USERNAME=`cat configs/${HOST_NAME}${FDO_CONFIG_ROOT}/fdo_username.conf`

	# Copy setup-vnc-desktop template configs to this hosts' repo profile
	install_file_tree config-templates/setup-vnc-desktop configs/${HOST_NAME}/

	# Rename FDO_USERNAME home folder in host config profile
	if [ -d configs/${HOST_NAME}/home/${FDO_USERNAME} ]
	then
		rm -rf configs/${HOST_NAME}/home/${FDO_USERNAME}
	fi
	mv configs/${HOST_NAME}/home/FDO_USERNAME configs/${HOST_NAME}/home/${FDO_USERNAME}

	# Correctively change ownership of FDo users' profile config files
	chown -R ${FDO_USERNAME}:${FDO_USERNAME} configs/${HOST_NAME}/home/${FDO_USERNAME}

	# Enable DBUS in rc.conf
	sed -i "" "s/dbus_enable=\"NO\"/dbus_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf

	# Substitute FDo username in rc.local and rc.shutdown.local
	sed -i "" "s|FDO_USERNAME|${FDO_USERNAME}|" configs/${HOST_NAME}/etc/rc.local
	sed -i "" "s|FDO_USERNAME|${FDO_USERNAME}|" configs/${HOST_NAME}/etc/rc.shutdown.local

	# Uncomment VNC related lines in rc.local and rc.shutdown.local
	sed -i "" "s/^#//" configs/${HOST_NAME}/etc/rc.local
	sed -i "" "s/^#//" configs/${HOST_NAME}/etc/rc.shutdown.local

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	# Start dbus
	service dbus start

	# Run vncserver for the first time, will prompt for vnc passwords
	sh /etc/rc.local

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n" 
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'setup-vnc-desktop'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\nPushing changes to ${REPO_NAME} remote repo...\n"
		git push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	DEFAULT_ROUTE_IP=`route -nv get 1 | tail -1 | awk '{print $5}'`

	echo -e "\n${LGRN}Congratulations! We have now finished setting up a VNC accessible desktop.${NRML}"
	echo -e "\n${YELL}To access the VNC session use SSVNC Viewer with SSH enabled ${NRML}"
	echo -e "${YELL}and the following URI:${NRML}"
	echo -e "${LGRN}${FDO_USERNAME}@${DEFAULT_ROUTE_IP}:10${NRML}\n\n"

	cd -

}

init_hotdesking ()
{

	cd /${REPO_NAME}

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'new-host' subcommand first.\n"
		exit 80
	fi

	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use 'update-config' to keep the repo up-to-date.\n"
		exit 81
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Get pool name to use for hotdesk users' home folders.
	POOL_NAME=""
	POOLS_AVAILABLE=`zpool list | tail -n +2 | awk '{print $1}'`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n"
		exit 82
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool for hotdesk user home folders:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			question_yes_no "You have selected '${POOL_NAME_TEMP}' to store the hotdesk users home folders.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				POOL_NAME="${POOL_NAME_TEMP}"
			fi
		done
	fi

	# Warn if hotdesk user home base dataset already exists.
	zfs list ${POOL_NAME}/fdo-hotdesk-home 2> /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The ZFS dataset '${POOL_NAME}/fdo-hotdesk-home' already exists!\n"
	fi

	# Get the NIS domainname.
	NIS_DOMAIN_NAME=""
	while [ "${NIS_DOMAIN_NAME}" = "" ]
	do
		echo -e "\n${LCYN}Enter NIS domain name (need not be the same as the host): ${NRML}\c"
		read NIS_DOMAIN_NAME_TEMP
		# Check that the nisdomainname is a valid domain name.
		test_valid_fqhn "${NIS_DOMAIN_NAME_TEMP}"
		if [ "${VALID_FQHN}" = "yes" ]
		then
			question_yes_no "\nYou have entered '${NIS_DOMAIN_NAME_TEMP}' as the NIS domain name.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				NIS_DOMAIN_NAME=${NIS_DOMAIN_NAME_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} The NIS domain name can not be '${NIS_DOMAIN_NAME_TEMP}'."
			echo -e "       It must only contain letters, numbers, periods and hyphens."
			echo -e "       It must not begin or end with a hyphen or a period.\n"
		fi
	done

	# Get IP to use for NIS service.
	NIS_SERVER_IP=""
	SERVICE_IP_AVAILABLE=`ifconfig | egrep "inet.*netmask" | egrep -v "netmask 0xffffffff" | awk '{print $2}' | egrep "${SERVICES_LAN_SUBNET_C}"`
	NUM_SERVICE_IP=`echo ${SERVICE_IP_AVAILABLE} | wc -w`
	if [ ${NUM_SERVICE_IP} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No LAN service IPs found. Unable to proceed.\n"
		exit 83
	fi
	if [ ${NUM_SERVICE_IP} -lt 2 ]
	then
		NIS_SERVER_IP=${SERVICE_IP_AVAILABLE}
	else
		while [ "${NIS_SERVER_IP}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select IP address to use for NIS server:" 12 60 10 ${SERVICE_IP_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			NIS_SERVER_IP_TEMP=`cat ${DIALOG_OUT_FILE}`
			question_yes_no "You have selected '${NIS_SERVER_IP_TEMP}' to use for the NIS server.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				NIS_SERVER_IP="${NIS_SERVER_IP_TEMP}"
			fi
		done
	fi

	sed -i "" "s/mountd_enable=\"NO\"/mountd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/nfs_server_enable=\"NO\"/nfs_server_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/nis_client_enable=\"NO\"/nis_client_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/nis_server_enable=\"NO\"/nis_server_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/nis_yppasswdd_enable=\"NO\"/nis_yppasswdd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpc_lockd_enable=\"NO\"/rpc_lockd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpc_statd_enable=\"NO\"/rpc_statd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpcbind_enable=\"NO\"/rpcbind_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/POOL_NAME/${POOL_NAME}/" configs/${HOST_NAME}${FDO_CONFIG_ROOT}/hotdesk-home-zfs-name.conf
	sed -i "" "s/NIS_DOMAIN_NAME/${NIS_DOMAIN_NAME}/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/NIS_SERVER_IP/${NIS_SERVER_IP}/" configs/${HOST_NAME}/etc/rc.conf

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	question_yes "\nNow we need to restart the network to register the NIS domain name.\nCan we proceed?" 

	/etc/netstart

	question_yes_no "\n\nWould you like to allow non-FreeBSD NIS clients to connect to this server?"
	if [ "${ANSWER}" = "yes" ]
	then
		 sed -i "" "s/^#UNSECURE/UNSECURE/" /var/yp/Makefile
	fi

	touch /etc/exports
	touch /var/yp/master.passwd
	chmod 600 /var/yp/master.passwd

	# Start rpcbind required by ypinit
	service rpcbind start

	echo -e "\n${YELL}Now we will initialise the NIS maps. Follow the steps below:${NRML}\n"
	echo -e "${YELL}1.) Enter 'y' when prompted to '... quit on non fatal errors'.${NRML}"
	echo -e "${YELL}2.) Enter 'y' if prompted to '... destroy the existing${NRML}"
	echo -e "${YELL}    /var/yp/${NIS_DOMAIN_NAME}'.${NRML}"
	echo -e "${YELL}3.) Press 'Ctrl' and 'D' keys together when prompted for 'next host to add'.${NRML}"
	echo -e "${YELL}4.) Enter 'y' when prompted to confirm NIS server list is correct.${NRML}\n"

	ypinit -m ${NIS_DOMAIN_NAME}

	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The NIS maps failed to initialise."
		echo -e "       Consult FDo documentation for help.\n"
		exit 84
	fi

	# Start the NIS/NFS services
	service ypserv start
	service ypbind start
	service lockd start
	service nfsd start

	# Let's add a group called users to support a Slackware based workstation / client
	pw group add users -g 100 > /dev/null 2>&1

	# Create the ZFS dataset for the root of hotdesk users home folders
	zfs create -o mountpoint=/fdo-hotdesk-home ${POOL_NAME}/fdo-hotdesk-home

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'init-hotdesking'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\nPushing changes to ${REPO_NAME} remote repo...\n"
		git push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished setting up NIS/NFS hotdesking.${NRML}"
	echo -e "\n${LGRN}To register hotdesk users on this server; use the command:${NRML}"
	echo -e "${LBLU}fdo-hotdesk-add-user${NRML}\n"

	echo -e "${YELL}Hotdesk user home folder pool name: ${POOL_NAME}${NRML}"
	echo -e "${YELL}Hotdesk user home folder dataset: ${POOL_NAME}/fdo-hotdesk-home${NRML}"
	echo -e "${YELL}NIS domain name: ${NIS_DOMAIN_NAME}${NRML}"
	echo -e "${YELL}NIS server IP address: ${NIS_SERVER_IP}${NRML}\n"

	cd -

}

init_jails ()
{
	cd /${REPO_NAME}
 
	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'new-host' subcommand first.\n"
		exit 90
	fi
 
	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the subcommand 'update-config' to keep the repo up-to-date.\n"
		exit 91
	fi
 
	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"
 
	# Get the LAN interface that the jails will run on
	LAN_NET_IFACE=""
	NET_IFACES=`ifconfig | egrep "^[a-z].*[0-9]" | cut -d: -f1`
	for IFACE in ${NET_IFACES}
	do
		ifconfig ${IFACE} | egrep "inet.*netmask" | egrep -v "netmask 0xffffffff" | awk '{print $2}' | egrep "${SERVICES_LAN_SUBNET_C}" > /dev/null
		if [ $? -eq 0 ]
		then
			LAN_NET_IFACE=${IFACE}
		fi
	done

	# Exit if the LAN subnet interface was not found
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No LAN interface providing the ${SERVICES_LAN_SUBNET_C} subnet was found."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 92
	fi

	# Get pool name to use for base of jails.
	POOL_NAME=""
	POOLS_AVAILABLE=`zpool list | tail -n +2 | awk '{print $1}'`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n"
		exit 93
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool to use for jails datasets:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			question_yes_no "You have selected '${POOL_NAME_TEMP}' to store the service jails.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				POOL_NAME="${POOL_NAME_TEMP}"
			fi
		done
	fi
 
	# Get host IPs to use for sshd.
	HOST_IP_ADDRESSES=`ifconfig | egrep "inet.*netmask" | egrep -v "netmask 0xffffffff" | awk '{print $2}' | egrep "${SERVICES_LAN_SUBNET_C}"`
	NUM_HOST_IP=`echo ${HOST_IP_ADDRESSES} | wc -w`
	if [ ${NUM_HOST_IP} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No usable host IPs found. Unable to proceed.\n"
		exit 94
	fi

	# Warn if jail base dataset already exists.
	zfs list ${POOL_NAME}/jails 2> /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The ZFS dataset '${POOL_NAME}/jails' already exists!\n"
	fi

	patch_host
	PATCH_HOST_RETURN_CODE=${?}
	if [ ${PATCH_HOST_RETURN_CODE} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Updating of host to latest patch level failed."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 95
	fi

	# Get version strings
	FREEBSD_VERSION_STRING=`freebsd-version`
	FREEBSD_VERSION=`freebsd-version | cut -d- -f1` 
	FREEBSD_MAJOR_VERSION=`echo ${FREEBSD_VERSION} | cut -d. -f1`
	FREEBSD_CADENCE=`freebsd-version | cut -d- -f2` 
	FREEBSD_PATCH_LEVEL=`freebsd-version | cut -d- -f3`

	SUM_EXIT_CODE=0

	# Download relevant base system tarballs
	echo -e "\n${YELL}Downloading FreeBSD base system tarballs...${NRML}\n"
	fetch -o /tmp/jail-base.txz ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/${FREEBSD_VERSION}-${FREEBSD_CADENCE}/base.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	fetch -o /tmp/jail-lib32.txz ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/${FREEBSD_VERSION}-${FREEBSD_CADENCE}/lib32.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	fetch -o /tmp/jail-src.txz ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/${FREEBSD_VERSION}-${FREEBSD_CADENCE}/src.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	if [ ${SUM_EXIT_CODE} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to download the base system tarballs."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 96
	fi

	# Create ZFS datasets for service jail template
	echo -e "\n${YELL}Creating ZFS datasets for template jail...${NRML}\n"
	zfs create -o mountpoint=/jls ${POOL_NAME}/jails
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	zfs create ${POOL_NAME}/jails/template
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	# Mount the datasets if they are not already
	zfs mount | grep "${POOL_NAME}/jails "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${POOL_NAME}/jails
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	zfs mount | grep "${POOL_NAME}/jails/template "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${POOL_NAME}/jails/template
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	# Install base system tarballs into the template jail directory
	echo -e "\n${YELL}Extracting FreeBSD base system tarballs into template jail...${NRML}\n"
	tar -JxC /jls/template/ -f /tmp/jail-base.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	tar -JxC /jls/template/ -f /tmp/jail-lib32.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	tar -JxC /jls/template/ -f /tmp/jail-src.txz
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	if [ ${SUM_EXIT_CODE} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Something went wrong in preparing the template jail."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 97
	fi

	echo "${POOL_NAME}" > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/jails_pool.conf
	sed -i "" "s/jail_enable=\"NO\"/jail_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/^#template/template/" configs/${HOST_NAME}/etc/jail.conf

	# Only run sshd on LAN host (not jail) IPs
	for IP_ADDRESS in ${HOST_IP_ADDRESSES}
	do
		## TODO: decide which of these IP addresses (if more than one) to use in port forwarding rule. 
		##       Currently it will use the first in the list.
		sed -i "" "s/HOST_LAN_IP/${IP_ADDRESS}/" configs/${HOST_NAME}/etc/pf.conf
		sed -i "" "s/#\(rdr on .*host_sshd.*\)/\1/" configs/${HOST_NAME}/etc/pf.conf
		echo "ListenAddress ${IP_ADDRESS}" >> configs/${HOST_NAME}/etc/ssh/sshd_config
	done

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	# Install init-jails configs to the template jail
	install_file_tree config-templates/init-jails /jls/template/

	# Create nullfs mountpoint for hosts ssl certs
	mkdir -p /jls/template/usr/local/etc/ssl/certs

	# Copy certain host specific config files to the template jail
	HOST_CONFIG_FILES=`find config-templates/init-jails -type f | sed "s|^config-templates/init-jails/||"`
	for CONFIG_FILE in ${HOST_CONFIG_FILES}
	do
		FILE_CONTENTS=`cat config-templates/init-jails/${CONFIG_FILE}`
		if [ "${FILE_CONTENTS}" = "COPY_FROM_HOST" ]
		then
			cp /${CONFIG_FILE} /jls/template/${CONFIG_FILE}
		elif [ "${FILE_CONTENTS}" = "COPY_STATIC_FROM_HOST" ]
		then
			STATIC_CONFIG_FILE="${CONFIG_FILE}.static"
			cp /${STATIC_CONFIG_FILE} /jls/template/${CONFIG_FILE}
		fi
	done

	# Run tzsetup for the jail
	tzsetup -s -C /jls/template `cat /var/db/zoneinfo`

	ifconfig ${LAN_NET_IFACE} inet ${SERVICES_LAN_SUBNET_C}.11 netmask 255.255.255.255 alias
	service pf reload
	service sshd reload
	service jail start template

	echo -e "\n${YELL}Updating template jail to latest patch release...${NRML}\n"
	PAGER=cat freebsd-update -b /jls/template fetch > /tmp/fdo-freebsd-update.output
	PAGER=cat freebsd-update -b /jls/template install > /tmp/fdo-freebsd-update.output

	service jail restart template

	# Install essential package into the template jail
	echo -e "\n${YELL}Next we need to install some essential packages into the template jail.${NRML}"
	echo -e "${YELL}Please accept when prompted...${NRML}\n"
	pause_prompt 8
	pkg -j template update
	pkg -j template install ${ESSENTIAL_JAIL_PACKAGES}

	# Stop the template jail now that we're done making the template
	service jail stop template

	# Disable template jail from running again
	sed -i "" "s/^template/#template/" configs/${HOST_NAME}/etc/jail.conf
	ifconfig ${LAN_NET_IFACE} inet ${SERVICES_LAN_SUBNET_C}.11 netmask 255.255.255.255 -alias

	# Install updated host configs to the system (after disabling template jail)
	install_file_tree configs/${HOST_NAME} /

	# Take snapshot of the template for use in create-jail*
	zfs snapshot ${POOL_NAME}/jails/template@${FREEBSD_VERSION_STRING}

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'init-jails'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\nPushing changes to ${REPO_NAME} remote repo...\n"
		git push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished initialising the jails subsystem.${NRML}"
	echo -e "\n${LGRN}To create jails, use the command:${NRML}"
	echo -e "${LBLU}${SCRIPT_NAME} create-jail${NRML}\n"

	cd -

}

init_remote_desktops ()
{

	## TODO: provision rdscreensized

	cd /${REPO_NAME}
 
	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'new-host' subcommand first.\n"
		exit 100
	fi
 
	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use 'update-config' to keep the repo up-to-date.\n"
		exit 101
	fi
 
	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"
 
	SUM_EXIT_CODE=0

	echo -e "\n${YELL}First we need to install some required packages.${NRML}"
	echo -e "${YELL}Please accept when prompted...${NRML}\n"
	pause_prompt 8
	pkg update
	pkg install ${REMOTE_DESKTOP_PACKAGES}

	kldstat | grep vboxdrv.ko > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		kldload vboxdrv 2> /dev/null
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	kldstat | grep vboxnetflt.ko > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		kldload vboxnetflt 2> /dev/null
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	kldstat | grep vboxnetadp.ko > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		kldload vboxnetadp 2> /dev/null
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	if [ ${SUM_EXIT_CODE} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} A problem was encountered when loading the VirtualBox kernel modules."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 102
	fi

	# Get pool name to use for base of remote desktops datasets.
	POOL_NAME=""
	POOLS_AVAILABLE=`zpool list | tail -n +2 | awk '{print $1}'`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n"
		exit 103
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool to use for remote desktop datasets:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			question_yes_no "You have selected '${POOL_NAME_TEMP}' to store the remote desktops.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				POOL_NAME="${POOL_NAME_TEMP}"
			fi
		done
	fi
 
	# Create ZFS datasets for remote desktop template
	echo -e "\n${YELL}Creating ZFS datasets for the template ...${NRML}\n"
	zfs list ${POOL_NAME}/vboxguests > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		zfs create -o mountpoint=/vboxguests ${POOL_NAME}/vboxguests
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	zfs list ${POOL_NAME}/vboxguests/RemoteDesktop > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		zfs create ${POOL_NAME}/vboxguests/RemoteDesktop
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	# Mount the datasets if they are not already
	zfs mount | grep "${POOL_NAME}/vboxguests "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${POOL_NAME}/vboxguests
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))
	zfs mount | grep "${POOL_NAME}/vboxguests/RemoteDesktop "
	if [ ${?} -ne 0 ]
	then
		zfs mount ${POOL_NAME}/vboxguests/RemoteDesktop
	fi
	SUM_EXIT_CODE=$(( ${SUM_EXIT_CODE} + ${?} ))

	if [ ${SUM_EXIT_CODE} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} A problem was encountered when creating the ZFS datasets for the remote"
		echo -e "       desktops."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 104
	fi

	sed -i "" "s/vboxnet_enable=\"NO\"/vboxnet_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/^#\(add path .* vboxusers\)/\1/" configs/${HOST_NAME}/etc/devfs.rules
	echo "${POOL_NAME}" > configs/${HOST_NAME}${FDO_CONFIG_ROOT}/remote_desktops_pool.conf

	# Copy init-remote-desktops template configs to this hosts' repo profile
	install_file_tree config-templates/init-remote-desktops configs/${HOST_NAME}/

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	# Add remote desktop template user
	pw useradd RemoteDesktop -m -s /usr/local/bin/bash -c "Remote Desktop Template User" -d /vboxguests/RemoteDesktop -G "operator vboxusers"

	# Change ownership of the template VM base directory to the template user
	chown -R RemoteDesktop:RemoteDesktop /vboxguests/RemoteDesktop

	# Restart devfs
	service devfs restart

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'init-remote-desktops'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\nPushing changes to ${REPO_NAME} remote repo...\n"
		git push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished initialising the remote desktop subsystem.${NRML}"
	echo -e "\n${LGRN}To create a remote desktop template, use the command:${NRML}"
	echo -e "${LBLU}${SCRIPT_NAME} create-remote-desktop-template${NRML}\n"

	cd -

}

create_remote_desktop_template ()
{

	RD_TEMPLATE_NAME=${1}
	if [ "${RD_TEMPLATE_NAME}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No template name provided."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 110
	fi

	cd /${REPO_NAME}

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then  
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'new-host' subcommand first.\n"
		exit 111
	fi

	POOL_NAME=`cat ${FDO_CONFIG_ROOT}/remote_desktops_pool.conf 2> /dev/null`
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the remote desktops subsytem is not initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} init-remote-desktops${NRML}\n"
		exit 112
	fi

	zfs list ${POOL_NAME}/vboxguests/RemoteDesktop@${RD_TEMPLATE_NAME} > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The template '${RD_TEMPLATE_NAME}' already exists.\n"
		echo -e "       To delete it use the command:"
		echo -e "       ${LBLU}zfs destroy ${POOL_NAME}/vboxguests/RemoteDesktop@${RD_TEMPLATE_NAME}${NRML}"
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 113
	fi

	# Get the LAN interface that the virtualbox guest will use for bridged networking
	LAN_NET_IFACE=""
	NET_IFACES=`ifconfig | egrep "^[a-z].*[0-9]" | cut -d: -f1`
	for IFACE in ${NET_IFACES}
	do
		ifconfig ${IFACE} | egrep "inet.*netmask" | egrep -v "netmask 0xffffffff" | awk '{print $2}' | egrep "${SERVICES_LAN_SUBNET_C}" > /dev/null
		if [ $? -eq 0 ]
		then
			LAN_NET_IFACE=${IFACE}
		fi
	done

	# Exit if the LAN subnet interface was not found
	if [ "${LAN_NET_IFACE}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No LAN interface providing the ${SERVICES_LAN_SUBNET_C} subnet was found."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 114
	fi

	# Get IP to use for VNC.
	VNC_SERVER_IP=""
	SERVICE_IP_AVAILABLE=`ifconfig | egrep "inet.*netmask" | egrep -v "netmask 0xffffffff" | awk '{print $2}' | egrep "${SERVICES_LAN_SUBNET_C}"`
	NUM_SERVICE_IP=`echo ${SERVICE_IP_AVAILABLE} | wc -w`
	if [ ${NUM_SERVICE_IP} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No LAN service IPs found. Unable to proceed.\n"
		exit 115
	fi
	if [ ${NUM_SERVICE_IP} -lt 2 ]
	then
		VNC_SERVER_IP=${SERVICE_IP_AVAILABLE}
	else
		while [ "${VNC_SERVER_IP}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select IP address for VNC access:" 12 60 10 ${SERVICE_IP_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			VNC_SERVER_IP_TEMP=`cat ${DIALOG_OUT_FILE}`
			question_yes_no "You have selected '${VNC_SERVER_IP_TEMP}' to use for the VNC session.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				VNC_SERVER_IP="${VNC_SERVER_IP_TEMP}"
			fi
		done
	fi

	question_yes_no "Is this template for a 64bit OS?"
	IS_64BIT="${ANSWER}"


	# Get the installer ISO path
	LOOP=1
	while [ ${LOOP} -eq 1 ]
	do
		# Ask for installer ISO file
		dialog --title "Select OS installer ISO" --no-cancel --fselect / 20 80 2> ${DIALOG_OUT_FILE}
		OS_INSTALLER_ISO=`cat ${DIALOG_OUT_FILE}`
		if [ -f "${OS_INSTALLER_ISO}" ]
		then
			file ${OS_INSTALLER_ISO} | grep "ISO 9660" > /dev/null
			if [ ${?} -eq 0 ]
			then
				LOOP=0
			else
				echo -e "\n\n${ORNG}WARNING:${NRML} File selected is not an ISO!\n"
				pause_prompt 5
			fi
		else
			echo -e "\n\n${ORNG}WARNING:${NRML} No file selected!\n"
			pause_prompt 5
		fi
	done

	echo -e "\n"

	su - RemoteDesktop -c "VBoxManage list vms" | grep RemoteDesktop > /dev/null
	if [ ${?} -eq 0 ]
	then
		su - RemoteDesktop -c "VBoxManage list runningvms" | awk '{print $1}' | egrep "RemoteDesktop" > /dev/null
		if [ ${?} -eq 0 ]
		then
			service RemoteDesktop onestop
		fi
		su - RemoteDesktop -c "VBoxManage unregistervm RemoteDesktop --delete"
	fi
	su - RemoteDesktop -c "VBoxManage createvm --name 'RemoteDesktop' --register"
	su - RemoteDesktop -c "VBoxManage modifyvm RemoteDesktop --memory 2048 --acpi on --ioapic on --boot1 dvd --vram 64 --accelerate2dvideo on"
	su - RemoteDesktop -c "VBoxManage modifyvm RemoteDesktop --nic1 bridged --bridgeadapter1 ${LAN_NET_IFACE} --cableconnected1 on"
	su - RemoteDesktop -c "VBoxManage modifyvm 'RemoteDesktop' --vrde on --vrdeport 6000 --vrdeaddress ${VNC_SERVER_IP} --vrdeproperty VNCPassword=vncpassword"
	su - RemoteDesktop -c "VBoxManage createhd --filename /vboxguests/RemoteDesktop/VirtualBox\ VMs/RemoteDesktop/RemoteDesktop.vdi --size 10000"

	question_yes_no "\n\nAre you installing a Windows XP (or older) guest OS?"
	if [ "${ANSWER}" = "yes" ]
	then
		su - RemoteDesktop -c "VBoxManage storagectl 'RemoteDesktop' --name 'IDE Controller' --add ide"
		su - RemoteDesktop -c "VBoxManage storageattach 'RemoteDesktop' --storagectl 'IDE Controller' --port 0 --device 0 --type hdd --medium /vboxguests/RemoteDesktop/VirtualBox\ VMs/RemoteDesktop/RemoteDesktop.vdi"
		su - RemoteDesktop -c "VBoxManage storageattach 'RemoteDesktop' --storagectl 'IDE Controller' --port 1 --device 0 --type dvddrive --medium ${OS_INSTALLER_ISO}"
	else
		su - RemoteDesktop -c "VBoxManage storagectl 'RemoteDesktop' --name 'SATA Controller' --add sata"
		su - RemoteDesktop -c "VBoxManage storageattach 'RemoteDesktop' --storagectl 'SATA Controller' --port 0 --device 0 --type hdd --medium /vboxguests/RemoteDesktop/VirtualBox\ VMs/RemoteDesktop/RemoteDesktop.vdi"
		su - RemoteDesktop -c "VBoxManage storageattach 'RemoteDesktop' --storagectl 'SATA Controller' --port 1 --device 0 --type dvddrive --medium ${OS_INSTALLER_ISO}"
	fi

	if [ "${IS_64BIT}" = "yes" ]
	then
		su - RemoteDesktop -c "VBoxManage modifyvm 'RemoteDesktop' --longmode on"
	else
		su - RemoteDesktop -c "VBoxManage modifyvm 'RemoteDesktop' --longmode off"
	fi

	# Start template for first time
	touch /var/log/RemoteDesktop.log
	chown RemoteDesktop:RemoteDesktop /var/log/RemoteDesktop.log
	service RemoteDesktop onestart

	# Inform user that next step is to login via VNC to the template and perfrom the installation / configuration.
	echo -e "\n${YELL}The guest OS should now be running in the remote desktop template.${NRML}"
	echo -e "${YELL}The OS installer ISO should also be attached and booted into ${NRML}"
	echo -e "${YELL}the installation environment.${NRML}"
	echo -e "${YELL}You should now install the guest OS and reboot it when finished.${NRML}\n"
	echo -e "${YELL}Connect to the remote desktop template using a VNC viewer ${NRML}"
	echo -e "${YELL}(e.g. SSVNC) using the following:${NRML}\n"
	echo -e "${LGRN}VNC URI:      ${VNC_SERVER_IP}:6000${NRML}"
	echo -e "${LGRN}VNC Password: vncpassword\n\n"
	
	# Pause for user to finish configuring template
	question_yes "\n\nAre you finished installing the guest OS for this remote desktop template?" 

	# Optionally install guest additions
	question_yes_no "\n\nWould you like to install guest additions into the remote desktop template? [RECOMMENDED]" 
	if [ "${ANSWER}" = "yes" ]
	then
		VBOX_VERSION=`pkg info virtualbox-ose | head -1 | cut -d_ -f 1 | cut -d- -f3`
		GUEST_ADDITIONS_ISO="VBoxGuestAdditions_${VBOX_VERSION}.iso"

		echo -e "\n${YELL}Downloading guest additions DVD ISO...${NRML}\n"
		fetch -o /vboxguests/${GUEST_ADDITIONS_ISO} http://download.virtualbox.org/virtualbox/${VBOX_VERSION}/${GUEST_ADDITIONS_ISO}
		su - RemoteDesktop -c "VBoxManage storageattach 'RemoteDesktop' --storagectl 'IDE Controller' --port 1 --device 0 --type dvddrive --medium /vboxguests/${GUEST_ADDITIONS_ISO}"

		echo -e "\n${YELL}The guest additions DVD ISO should now be available in the guest OS.${NRML}"
		echo -e "${YELL}Please install the guest additions and reboot the guest OS.${NRML}\n\n"
		question_yes "Finished installing guest additions and rebooted the guest OS?" 
		su - RemoteDesktop -c "VBoxManage controlvm 'RemoteDesktop' setvideomodehint 1272 700 32"
	fi

	echo -e "\n${YELL}Now you may configure and install software as necessary into the ${NRML}"
	echo -e "${YELL}remote desktop template. Reboot when done...${NRML}\n"

	STILL_CONFIGURING="yes"
	while [ "${STILL_CONFIGURING}" = "yes" ]
	do
		LOOP=1
		while [ ${LOOP} = 1 ]
			do
			echo -e "${LCYN}Would you like to insert a DVD ISO into the remote desktop template ${NRML}"
			echo -e "${LCYN}or have you finished setting up the template (insert/finish): ${NRML}\c"
			read ANSWER
			if [ "${ANSWER}" = "insert" ] || [ "${ANSWER}" = "finish" ]
			then
				LOOP=0
			fi
			echo -e ""
		done
	
		if [ "${ANSWER}" = "finish" ]
		then
			STILL_CONFIGURING="no"
		else
			# Ask for DVD ISO file to insert
			dialog --fselect / 20 80 2> ${DIALOG_OUT_FILE}
			SELECTED_FILE=`cat ${DIALOG_OUT_FILE}`
			if [ -f "${SELECTED_FILE}" ]
			then
				file ${SELECTED_FILE} | grep "ISO 9660" > /dev/null
				if [ ${?} -eq 0 ]
				then
					su - RemoteDesktop -c "VBoxManage storageattach 'RemoteDesktop' --storagectl 'IDE Controller' --port 1 --device 0 --type dvddrive --medium ${SELECTED_FILE}"
					echo -e "\n\n${YELL}The selected ISO should now be inserted and available in the guest OS.${NRML}\n"
				else
					echo -e "\n\n${ORNG}WARNING:${NRML} File selected is not an ISO!\n"
					pause_prompt 5
				fi
			else
				echo -e "\n\n${ORNG}WARNING:${NRML} No file selected!\n"
				pause_prompt 5
			fi
		fi
	done

	service RemoteDesktop onestop
	zfs snapshot ${POOL_NAME}/vboxguests/RemoteDesktop@${RD_TEMPLATE_NAME}

	echo -e "\n${LGRN}Congratulations! The remote desktop template '${RD_TEMPLATE_NAME}'${NRML}"
	echo -e "${LGRN}is ready to use.${NRML}\n"
	echo -e "${LGRN}To setup a new remote desktop, use the command:${NRML}"
	echo -e "${LBLU}${SCRIPT_NAME} create-remote-desktop-instance${NRML}\n"

	cd -

}

create_remote_desktop_instance ()
{

	if [ ${#} -ne 3 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Incorrect number of arguments supplied."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		usage
		exit 120
	fi

	RD_TEMPLATE_NAME=$1
	VNC_OFFSET=$2
	VNC_PASSWORD=$3
	RD_NAME=${RD_TEMPLATE_NAME}${VNC_OFFSET}

	cd /${REPO_NAME}

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'new-host' subcommand first.\n"
		exit 121
	fi

	# Check that the remote desktops subsystem is initialised and therefore we know the pool name.
	POOL_NAME=`cat ${FDO_CONFIG_ROOT}/remote_desktops_pool.conf 2> /dev/null`
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the remote desktops subsystem is not initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} init-remote-desktops${NRML}\n"
		exit 122
	fi

	# Check that the template exists
	zfs list ${POOL_NAME}/vboxguests/RemoteDesktop@${RD_TEMPLATE_NAME} > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The remote desktop template '${RD_TEMPLATE_NAME}' does not exist!"
		echo -e "       Please use the 'create-remote-desktop-template' subcommand first.\n"
		exit 123
	fi

	# Check that the VNC offset is not already in use
	PREVIOUS_IFS=${IFS}
	IFS=${CARRIAGE_RETURN}
	VBOX_CONFIGS=`ls /vboxguests/*/VirtualBox\ VMs/*/*.vbox`
	PORT_USED_COUNT=0
	for VBOX_CONFIG in ${VBOX_CONFIGS} ; do egrep "name=\"TCP\/Ports\" value=\"60${VNC_OFFSET}\"" "${VBOX_CONFIG}" > /dev/null ; if [ ${?} -eq 0 ] ; then PORT_USED_COUNT=$(( ${PORT_USED_COUNT} + 1 )) ; fi ;done
	if [ ${PORT_USED_COUNT} -gt 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The VNC port offset is already in use!\n"
		exit 124
	fi
	IFS=${PREVIOUS_IFS}

	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the 'update-config' subcommand to keep the repo up-to-date.\n"
		exit 125
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	## TODO: check what SUM_EXIT_CODE (below here) is for
	SUM_EXIT_CODE=0

	zfs clone ${POOL_NAME}/vboxguests/RemoteDesktop@${RD_TEMPLATE_NAME} ${POOL_NAME}/vboxguests/${RD_NAME}

	mv "/vboxguests/${RD_NAME}/VirtualBox VMs/RemoteDesktop" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}"
	mv "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/RemoteDesktop.vbox" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/${RD_NAME}.vbox"
	mv "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/RemoteDesktop.vbox-prev" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/${RD_NAME}.vbox-prev"
	mv "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/RemoteDesktop.vdi" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/${RD_NAME}.vdi"

	sed -i "" "s/RemoteDesktop/${RD_NAME}/g" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/${RD_NAME}.vbox"
	sed -i "" "s/RemoteDesktop/${RD_NAME}/g" "/vboxguests/${RD_NAME}/VirtualBox VMs/${RD_NAME}/${RD_NAME}.vbox-prev"

	find /vboxguests/${RD_NAME}/.kde -exec sed -i "" "s/RemoteDesktop/${RD_NAME}/g" {} \; 2> /dev/null
	find /vboxguests/${RD_NAME}/.kde4 -exec sed -i "" "s/RemoteDesktop/${RD_NAME}/g" {} \; 2> /dev/null
	find /vboxguests/${RD_NAME}/.config -exec sed -i "" "s/RemoteDesktop/${RD_NAME}/g" {} \; 2> /dev/null
	find /vboxguests/${RD_NAME}/.VirtualBox -exec sed -i "" "s/RemoteDesktop/${RD_NAME}/g" {} \; 2> /dev/null

	cpdup /usr/local/etc/rc.d/RemoteDesktop /usr/local/etc/rc.d/${RD_NAME}
	sed -i "" "s/RemoteDesktop/${RD_NAME}/g" /usr/local/etc/rc.d/${RD_NAME}

	pw useradd -n ${RD_NAME} -c "Remote Desktop ${VNC_OFFSET}" -d /vboxguests/${RD_NAME} -G vboxusers -s /usr/local/bin/bash
	chown -R ${RD_NAME}:${RD_NAME} /vboxguests/${RD_NAME}

	su - ${RD_NAME} -c "/usr/local/bin/VBoxManage setproperty vrdeextpack VNC"
	su - ${RD_NAME} -c "/usr/local/bin/VBoxManage modifyvm ${RD_NAME} --vrdeport 60${VNC_OFFSET}"
	su - ${RD_NAME} -c "/usr/local/bin/VBoxManage modifyvm ${RD_NAME} --vrdeproperty VNCPassword=${VNC_PASSWORD}"
	su - ${RD_NAME} -c "/usr/local/bin/VBoxManage modifyvm ${RD_NAME} --macaddress1 auto"

	cat configs/${HOST_NAME}/etc/rc.conf | grep ${RD_NAME}
	if [ $? != 0 ]
	then
		echo "${RD_NAME}_enable=\"YES\"" >> configs/${HOST_NAME}/etc/rc.conf
	fi

	touch /var/log/${RD_NAME}.log
	chown ${RD_NAME}:${RD_NAME} /var/log/${RD_NAME}.log

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'create-remote-desktop-instance' for '${RD_NAME}'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\nPushing changes to ${REPO_NAME} remote repo...\n"
		git push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished creating the remote desktop '${RD_NAME}'.${NRML}"
	echo -e "\n${LGRN}To start the remote desktop, use the command:${NRML}"
	echo -e "${LBLU}service ${RD_NAME} start${NRML}\n"

	cd -

}

get_jail_id_from_name ()
{
	# ${1} is jail name

	JAIL_ID_FILE=`ls -1 /var/run/jail_${1}.id | head -1`
	JAIL_ID=`cat ${JAIL_ID_FILE}`

}

start_jail_service ()
{
	# ${1} is jail name
	# ${2} is service name
	# ${3} may be --allow-restart

	get_jail_id_from_name ${1}

	echo -e "\n${YELL}Starting the service '${2}' in the jail '${1}'...${NRML}\n"

	jexec ${JAIL_ID} service ${2} start > /dev/null 2>&1

	if [ ${?} -ne 0 ] && [ "${3}" = "--allow-restart" ]
	then
		jexec ${JAIL_ID} service ${2} restart > /dev/null 2>&1
	fi

	if [ ${?} -ne 0 ]
	then
		echo -e "${LRED}WARNING:${NRML} Failed to start service '${2}' in jail '${1}'!\n"
	else
		echo -e "${YELL}INFO:${NRML} Successfully started service '${2}' in jail '${1}'!\n"
	fi

}

create_jail ()
{

	if [ "${3}" = "--non-interactive" ]
	then
		IS_INTERACTIVE="no"
	else
		IS_INTERACTIVE="yes"
	fi

	if [ ${#} -ne 2 ]
	then
		if [ ${#} -ne 3 ] || [ "${IS_INTERACTIVE}" = "yes" ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Incorrect number of arguments supplied."
			echo -e "       ${LRED}Aborting.${NRML}\n"
			usage
			exit 130
		fi
	fi

	JAIL_NAME=${1}
	JAIL_HOST_NAME=${2}

	cd /${REPO_NAME}

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo."
		echo -e "       Please use the 'new-host' subcommand first.\n"
		exit 131
	fi

	# Check that the jails subsystem is initialised and therefore we know the pool name.
	POOL_NAME=`cat ${FDO_CONFIG_ROOT}/jails_pool.conf 2> /dev/null`
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears that the jails subsystem is not initialised."
		echo -e "       Consider using the command:"
		echo -e "       ${LBLU}${SCRIPT_NAME} init-jails${NRML}\n"
		exit 132
	fi

	# Check that the jail_name has not already been used
	cat /etc/jail.conf | egrep "^${JAIL_NAME} {" > /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The jail_name 'JAIL_NAME' is already in use."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 133
	fi

	# Get version strings
	FREEBSD_VERSION_STRING=`freebsd-version`
	FREEBSD_VERSION=`freebsd-version | cut -d- -f1` 
	FREEBSD_MAJOR_VERSION=`echo ${FREEBSD_VERSION} | cut -d. -f1`
	FREEBSD_CADENCE=`freebsd-version | cut -d- -f2` 
	FREEBSD_PATCH_LEVEL=`freebsd-version | cut -d- -f3`

	TEMPLATE_SNAPSHOT=`zfs list -t all | awk '{print $1}' | cut -d@ -f2| egrep "${FREEBSD_VERSION}" | sort | tail -1`

	LAN_NET_IFACE=`cat ${FDO_CONFIG_ROOT}/net_iface_lan.conf`

	if [ "${JAIL_IP}" = "" ]
	then
		FIRST_AVAILABLE_IP=12
		LOOP="true"
		while [ "${LOOP}" = "true" ]
		do
			ifconfig ${LAN_NET_IFACE} | egrep "inet.*netmask 0xffffffff" | egrep "${SERVICES_LAN_SUBNET_C}.${FIRST_AVAILABLE_IP}" > /dev/null 2>&1
			if [ ${?} -ne 0 ]
			then
				LOOP=0
			else
				FIRST_AVAILABLE_IP=$(( ${FIRST_AVAILABLE_IP} +1 ))
			fi
		done
		JAIL_IP="${SERVICES_LAN_SUBNET_C}.${FIRST_AVAILABLE_IP}"
	fi

	zfs clone ${POOL_NAME}/jails/template@${TEMPLATE_SNAPSHOT} ${POOL_NAME}/jails/${JAIL_NAME}

	# Create entry in configs/${HOST_NAME}/etc/jail.conf
	echo "" >> configs/${HOST_NAME}/etc/jail.conf
	echo "${JAIL_NAME} {" >> configs/${HOST_NAME}/etc/jail.conf
	echo "        host.hostname = \"${JAIL_HOST_NAME}\";" >> configs/${HOST_NAME}/etc/jail.conf
	echo "        ip4.addr = ${JAIL_IP};" >> configs/${HOST_NAME}/etc/jail.conf
	echo "}" >> configs/${HOST_NAME}/etc/jail.conf

	# Prepare the jail fstab
	cp config-templates/new-host/etc/fstab.template configs/${HOST_NAME}/etc/fstab.${JAIL_NAME}
	sed -i "" "s|/jls/template/|/jls/${JAIL_NAME}/|" configs/${HOST_NAME}/etc/fstab.${JAIL_NAME}

	# Create IP address (alias) for the jail
	sed -i "" "s/^#\(ifconfig_${LAN_NET_IFACE}_alias.*${JAIL_IP}.*\)/\1/" configs/${HOST_NAME}/etc/rc.conf
	ifconfig ${LAN_NET_IFACE} inet ${JAIL_IP} netmask 255.255.255.255 alias

	# Copy latest resolv.conf file from current template jail filesystem (not snapshot)
	cp /jls/template/etc/resolv.conf /jls/${JAIL_NAME}/etc/resolv.conf

	# Install latest scripts to the jail
	install_scripts /jls/${JAIL_NAME}/

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	git add configs/${HOST_NAME}

	if [ "${IS_INTERACTIVE}" = "yes" ]
	then
		echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
		git commit -m "Updating host after 'create-jail ${JAIL_NAME} ${JAIL_HOST_NAME}'; ${HOST_NAME}."

		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\nPushing changes to ${REPO_NAME} remote repo...\n"
			git push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			fi
		fi

		echo -e "\n${LGRN}Congratulations! We have now finished creating the jail '${JAIL_NAME}'.${NRML}"
		echo -e "\n${LGRN}To login to the jail, use the command:${NRML}"
		echo -e "${LBLU}jlogin ${JAIL_NAME}${NRML}\n"
	
		question_yes_no "Would you like to start the jail '${JAIL_NAME}' now?"
		if [ "${ANSWER}" = "yes" ]
		then
			service jail start ${JAIL_NAME}
		fi
	else
		service jail start ${JAIL_NAME}
	fi

	cd -

}

revert_create_jail ()
{
	JAIL_TO_REVERT=${1}

	echo -e "\n${YELL}Reverting create jail for ${JAIL_TO_REVERT}...${NRML}\n"

	cd /${REPO_NAME}

	# Stop the jail
	service jail stop ${JAIL_TO_REVERT}
	sleep 10 
	jls | tail -n +2 | awk '{print $3}' | egrep "${JAIL_TO_REVERT}" > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		JAIL_ID_FILE=`ls -1 /var/run/jail_${JAIL_TO_REVERT}.id | head -1`
		JAIL_ID=`cat ${JAIL_ID_FILE}`
		jail -r ${JAIL_ID} 
		umount -f /jls/${JAIL_TO_REVERT}/usr/local/etc/ssl/certs
	fi

	# Destroy additional jail recipe datasets in reverse order
	REV_RECIPE_ZFS_DATASETS=`echo ${RECIPE_ZFS_DATASETS} | rev`
	for REV_RECIPE_ZFS_DATASET in ${REV_RECIPE_ZFS_DATASETS}
	do
		RECIPE_ZFS_DATASET=`echo ${REV_RECIPE_ZFS_DATASET} | rev`
		zfs destroy -f ${RECIPE_ZFS_DATASET}
	done

	# Destroy the jail filesystem
	POOL_NAME=`cat ${FDO_CONFIG_ROOT}/jails_pool.conf 2> /dev/null`
	zfs destroy -rf ${POOL_NAME}/jails/${JAIL_TO_REVERT}

	# Delete jail config directory from local repo
	rm -rf configs/${JAIL_TO_REVERT}@${HOST_NAME}

	# Roll back local repo to last commit
	git reset --hard HEAD

	# Install back old host configs
	install_file_tree configs/${HOST_NAME} /

	echo -e "\n${YELL}Finished reverting jail creation! Exiting.${NRML}\n"
	exit 139

}

edit_recipe_configs ()
{

	echo -e "\n"

	for CONFIG_FILE in ${RECIPE_CONFIG_FILES}
	do 
		FILE_NAME=`basename ${CONFIG_FILE}`
		if [ -d ${CONFIG_FILE} ] || [ "${FILE_NAME}" = "${PKG_REPO_CONF_FILE}" ] || [ "${FILE_NAME}" = "${PKG_REPO_CERT_FILE}" ] 
		then
			continue
		fi

		question_yes_no "Would you like to edit the recipe config '${CONFIG_FILE}'?"
		if [ "${ANSWER}" = "yes" ]
		then
			if [ "${EDITOR}" = "" ]
			then
				EDITOR=ee
			fi
			echo ""
			${EDITOR} ${CONFIG_FILE}
			echo ""
		fi
	done

}

create_jail_from_recipe ()
{

	## TODO: more checks like whether jail name already exists and if recipe name is valid

	if [ ${#} -ne 3 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Incorrect number of arguments supplied."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		usage
		exit 140
	fi

	JAIL_NAME=${1}
	JAIL_HOST_NAME=${2}
	JAIL_RECIPE_NAME=${3}

	# Source the recipe
	. /${REPO_NAME}/jail-recipes/${JAIL_RECIPE_NAME}/${JAIL_RECIPE_NAME}

	echo -e "\n\n${YELL}Creating a blank jail with the IP address '${JAIL_IP}'...${NRML}\n"

	# Create a blank jail (non-interactively)
	create_jail ${JAIL_NAME} ${JAIL_HOST_NAME} --non-interactive
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Creation of blank jail failed."
		echo -e "       ${LRED}Aborting.${NRML}\n"
		revert_create_jail ${JAIL_NAME}
	fi

	# Source the recipe again to pick up any updated variables
	. /${REPO_NAME}/jail-recipes/${JAIL_RECIPE_NAME}/${JAIL_RECIPE_NAME}

	echo -e "\n\n${YELL}Creating any additional jail recipe datasets...${NRML}\n"

	# Create additional jail recipe datasets
	COUNT=0
	for RECIPE_ZFS_DATASET in ${RECIPE_ZFS_DATASETS}
	do
		COUNT=$(( ${COUNT} + 1 ))
		RECIPE_ZFS_MOUNTPOINT=`echo ${RECIPE_ZFS_MOUNTPOINTS} | awk -v column="${COUNT}" '{print $column}'`
		zfs create -o mountpoint=${RECIPE_ZFS_MOUNTPOINT} ${RECIPE_ZFS_DATASET}
	done

	cd /${REPO_NAME}

	# Install recipe config templates to new jails' repo config directory
	mkdir configs/${JAIL_NAME}@${HOST_NAME}
	install_file_tree jail-recipes/${JAIL_RECIPE_NAME}/config-templates configs/${JAIL_NAME}@${HOST_NAME}/

	# Install initial config templates to the new jail
	install_file_tree configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/

	echo -e "\n\n${YELL}Cooking '${JAIL_RECIPE_NAME}' recipe for '${JAIL_NAME}'...${NRML}\n"

	# Cook the sourced recipe
	cook_recipe

	if [ "${RECIPE_SUCCESS}" = "yes" ] || [ "${RECIPE_SUCCESS}" = "devel" ]
	then
		# Interactively edit the configs touched by the recipe
		RECIPE_CONFIG_FILES=`find configs/${JAIL_NAME}@${HOST_NAME} -print`
		edit_recipe_configs

		# Install any new or modfied configs
		install_file_tree configs/${HOST_NAME} /
		install_file_tree configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/

		# Restart pf if required
		if [ "${RECIPE_REQUIRES_PF_RELOAD}" = "yes" ]
		then
			service pf reload
		fi

		# Restart jail if required
		if [ "${RECIPE_REQUIRES_JAIL_RESTART}" = "yes" ]
		then
			service jail restart ${JAIL_NAME}
		fi

		# Start jail recipe services
		for SERVICE in ${START_JAIL_SERVICES}
		do
			start_jail_service ${JAIL_NAME} ${SERVICE} --allow-restart
			sleep 3
		done

	elif [ "${RECIPE_SUCCESS}" = "no" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Jail recipe failed!\n"
		revert_create_jail ${JAIL_NAME}
	else
		echo -e "\n${ORGN}WARNING:${NRML} The recipe did not return a valid RECIPE_SUCCESS variable!\n"
	fi

	if [ "${RECIPE_SUCCESS}" = "devel" ]
	then
		echo -e "\n${LGRN}After tasting your new recipe, you may run the command:${NRML}"
		echo -e "${LBLU}${SCRIPT_NAME} revert-create-jail ${JAIL_NAME}${NRML}\n"
	fi

	if [ "${RECIPE_SUCCESS}" = "yes" ]
	then
		git add configs/${HOST_NAME}
		git add configs/${JAIL_NAME}@${HOST_NAME}
		git commit -m "Updating host after 'create-jail-from-recipe ${JAIL_NAME} ${JAIL_HOST_NAME} ${JAIL_RECIPE_NAME}'; ${HOST_NAME}."

		if [ "${REPO_URI}" != "local" ]
		then
			echo -e "\nPushing changes to ${REPO_NAME} remote repo...\n"
			git push origin master
			if [ $? -ne 0 ]
			then
				echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
				echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
			fi
		fi
 
		if [ -f /jls/${JAIL_NAME}/usr/local/etc/ssl/jail-certs.list ]
		then
			echo -e "\n${ORNG}NOTICE:${NRML} This jail requires some SSL certificates to be placed in the directory  "
			echo -e "         '/usr/local/etc/ssl/certs'. They can be copied or symlinked to the     "
			echo -e "         correct file name either manually or by using the 'fdo-cert-manager'   "
			echo -e "         utility. To see a list of the required certificate files, use the      "
			echo -e "         following command:                                                     "
			echo -e "         ${LBLU}cat /jls/${JAIL_NAME}/usr/local/etc/ssl/jail-certs.list${NRML}\n"
		fi

		echo -e "\n${LGRN}Congratulations! We have now finished creating the jail '${JAIL_NAME}'.${NRML}"
		echo -e "${LGRN}To login to the jail, use the command:${NRML}"
		echo -e "${LBLU}jlogin ${JAIL_NAME}${NRML}\n"
	fi

	cd -

}

init_clonezilla_images ()
{

	cd /${REPO_NAME}

	# Check that the host is already registered.
	if [ ! -d "configs/${HOST_NAME}" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} This host has not yet been registered in the repo!"
		echo -e "       Please use the 'new-host' subcommand first.\n"
		exit 160
	fi

	# Check for unsaved registered host config files
	echo -e "\n${YELL}Now we need to check if there are any unsaved changes to this hosts registered${NRML}"
	echo -e "${YELL}config files...${NRML}\n"
	check_configs configs/${HOST_NAME} / --silent | grep "OUT OF CHECK"
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} One or more host config files are not updated in the repo."
		echo -e "       Please use the 'update-config' subcommand to keep the repo up-to-date.\n"
		exit 161
	fi

	echo -e "\n${LGRN}All registered configs for this host are up to date in the repo!${NRML}\n"

	# Get pool name to use for Clonezilla images.
	POOL_NAME=""
	POOLS_AVAILABLE=`zpool list | tail -n +2 | awk '{print $1}'`
	NUM_POOLS=`echo ${POOLS_AVAILABLE} | wc -w`
	if [ ${NUM_POOLS} -lt 1 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} No pools found. Unable to proceed.\n"
		exit 162
	fi
	if [ ${NUM_POOLS} -lt 2 ]
	then
		POOL_NAME=${POOLS_AVAILABLE}
	else
		while [ "${POOL_NAME}" = "" ]
		do
			dialog --no-items --no-cancel --menu "Select pool for Clonezilla images:" 12 60 10 ${POOLS_AVAILABLE} 2> ${DIALOG_OUT_FILE}
			POOL_NAME_TEMP=`cat ${DIALOG_OUT_FILE}`
			question_yes_no "You have selected '${POOL_NAME_TEMP}' to store the Clonezilla images.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				POOL_NAME="${POOL_NAME_TEMP}"
			fi
		done
	fi

	# Get the LAN IP address of this host
	LAN_NET_IFACE=`cat ${FDO_CONFIG_ROOT}/net_iface_lan.conf`
	HOST_IP=`ifconfig ${LAN_NET_IFACE} | egrep "inet.*netmask.*" | egrep -v "inet.*netmask 0xffffffff" | head -1 | awk '{print $2}'`
	if [ "${HOST_IP}" = "" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} A LAN IP address for this host could not be found!"
		echo -e "       ${LRED}Aborting.${NRML}\n"
		exit 163
	fi

	# Warn if Clonezilla images dataset already exists.
	zfs list ${POOL_NAME}/clonezilla-images 2> /dev/null
	if [ ${?} -eq 0 ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The ZFS dataset '${POOL_NAME}/clonezilla-images' already exists!\n"
	fi

	sed -i "" "s/mountd_enable=\"NO\"/mountd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/nfs_server_enable=\"NO\"/nfs_server_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpc_lockd_enable=\"NO\"/rpc_lockd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpc_statd_enable=\"NO\"/rpc_statd_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf
	sed -i "" "s/rpcbind_enable=\"NO\"/rpcbind_enable=\"YES\"/" configs/${HOST_NAME}/etc/rc.conf

	# Install host configs to the system
	install_file_tree configs/${HOST_NAME} /

	# Create the ZFS dataset for the Clonezilla images
	zfs create -o mountpoint=/usr/home/partimag ${POOL_NAME}/clonezilla-images

	touch /etc/exports

	echo -e ""

	# Start the NFS services
	service rpcbind start
	service lockd start
	service nfsd start

	# Add mountpoint to NFS exports file
	cat /etc/exports | egrep "^/usr/home/partimag " > /dev/null 2>&1
	if  [ ${?} -ne 0 ]
	then
		echo "/usr/home/partimag -maproot=root -network 192.168.10 -mask 255.255.0.0" >> /etc/exports
		echo -e ""
		service mountd reload
	fi

	echo -e "\n\n${YELL}We are now ready to push the updated host configs up to the remote repo.${NRML}\n"
	git add configs/${HOST_NAME}
	git commit -m "Updating host after 'init-clonezilla-images'; ${HOST_NAME}."

	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\nPushing changes to ${REPO_NAME} remote repo...\n"
		git push origin master
		if [ $? -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} Failed to push commit to remote git repo."
			echo -e "       Please consider manually running 'git push' from within /${REPO_NAME}.\n"
		fi
	fi

	echo -e "\n${LGRN}Congratulations! We have now finished setting up an NFS share for Clonezilla${NRML}"
	echo -e "${LGRN}images.${NRML}\n"
	echo -e "${YELL}Clonezilla images NFS version:      3${NRML}"
	echo -e "${YELL}Clonezilla images host address:     ${HOST_IP}${NRML}"
	echo -e "${YELL}Clonezilla images server directory: /home/partimag${NRML}\n"

	cd -

}

merge_local_repo_to_remote ()
{
	# Test that we are actually using a local repo
	if [ "${REPO_URI}" != "local" ]
	then
		echo -e "\n${LRED}ERROR:${NRML} It appears you are already using a remote repo!"
		echo -e "       Aborting."
		exit 180
	fi

	# Ask for the URI of the remote repo.
	REMOTE_REPO_URI=""
	while [ "${REMOTE_REPO_URI}" = "" ]
	do
		echo -e "\n${LCYN}Enter the remote git repo URI:${NRML}"
		read REMOTE_REPO_URI_TEMP
		# Allow use to change their mind about type of repo
		if [ "${REMOTE_REPO_URI_TEMP}" = "" ]
		then
			break
		fi
		# Test the input to see if it is a valid URI (URL)
		test_valid_simple_url "${REMOTE_REPO_URI_TEMP}"
		if [ "${VALID_URL}" = "yes" ]
		then
			question_yes_no "\nYou have entered '${REMOTE_REPO_URI_TEMP}'\nas the remote git repo URI.\nIs this correct?"
			if [ "${ANSWER}" = "yes" ]
			then
				REMOTE_REPO_URI=${REMOTE_REPO_URI_TEMP}
			fi
		else
			echo -e "\n${LRED}ERROR:${NRML} remote git repo URI is invalid!\n"
		fi
	done

	# Check that the remote repo is valid and that this hostname does not already exist. 
	cd /tmp
	rm -rf "${REPO_NAME}"
	echo -e "\n${YELL}We need to check that this host does not already exist in the remote repo.${NRML}"
	echo -e "${YELL}Please enter the remote repo credentials when prompted...${NRML}\n"
	git clone "${REMOTE_REPO_URI}" "${REPO_NAME}"
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to clone the remote repo!"
		echo -e "       Aborting."
		exit 181
	fi
	if [ ! -d "${REPO_NAME}/configs/" ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} The remote repo does not contain a config directory."
		echo -e "         This usually means that it is a newly created, empty repo.\n"
	elif [ -d  "${REPO_NAME}/configs/${HOST_NAME}" ]
	then
		rm -rf "${REPO_NAME}"
		echo -e "\n${LRED}ERROR:${NRML} This host already exists in the remote repo!"
	echo -e "       Consider removing or renaming the stale host config directory in the"
		echo -e "       remote repo."
		echo -e "       Aborting."
		exit 182
	else
		echo -e "\n${LGRN}The remote repo seems to be ok!${NRML}\n"
	fi
	rm -rf "${REPO_NAME}"

	# Move into the local repo.
	cd "/${REPO_NAME}"

	# Record last local commit, so that we can rewind if needed.
	LAST_LOCAL_COMMIT=`git log -1 | head -1 | awk '{print $2}'`

	# Check for an existing (stale) remote repo, and if user agrees, proceed and delete it.
	EXISTING_REMOTE=`git remote -v | egrep "^origin" | grep '(push)$' | awk '{print $2}'`
	if [ "${EXISTING_REMOTE}" != "" ]
	then
		echo -e "\n${ORNG}WARNING:${NRML} There appears to be an existing remote origin in the local repo!"
		echo -e "         Git URI of origin: ${EXISTING_REMOTE}\n"
		question_yes_no "Would you like to proceed?"
		if [ "${ANSWER}" = "yes" ]
		then
			git remote remove origin
		else
			exit 183
		fi
	fi

	# Add the remote repo URI as this local repos' remote.
	git remote add origin "${REMOTE_REPO_URI}" > /dev/null 2>&1
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to add the remote repo as the origin!"
		echo -e "       Aborting."
		exit 184
	fi

	# Fetch the remote repo.
	echo -e "\n${YELL}Next we need to fetch the remote repo into our local repo.${NRML}"
	echo -e "${YELL}Please enter the remote repo credentials when prompted...${NRML}\n"
	git fetch
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} Unable to fetch the remote repo (origin/master)!"
		echo -e "       Aborting."
		git remote remove origin
		exit 185
	fi

	# Align the master branch on both local and remote repo.
	git branch --set-upstream-to=origin/master master > /dev/null 2>&1
	if [ ${?} -eq 0 ]
	then
		# Remote is non-empty. Perform a merge of the local and remote master branch.
		echo -e "\n${YELL}Next we need to merge the remote repo and our local repo...${NRML}\n"
		pause_prompt 8
		git merge -m "Merging local repo from host '${HOST_NAME}'."
		if [ ${?} -ne 0 ]
		then
			echo -e "\n${LRED}ERROR:${NRML} The merge operation seems to have failed!"
			echo -e "       Aborting."
		git remote remove origin
		exit 186
		fi
	fi

	# Lastly, push the local repo deltas to the remote repo.
	echo -e "\n${YELL}Now we need to push the local repo changes to the remote repo.${NRML}"
	echo -e "${YELL}Please enter the remote repo credentials when prompted...${NRML}\n"
	git push origin master
	if [ ${?} -ne 0 ]
	then
		echo -e "\n${LRED}ERROR:${NRML} The push operation seems to have failed!"
		echo -e "       Aborting."
		git remote remove origin
		git reset --soft "${LAST_LOCAL_COMMIT}"
		exit 187
	fi

	REPO_URI="${REMOTE_REPO_URI}"
	echo "${REPO_URI}" >  "${FDO_CONFIG_ROOT}/fdo-server-repo.conf"
	
	echo -e "\n\n${LGRN}Congratulations! Successfully merged his hosts local repo to the remote repo.${NRML}\n"

}

##### MAIN EXECUTION THREAD ####################################################

SUB_CMD=${1}
SUB_ARG1=${2}
SUB_ARG2=${3}
SUB_ARG3=${4}
HOST_NAME=`hostname -s`
FQHN=`hostname -f`
DOMAIN_NAME=`echo ${FQHN} | sed "s/${HOST_NAME}\.//"`

if [ "${SUB_CMD}" != "connect-internet" ]
then
	fetch_latest_self
fi

check_repo_config

if [ $# -lt 1 ]
then
	usage
	exit 1
fi


case ${SUB_CMD} in

	install-scripts)
		update_local_repo

		# Install scripts to the host
		install_scripts /

		# Install scripts to the jails
		for JAIL_DIR in `ls -1 /jls 2> /dev/null`
		do
			install_scripts /jls/${JAIL_DIR}/
		done
		;;

	add-script)
		# Add new script to local and remote git repo
		update_local_repo
		add_script ${SUB_ARG1}
		;;

	update-script)
		# Update a script to local and remote git repo
		update_local_repo
		update_script ${SUB_ARG1}
		;;

	install-configs)
		update_local_repo

		# Install configs to the host
		question_yes_no "Are you sure you want to install all configs from the repo to this host?"
		if [ "${ANSWER}" = "yes" ]
		then
			install_configs configs/${HOST_NAME} /
		fi

		# Install configs to the jails
		cd /${REPO_NAME}
		for JAIL_NAME in `ls -1 configs | grep -e "@${HOST_NAME}" | cut -d@ -f1`
		do
			question_yes_no "Are you sure you want to install all configs from the repo to the\n'${JAIL_NAME}' jail?"
			if [ "${ANSWER}" = "yes" ]
			then
				install_configs configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/
			fi
		done
		cd -
		;;

	check-configs)
		update_local_repo

		# Check configs for the host.
		echo -e "\nChecking configs for the host...\n"
		check_configs configs/${HOST_NAME} / ${SUB_ARG1}

		# Check configs for the jails.
		cd /${REPO_NAME}
		for JAIL_NAME in `ls -1 configs | grep -e "@${HOST_NAME}" | cut -d@ -f1`
		do
			echo -e "\nChecking configs for the '${JAIL_NAME}' jail...\n"
			check_configs configs/${JAIL_NAME}@${HOST_NAME} /jls/${JAIL_NAME}/ ${SUB_ARG1}
		done
		cd -
		;;

	add-config)
		# Add a config file from the system to local and remote git repo.
		update_local_repo
		add_config ${SUB_ARG1}
		;;

	update-config)
		# Update a config file from the system to local and remote git repo.
		update_local_repo
		update_config ${SUB_ARG1}
		;;

	connect-internet)
		# Create a non-persistent connection to the internet so that we can access FDo resources etc.
		connect_internet
		;;

	new-host)
		# Register a new host in the repo, install essential packages and initial configuration from templates.
		new_host ${SUB_ARG1} ${SUB_ARG2}
		;;

	patch-host)
		# Use freebsd-update to update to latest patch level.
		patch_host
		;;

	setup-vnc-desktop)
		# Install minimal X desktop environment accessible via VNC using IceWM, Roxterm, Xfe, Firefox and TightVNC.
		update_local_repo
		setup_vnc_desktop
		;;

	init-hotdesking)
		# Initialise the NIS/NFS hostdesking subsystem.
		update_local_repo
		init_hotdesking
		;;

	init-clonezilla-images)
		# Initialise the NFS share for Clonezilla images.
		update_local_repo
		init_clonezilla_images
		;;

	merge-local-repo-to-remote)
		# Move and merge a local repo to a private remote repo
		update_local_repo
		merge_local_repo_to_remote
		;;

	init-jails)
		# Initialise the FDo jails subsystem.
		update_local_repo
		init_jails
		;;

	create-jail)
		# Create a vanilla jail.
		update_local_repo
		JAIL_IP=""
		create_jail ${SUB_ARG1} ${SUB_ARG2}
		;;

	create-jail-from-recipe)
		# Create a jail from a jail recipe.
		update_local_repo
		JAIL_IP=""
		create_jail_from_recipe ${SUB_ARG1} ${SUB_ARG2} ${SUB_ARG3}
		;;

	revert-create-jail)
		# Revert back to before last jail creation (developers).
		revert_create_jail ${SUB_ARG1}
		;;

	init-remote-desktops)
		# Initialise the FDo remote desktop subsystem (currently based on VirtualBox).
		update_local_repo
		init_remote_desktops
		;;

	create-remote-desktop-template)
		# Create a template (uses ZFS snapshots) for a particular type of remote desktop.
		create_remote_desktop_template ${SUB_ARG1}
		;;

	create-remote-desktop-instance)
		# Create a VM instance from a remote desktop template (uses ZFS snapshots).
		update_local_repo
		create_remote_desktop_instance ${SUB_ARG1} ${SUB_ARG2} ${SUB_ARG3}
		;;

	*)
		echo ""
		echo -e "${LRED}ERROR:${NRML} Sub-command ${SUB_CMD} is unknown!"
		usage
		exit 2
		;;

esac

################################################################################
